import { createRequire as topLevelCreateRequire } from 'module'
const require = topLevelCreateRequire(import.meta.url || __dirname)
import {
  getClient
} from "./chunk-SN7XVJE5.js";

// http/index.ts
import assert from "node:assert";
import path from "node:path";
import stream from "node:stream";
import { AsyncLocalStorage } from "node:async_hooks";

// ../../lib/aws/s3.ts
import { ReadableStream as ReadableStream2 } from "node:stream/web";
import { Readable } from "node:stream";
async function getObject(url) {
  const client = await getClient();
  const response = await client.fetch(url);
  if (response.status === 200) {
    const body = response.body instanceof ReadableStream2 ? response.body : response.body instanceof Readable ? Readable.toWeb(response.body) : null;
    return {
      body,
      etag: response.headers.get("etag"),
      contentType: response.headers.get("content-type"),
      cacheControl: response.headers.get("cache-control")
    };
  }
}

// ../../lib/fs/index.ts
import { ReadableStream as ReadableStream3 } from "node:stream/web";
import fs from "fs/promises";
var CHUNK_SIZE = 1024;
function createReadableStream(filename) {
  let fileHandle;
  let position = 0;
  return new ReadableStream3({
    async start() {
      fileHandle = await fs.open(filename, "r");
    },
    async pull(controller) {
      const buffer = new Uint8Array(CHUNK_SIZE);
      const { bytesRead } = await fileHandle.read(buffer, 0, CHUNK_SIZE, position);
      if (bytesRead === 0) {
        await fileHandle.close();
        controller.close();
      } else {
        position += bytesRead;
        controller.enqueue(buffer.subarray(0, bytesRead));
      }
    },
    cancel() {
      return fileHandle.close();
    }
  });
}

// ../../lib/node-http/get-framework.ts
import http2 from "node:http";

// ../../lib/node-http/response.ts
import http from "node:http";
import { Readable as Readable2 } from "node:stream";
var headerEnd = "\r\n\r\n";
var BODY = Symbol();
var HEADERS = Symbol();
function getString(data) {
  if (Buffer.isBuffer(data)) {
    return data.toString("utf8");
  } else if (typeof data === "string") {
    return data;
  } else {
    throw new Error(`response.write() of unexpected type: ${typeof data}`);
  }
}
function addData(stream2, data) {
  if (Buffer.isBuffer(data) || typeof data === "string" || data instanceof Uint8Array) {
    stream2.push(Buffer.from(data));
  } else {
    throw new Error(`response.write() of unexpected type: ${typeof data}`);
  }
}
var ServerlessResponse = class extends http.ServerResponse {
  _header = "";
  _wroteHeader = false;
  constructor(request) {
    super(request);
    const body = new Readable2({ read() {
    } });
    this[BODY] = body;
    this[HEADERS] = {};
    this.useChunkedEncodingByDefault = false;
    this.chunkedEncoding = false;
    this._header = "";
    this.assignSocket({
      _writableState: {},
      writable: true,
      // @ts-ignore
      on: Function.prototype,
      // @ts-ignore
      removeListener: Function.prototype,
      // @ts-ignore
      destroy: Function.prototype,
      // @ts-ignore
      cork: Function.prototype,
      // @ts-ignore
      uncork: Function.prototype,
      // @ts-ignore
      write: (data, encoding, cb) => {
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = void 0;
        }
        if (this._header === "" || this._wroteHeader) {
          addData(body, data);
        } else {
          const string = getString(data);
          const index = string.indexOf(headerEnd);
          if (index !== -1) {
            const remainder = string.slice(index + headerEnd.length);
            addData(body, remainder);
            this._wroteHeader = true;
            this.emit("headers");
          }
        }
        if (typeof cb === "function") {
          cb();
        }
        return true;
      }
    });
    this.once("finish", () => {
      body.push(null);
      this.emit("close");
    });
  }
  static async headers(res) {
    await new Promise((resolve) => {
      if (res._wroteHeader) {
        resolve();
      } else {
        res.once("headers", resolve);
      }
    });
    const headers = typeof res.getHeaders === "function" ? res.getHeaders() : res._headers;
    return Object.assign(headers, res[HEADERS]);
  }
  static body(response) {
    if ([101, 103, 204, 205, 304].includes(response.statusCode)) {
      return null;
    }
    return response[BODY];
  }
  // Express does some strange prototype rewriting, so you can't use instance methods to read the body
  get headers() {
    return this[HEADERS];
  }
  setHeader(key, value) {
    if (this._wroteHeader) {
      this[HEADERS][key] = value;
    } else {
      super.setHeader(key, value);
    }
    return this;
  }
  writeHead(statusCode, reason, obj) {
    if (reason || obj) {
      let headers = {};
      if (typeof reason === "string" && obj) {
        headers = obj;
      } else if (typeof reason === "object") {
        headers = reason;
      }
      for (const name in headers) {
        this.setHeader(name, headers[name]);
        if (!this._wroteHeader) {
          break;
        }
      }
    }
    super.writeHead(statusCode, reason, obj);
    return this;
  }
};

// ../../lib/node-http/get-framework.ts
function common(cb) {
  return (request) => {
    const response = new ServerlessResponse(request);
    cb(request, response);
    return response;
  };
}
function getFramework(app) {
  if (app instanceof http2.Server) {
    return (request) => {
      const response = new ServerlessResponse(request);
      app.emit("request", request, response);
      return response;
    };
  }
  if (typeof app.callback === "function") {
    return common(app.callback());
  }
  if (typeof app.handle === "function") {
    return common((request, response) => {
      app.handle(request, response);
    });
  }
  if (typeof app.handler === "function") {
    return common((request, response) => {
      app.handler(request, response);
    });
  }
  if (typeof app._onRequest === "function") {
    return common((request, response) => {
      app._onRequest(request, response);
    });
  }
  if (typeof app === "function") {
    return common(app);
  }
  if (app.router && typeof app.router.route == "function") {
    return common((req, res) => {
      const { url, method, headers } = req;
      app.router.route({ url, method, headers, body: req }, res);
    });
  }
  if (app._core && typeof app._core._dispatch === "function") {
    return common(
      app._core._dispatch({
        app
      })
    );
  }
  if (typeof app.ready === "function") {
    return async (request) => {
      const response = new ServerlessResponse(request);
      await app.ready();
      app.server.emit("request", request, response);
      return response;
    };
  }
  if (typeof app.main === "function") {
    return common(app.main);
  }
  throw new Error("Unsupported framework");
}

// ../../lib/node-http/create-request.ts
import { Readable as Readable3 } from "node:stream";
import { ReadableStream as ReadableStream4 } from "node:stream/web";

// ../../lib/node-http/request.ts
import http3 from "node:http";
var ServerlessRequest = class extends http3.IncomingMessage {
  // type dis
  requestContext;
  // type dis
  apiGateway;
  // For backwards compatibility with cloud adapter
  rawBody = Buffer.alloc(0);
  // Keep track if reading message has begun
  reading = false;
  constructor({
    method,
    url,
    headers,
    body,
    remoteAddress
  }) {
    super({
      encrypted: true,
      readable: false,
      remoteAddress,
      address: () => ({ port: 443 }),
      // @ts-ignore
      end: Function.prototype,
      // @ts-ignore
      destroy: Function.prototype
    });
    Object.assign(this, {
      ip: remoteAddress,
      complete: true,
      httpVersion: "1.1",
      httpVersionMajor: "1",
      httpVersionMinor: "1",
      method,
      headers,
      rawBody: Buffer.alloc(0),
      url
    });
    if (body) {
      body.on("readable", () => {
        if (this.reading) {
          this._read(0);
        }
        this.emit("readable");
      });
      body.on("close", () => {
        this.emit("close");
      });
      body.on("end", () => {
        this.push(null);
        this.emit("end");
      });
      body.on("error", () => {
        this.emit("error");
      });
    }
    this._read = (_size) => {
      this.reading = true;
      if (!body) {
        this.push(null);
        return;
      }
      let chunk;
      while (null !== (chunk = body.read())) {
        this.rawBody = Buffer.concat([this.rawBody, chunk]);
        if (!this.push(chunk)) {
          break;
        }
      }
    };
  }
};

// ../../lib/node-http/create-request.ts
function createRequest(request, context) {
  const httpHeaders = {};
  request.headers.forEach((value, key) => {
    httpHeaders[key] = value;
  });
  const url = new URL(request.url);
  const body = request.body instanceof Readable3 ? request.body : request.body instanceof ReadableStream4 ? Readable3.fromWeb(request.body) : null;
  return new ServerlessRequest({
    method: request.method,
    headers: httpHeaders,
    body,
    remoteAddress: context.remoteAddress,
    // IncomingMessage.url does not include the protocol and host
    url: `${url.pathname}${url.search}`
  });
}

// ../../lib/node-http/index.ts
function nodeAdapter(handler) {
  const getResponse = getFramework(handler);
  return async function(requestEvent, context) {
    const request = createRequest(requestEvent, context);
    const response = await getResponse(request);
    const nodeHeaders = await ServerlessResponse.headers(response);
    const headers = new Headers();
    const names = Object.keys(nodeHeaders);
    for (const name of names) {
      const value = nodeHeaders[name];
      if (value === void 0) {
        continue;
      }
      if (Array.isArray(value)) {
        for (const item of value) {
          headers.append(name, item);
        }
      } else {
        headers.set(name, value.toString());
      }
    }
    return new Response(ServerlessResponse.body(response), {
      headers,
      status: response.statusCode
    });
  };
}

// http/index.ts
var DEFAULT_HANDLER_TIMEOUT_MS = 29e3;
var Handler = class {
  prefix;
  handler;
  constructor(prefix, handler) {
    this.prefix = prefix;
    this.handler = handler;
  }
};
var requestContextStorage = new AsyncLocalStorage();
function normalize(path2) {
  return path2.replace(/\/+/g, "/").replace(/^\//, "").replace(/\/$/, "");
}
async function getStaticAssetObject(relativePath) {
  assert(process.env.AMPT_ASSETS_LOCATION, "AMPT_ASSETS_LOCATION is not set");
  const s3url = `https://${process.env.STORAGE_BUCKET}.s3.${process.env.AWS_REGION}.amazonaws.com/static-assets/${path.posix.join(process.env.AMPT_ASSETS_LOCATION, relativePath)}`;
  const result = await getObject(s3url).catch(() => void 0);
  if (!result) {
    return void 0;
  }
  return result;
}
async function getS3AssetResponse(relativePath, statusCode) {
  const result = await getStaticAssetObject(relativePath);
  if (!result) {
    throw new Error("Invalid path in http.on()");
  }
  return new Response(result.body, {
    status: statusCode,
    headers: {
      ...result.etag && { etag: result.etag },
      ...result.contentType && { "content-type": result.contentType },
      ...result.cacheControl && { "cache-control": result.cacheControl }
    }
  });
}
var Http = class _Http {
  useNode = false;
  loaders = [];
  listenerAdded = false;
  defaultNotFoundResponse = () => new Response("Not Found", { status: 404 });
  defaultErrorResponse = () => new Response("Internal Server Error", { status: 500 });
  parent;
  defaultTimeout = DEFAULT_HANDLER_TIMEOUT_MS;
  node;
  constructor(args) {
    this.useNode = args?.useNode || false;
    if (!this.useNode) {
      const nodeHttp = new _Http({ useNode: true, parent: this });
      delete nodeHttp.node;
      this.node = nodeHttp;
    } else {
      this.parent = args?.parent;
    }
  }
  static parseUseArgs(prefixOrHandler, _handler) {
    const handler = _handler ? _handler : prefixOrHandler;
    const eventPrefix = _handler ? normalize(prefixOrHandler) : "";
    return {
      handler,
      eventPrefix
    };
  }
  setTimeout(timeout) {
    const context = requestContextStorage.getStore();
    if (context) {
      context.setTimeout(timeout);
    } else {
      if (this.parent) {
        this.parent.setTimeout(timeout);
      } else {
        this.defaultTimeout = timeout;
      }
    }
  }
  use(prefixOrHandler, _handler) {
    const { handler, eventPrefix } = _Http.parseUseArgs(prefixOrHandler, _handler);
    const handlerPrefix = `/${eventPrefix}`;
    const instance = this.parent || this;
    const patchedHandler = this.useNode ? nodeAdapter(handler) : handler;
    instance.loaders.push(new Handler(handlerPrefix, patchedHandler));
    instance.addListener();
  }
  addListener() {
    if (this.listenerAdded) {
      return;
    }
    addEventListener("fetch", (event, eventContext) => {
      event.respondWith(this.handleEvent(event, eventContext));
    });
    this.listenerAdded = true;
  }
  // keep the original handler for compatibility with prev. versions
  useNodeHandler(prefixOrHandler, _handler) {
    if (!this.useNode && this.node) {
      this.node?.use(prefixOrHandler, _handler);
    } else {
      this.use(prefixOrHandler, _handler);
    }
  }
  async handleEvent(event, context) {
    const requestContext = {
      event,
      context,
      setTimeout: (timeout) => event.setTimeout?.(timeout)
    };
    return await requestContextStorage.run(requestContext, async () => {
      const notFoundResponses = [];
      const url = new URL(event.request.url);
      event.setTimeout?.(this.defaultTimeout || DEFAULT_HANDLER_TIMEOUT_MS);
      try {
        for (const loader of this.loaders) {
          if (!url.pathname.startsWith(loader.prefix)) {
            continue;
          }
          const result = loader.handler(event.request, context);
          if (!result) {
            continue;
          }
          const response = await result;
          if (!response) {
            continue;
          }
          if (response.status !== 404) {
            return response;
          }
          notFoundResponses.push(response);
        }
        return notFoundResponses.shift() || await this.defaultNotFoundResponse();
      } catch (err) {
        console.error(
          JSON.stringify({
            msg: "HTTP handler failed",
            err: { name: err.name, message: err.message, stack: err.stack, code: err.code }
          })
        );
        return await this.defaultErrorResponse();
      }
    });
  }
  on(eventName, relativePath) {
    if (this.useNode) {
      throw new Error("http.on() is not supported in node mode");
    }
    if (eventName.toString() === "404") {
      if (relativePath.startsWith("static/") && process.env.AMPT_ASSETS_LOCATION) {
        this.defaultNotFoundResponse = () => getS3AssetResponse(relativePath.slice(7), 404);
      } else {
        this.defaultNotFoundResponse = () => (
          // @ts-ignore
          new Response(createReadableStream(relativePath), {
            status: 404,
            headers: {
              "Content-Type": "text/html",
              "Cache-Control": `max-age=0, s-maxage=31449600, must-revalidate`
            }
          })
        );
      }
    } else if (eventName.toString() === "500") {
      if (relativePath.startsWith("static/") && process.env.AMPT_ASSETS_LOCATION) {
        this.defaultErrorResponse = () => getS3AssetResponse(relativePath.slice(7), 500);
      } else {
        this.defaultErrorResponse = () => (
          // @ts-ignore
          new Response(createReadableStream(relativePath), {
            status: 500,
            headers: {
              "Content-Type": "text/html",
              "Cache-Control": `max-age=0, s-maxage=31449600, must-revalidate`
            }
          })
        );
      }
    } else {
      throw new Error(`Unsupported event name for http.on(): ${eventName}`);
    }
    this.addListener();
  }
  async readStaticFile(relativePath) {
    let result;
    if (process.env.AMPT_ASSETS_LOCATION) {
      result = (await getStaticAssetObject(relativePath))?.body;
    } else {
      result = createReadableStream(path.join("static", relativePath));
    }
    if (this.useNode) {
      if (result && result instanceof ReadableStream) {
        const nodeStream = stream.Readable.fromWeb(result);
        return nodeStream;
      } else {
        return result;
      }
    } else {
      return result;
    }
  }
};
var http4 = new Http();

export {
  normalize,
  Http,
  http4 as http
};
