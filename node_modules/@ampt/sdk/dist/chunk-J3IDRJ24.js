import { createRequire as topLevelCreateRequire } from 'module'
const require = topLevelCreateRequire(import.meta.url || __dirname)
import {
  getClient
} from "./chunk-SN7XVJE5.js";
import {
  filterDisallowedExportParams,
  parseParamGroups,
  parseParams,
  setExports
} from "./chunk-MFAT3D7D.js";

// ../../lib/aws/ssm.ts
async function getParameter(name) {
  const client = await getClient();
  const paramsUrl = `https://ssm.${process.env.AWS_REGION}.amazonaws.com/`;
  const response = await client.fetch(paramsUrl, {
    body: JSON.stringify({
      Name: name,
      WithDecryption: true
      // support SecureString params too, otherwise this just gets ignored
    }),
    headers: {
      "Content-Type": "application/x-amz-json-1.1",
      "X-Amz-Target": "AmazonSSM.GetParameter"
    }
  });
  if (response.status === 200) {
    const { Parameter } = await response.json();
    return Parameter.Value;
  } else {
    throw new Error(`Unable to load SSM parameter "${name}": ${response.status}`);
  }
}

// ../../lib/params-core/store.ts
function getParamStore() {
  return globalThis.ParamsStore?.getStore();
}

// ../../lib/params-core/index.ts
var ParamsEngine = class {
  async load() {
    const store = getParamStore();
    if (!store) {
      const params2 = process.env.PARAMS_NAME ? await getParameter(process.env.PARAMS_NAME) : "{}";
      process.env.PARAMS = params2;
    }
    if (store && (!store.params || !store.paramGroups)) {
      try {
        const [params2, groups] = await Promise.all([
          process.env.PARAMS_NAME ? getParameter(process.env.PARAMS_NAME) : "{}",
          process.env.PARAM_GROUPS_NAME ? getParameter(process.env.PARAM_GROUPS_NAME) : "{}"
        ]);
        store.params = JSON.parse(params2);
        process.env.PARAMS = params2;
        if (groups) {
          const parsed = JSON.parse(groups);
          store.paramGroups = parsed.params;
          store.envExports = parsed.envExports;
        }
      } catch (err) {
        throw new Error("Failed to load params", { cause: err });
      }
    }
  }
  setExports() {
    const store = getParamStore();
    if (store && store.envExports) {
      setExports(store.paramGroups, store.envExports);
    }
    if (store && store.params) {
      process.env = {
        ...filterDisallowedExportParams(store.params),
        ...process.env
      };
    }
  }
};
var params_core_default = new ParamsEngine();

// params/index.ts
var existingEnv = {
  ORG_NAME: process.env.AMPT_ORG_NAME,
  SERVICE_NAME: process.env.AMPT_SERVICE_NAME,
  APP_NAME: process.env.AMPT_SERVICE_NAME,
  INSTANCE_NAME: process.env.AMPT_INSTANCE_NAME,
  ENVIRONMENT_NAME: process.env.AMPT_INSTANCE_NAME,
  ENV_NAME: process.env.AMPT_INSTANCE_NAME,
  INSTANCE_TYPE: process.env.AMPT_INSTANCE_TYPE,
  ENVIRONMENT_TYPE: process.env.AMPT_INSTANCE_TYPE,
  ENV_TYPE: process.env.AMPT_INSTANCE_TYPE,
  AMPT_STAGE: process.env.AMPT_STAGE,
  AMPT_URL: process.env.AMPT_URL,
  AMPT_REGION: process.env.AWS_REGION,
  CUSTOM_DOMAINS: process.env.AMPT_CUSTOM_DOMAINS ?? ""
};
var Params = class _Params {
  params = {};
  groups = {};
  static list(params2) {
    return params2;
  }
  constructor(params2) {
    const paramsStore = getParamStore();
    if (params2) {
      this.params = params2;
    } else if (paramsStore) {
      this.params = {
        ...paramsStore.params,
        ...existingEnv
      };
      this.groups = paramsStore.paramGroups || {};
    } else {
      this.params = {
        ...parseParams(),
        ...existingEnv
      };
      this.groups = parseParamGroups();
    }
  }
  export(_keys = []) {
    const keys = Array.isArray(_keys) ? _keys : [_keys];
    const allowedParams = filterDisallowedExportParams(this.params);
    if (!keys.length) {
      process.env = {
        ...allowedParams,
        ...process.env
      };
    } else {
      keys.forEach((key) => {
        if (!process.env[key] && allowedParams[key]) {
          process.env[key] = allowedParams[key];
        }
      });
    }
  }
  group(namespace) {
    if (this.groups[namespace]) {
      const groupParams = this.groups[namespace];
      const getter = (key) => groupParams[key];
      for (const [key, value] of Object.entries(groupParams)) {
        getter[key] = value;
      }
      return getter;
    }
  }
  list() {
    return _Params.list(this.params);
  }
  handler(key) {
    if (key) {
      return this.params[key] || void 0;
    }
    return {
      export: this.export.bind(this),
      list: this.list.bind(this),
      group: this.group.bind(this)
    };
  }
};
var _params = new Params();
var params = _params.handler.bind(_params);

export {
  Params,
  params
};
