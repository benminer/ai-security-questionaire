import { createRequire as topLevelCreateRequire } from 'module'
const require = topLevelCreateRequire(import.meta.url || __dirname)
import {
  AssumeRoleCommand,
  Client,
  Command,
  CredentialsProviderError,
  DEFAULT_RETRY_MODE,
  Hash,
  HttpRequest,
  NODE_MAX_ATTEMPT_CONFIG_OPTIONS,
  NODE_REGION_CONFIG_FILE_OPTIONS,
  NODE_REGION_CONFIG_OPTIONS,
  NODE_RETRY_MODE_CONFIG_OPTIONS,
  NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS,
  NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS,
  NoOpLogger,
  NodeHttpHandler,
  SSOClient,
  STSClient,
  ServiceException,
  calculateBodyLength,
  decorateDefaultCredentialProvider,
  decorateServiceException,
  defaultProvider,
  defaultUserAgent,
  emitWarningIfUnsupportedVersion,
  expectNonNull,
  expectNumber,
  expectString,
  fromBase64,
  fromContainerMetadata,
  fromEnv,
  fromIni,
  fromInstanceMetadata,
  fromProcess,
  fromSSO,
  fromTokenFile,
  fromUtf8,
  fromWebToken,
  getContentLengthPlugin,
  getDefaultRoleAssumer,
  getDefaultRoleAssumerWithWebIdentity,
  getEndpointPlugin,
  getHostHeaderPlugin,
  getLoggerPlugin,
  getRecursionDetectionPlugin,
  getRetryPlugin,
  getSerdePlugin,
  getUserAgentPlugin,
  loadConfig,
  loadConfigsForDefaultMode,
  parseEpochTimestamp,
  parseUrl,
  resolveAwsAuthConfig,
  resolveDefaultsModeConfig,
  resolveEndpoint,
  resolveEndpointConfig,
  resolveHostHeaderConfig,
  resolveRegionConfig,
  resolveRetryConfig,
  resolveUserAgentConfig,
  streamCollector,
  throwDefaultError,
  toBase64,
  toUtf8
} from "./chunk-2E5TW4HQ.js";
import "./chunk-6XEJQOQ7.js";
import "./chunk-DVAUNSLU.js";
import "./chunk-HWSCZVIB.js";

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "cognito-identity"
  };
};

// ../../node_modules/@aws-sdk/client-cognito-identity/package.json
var package_default = {
  name: "@aws-sdk/client-cognito-identity",
  description: "AWS SDK for JavaScript Cognito Identity Client for Node.js, Browser and React Native",
  version: "3.272.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo cognito-identity",
    "test:e2e": "ts-mocha test/**/*.ispec.ts && karma start karma.conf.js"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.272.0",
    "@aws-sdk/config-resolver": "3.272.0",
    "@aws-sdk/credential-provider-node": "3.272.0",
    "@aws-sdk/fetch-http-handler": "3.272.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.272.0",
    "@aws-sdk/middleware-endpoint": "3.272.0",
    "@aws-sdk/middleware-host-header": "3.272.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.272.0",
    "@aws-sdk/middleware-retry": "3.272.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-signing": "3.272.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.272.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.272.0",
    "@aws-sdk/protocol-http": "3.272.0",
    "@aws-sdk/smithy-client": "3.272.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.272.0",
    "@aws-sdk/util-defaults-mode-node": "3.272.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.272.0",
    "@aws-sdk/util-user-agent-node": "3.272.0",
    "@aws-sdk/util-utf8": "3.254.0",
    tslib: "^2.3.1"
  },
  devDependencies: {
    "@aws-sdk/client-iam": "3.272.0",
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/chai": "^4.2.11",
    "@types/mocha": "^8.0.4",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cognito-identity",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-cognito-identity"
  }
};

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/endpoint/ruleset.js
var p = "required";
var q = "fn";
var r = "argv";
var s = "ref";
var a = "PartitionResult";
var b = "tree";
var c = "error";
var d = "endpoint";
var e = { [p]: false, "type": "String" };
var f = { [p]: true, "default": false, "type": "Boolean" };
var g = { [s]: "Endpoint" };
var h = { [q]: "booleanEquals", [r]: [{ [s]: "UseFIPS" }, true] };
var i = { [q]: "booleanEquals", [r]: [{ [s]: "UseDualStack" }, true] };
var j = {};
var k = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsFIPS"] }] };
var l = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsDualStack"] }] };
var m = [g];
var n = [h];
var o = [i];
var _data = { version: "1.0", parameters: { Region: e, UseDualStack: f, UseFIPS: f, Endpoint: e }, rules: [{ conditions: [{ [q]: "aws.partition", [r]: [{ [s]: "Region" }], assign: a }], type: b, rules: [{ conditions: [{ [q]: "isSet", [r]: m }, { [q]: "parseURL", [r]: m, assign: "url" }], type: b, rules: [{ conditions: n, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: o, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: g, properties: j, headers: j }, type: d }] }] }, { conditions: [h, i], type: b, rules: [{ conditions: [k, l], type: b, rules: [{ endpoint: { url: "https://cognito-identity-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: n, type: b, rules: [{ conditions: [k], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://cognito-identity-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: o, type: b, rules: [{ conditions: [l], type: b, rules: [{ endpoint: { url: "https://cognito-identity.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { endpoint: { url: "https://cognito-identity.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] };
var ruleSet = _data;

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/runtimeConfig.shared.js
var getRuntimeConfig = (config) => ({
  apiVersion: "2014-06-30",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "Cognito Identity",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf8,
  utf8Encoder: config?.utf8Encoder ?? toUtf8
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/runtimeConfig.js
var getRuntimeConfig2 = (config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider(defaultProvider),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
};

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/CognitoIdentityClient.js
var CognitoIdentityClient = class extends Client {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig2(configuration);
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveAwsAuthConfig(_config_5);
    const _config_7 = resolveUserAgentConfig(_config_6);
    super(_config_7);
    this.config = _config_7;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/models/CognitoIdentityServiceException.js
var CognitoIdentityServiceException = class _CognitoIdentityServiceException extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _CognitoIdentityServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/models/models_0.js
var AmbiguousRoleResolutionType;
(function(AmbiguousRoleResolutionType2) {
  AmbiguousRoleResolutionType2["AUTHENTICATED_ROLE"] = "AuthenticatedRole";
  AmbiguousRoleResolutionType2["DENY"] = "Deny";
})(AmbiguousRoleResolutionType || (AmbiguousRoleResolutionType = {}));
var InternalErrorException = class _InternalErrorException extends CognitoIdentityServiceException {
  constructor(opts) {
    super({
      name: "InternalErrorException",
      $fault: "server",
      ...opts
    });
    this.name = "InternalErrorException";
    this.$fault = "server";
    Object.setPrototypeOf(this, _InternalErrorException.prototype);
  }
};
var InvalidParameterException = class _InvalidParameterException extends CognitoIdentityServiceException {
  constructor(opts) {
    super({
      name: "InvalidParameterException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidParameterException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidParameterException.prototype);
  }
};
var LimitExceededException = class _LimitExceededException extends CognitoIdentityServiceException {
  constructor(opts) {
    super({
      name: "LimitExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "LimitExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _LimitExceededException.prototype);
  }
};
var NotAuthorizedException = class _NotAuthorizedException extends CognitoIdentityServiceException {
  constructor(opts) {
    super({
      name: "NotAuthorizedException",
      $fault: "client",
      ...opts
    });
    this.name = "NotAuthorizedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _NotAuthorizedException.prototype);
  }
};
var ResourceConflictException = class _ResourceConflictException extends CognitoIdentityServiceException {
  constructor(opts) {
    super({
      name: "ResourceConflictException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceConflictException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ResourceConflictException.prototype);
  }
};
var TooManyRequestsException = class _TooManyRequestsException extends CognitoIdentityServiceException {
  constructor(opts) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyRequestsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _TooManyRequestsException.prototype);
  }
};
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["ACCESS_DENIED"] = "AccessDenied";
  ErrorCode2["INTERNAL_SERVER_ERROR"] = "InternalServerError";
})(ErrorCode || (ErrorCode = {}));
var ResourceNotFoundException = class _ResourceNotFoundException extends CognitoIdentityServiceException {
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
  }
};
var ExternalServiceException = class _ExternalServiceException extends CognitoIdentityServiceException {
  constructor(opts) {
    super({
      name: "ExternalServiceException",
      $fault: "client",
      ...opts
    });
    this.name = "ExternalServiceException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ExternalServiceException.prototype);
  }
};
var InvalidIdentityPoolConfigurationException = class _InvalidIdentityPoolConfigurationException extends CognitoIdentityServiceException {
  constructor(opts) {
    super({
      name: "InvalidIdentityPoolConfigurationException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidIdentityPoolConfigurationException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidIdentityPoolConfigurationException.prototype);
  }
};
var MappingRuleMatchType;
(function(MappingRuleMatchType2) {
  MappingRuleMatchType2["CONTAINS"] = "Contains";
  MappingRuleMatchType2["EQUALS"] = "Equals";
  MappingRuleMatchType2["NOT_EQUAL"] = "NotEqual";
  MappingRuleMatchType2["STARTS_WITH"] = "StartsWith";
})(MappingRuleMatchType || (MappingRuleMatchType = {}));
var RoleMappingType;
(function(RoleMappingType2) {
  RoleMappingType2["RULES"] = "Rules";
  RoleMappingType2["TOKEN"] = "Token";
})(RoleMappingType || (RoleMappingType = {}));
var GetCredentialsForIdentityInputFilterSensitiveLog = (obj) => ({
  ...obj
});
var GetCredentialsForIdentityResponseFilterSensitiveLog = (obj) => ({
  ...obj
});
var GetIdInputFilterSensitiveLog = (obj) => ({
  ...obj
});
var GetIdResponseFilterSensitiveLog = (obj) => ({
  ...obj
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/protocols/Aws_json1_1.js
var serializeAws_json1_1GetCredentialsForIdentityCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSCognitoIdentityService.GetCredentialsForIdentity"
  };
  let body;
  body = JSON.stringify(serializeAws_json1_1GetCredentialsForIdentityInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var serializeAws_json1_1GetIdCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSCognitoIdentityService.GetId"
  };
  let body;
  body = JSON.stringify(serializeAws_json1_1GetIdInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var deserializeAws_json1_1GetCredentialsForIdentityCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1GetCredentialsForIdentityCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = deserializeAws_json1_1GetCredentialsForIdentityResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_json1_1GetCredentialsForIdentityCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ExternalServiceException":
    case "com.amazonaws.cognitoidentity#ExternalServiceException":
      throw await deserializeAws_json1_1ExternalServiceExceptionResponse(parsedOutput, context);
    case "InternalErrorException":
    case "com.amazonaws.cognitoidentity#InternalErrorException":
      throw await deserializeAws_json1_1InternalErrorExceptionResponse(parsedOutput, context);
    case "InvalidIdentityPoolConfigurationException":
    case "com.amazonaws.cognitoidentity#InvalidIdentityPoolConfigurationException":
      throw await deserializeAws_json1_1InvalidIdentityPoolConfigurationExceptionResponse(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.cognitoidentity#InvalidParameterException":
      throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
    case "NotAuthorizedException":
    case "com.amazonaws.cognitoidentity#NotAuthorizedException":
      throw await deserializeAws_json1_1NotAuthorizedExceptionResponse(parsedOutput, context);
    case "ResourceConflictException":
    case "com.amazonaws.cognitoidentity#ResourceConflictException":
      throw await deserializeAws_json1_1ResourceConflictExceptionResponse(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.cognitoidentity#ResourceNotFoundException":
      throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.cognitoidentity#TooManyRequestsException":
      throw await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: CognitoIdentityServiceException,
        errorCode
      });
  }
};
var deserializeAws_json1_1GetIdCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1GetIdCommandError(output, context);
  }
  const data = await parseBody(output.body, context);
  let contents = {};
  contents = deserializeAws_json1_1GetIdResponse(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_json1_1GetIdCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ExternalServiceException":
    case "com.amazonaws.cognitoidentity#ExternalServiceException":
      throw await deserializeAws_json1_1ExternalServiceExceptionResponse(parsedOutput, context);
    case "InternalErrorException":
    case "com.amazonaws.cognitoidentity#InternalErrorException":
      throw await deserializeAws_json1_1InternalErrorExceptionResponse(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.cognitoidentity#InvalidParameterException":
      throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.cognitoidentity#LimitExceededException":
      throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
    case "NotAuthorizedException":
    case "com.amazonaws.cognitoidentity#NotAuthorizedException":
      throw await deserializeAws_json1_1NotAuthorizedExceptionResponse(parsedOutput, context);
    case "ResourceConflictException":
    case "com.amazonaws.cognitoidentity#ResourceConflictException":
      throw await deserializeAws_json1_1ResourceConflictExceptionResponse(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.cognitoidentity#ResourceNotFoundException":
      throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.cognitoidentity#TooManyRequestsException":
      throw await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: CognitoIdentityServiceException,
        errorCode
      });
  }
};
var deserializeAws_json1_1ExternalServiceExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_1ExternalServiceException(body, context);
  const exception = new ExternalServiceException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_json1_1InternalErrorExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_1InternalErrorException(body, context);
  const exception = new InternalErrorException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_json1_1InvalidIdentityPoolConfigurationExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_1InvalidIdentityPoolConfigurationException(body, context);
  const exception = new InvalidIdentityPoolConfigurationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_json1_1InvalidParameterExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_1InvalidParameterException(body, context);
  const exception = new InvalidParameterException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_json1_1LimitExceededExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_1LimitExceededException(body, context);
  const exception = new LimitExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_json1_1NotAuthorizedExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_1NotAuthorizedException(body, context);
  const exception = new NotAuthorizedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_json1_1ResourceConflictExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_1ResourceConflictException(body, context);
  const exception = new ResourceConflictException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_json1_1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_1ResourceNotFoundException(body, context);
  const exception = new ResourceNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_json1_1TooManyRequestsExceptionResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_json1_1TooManyRequestsException(body, context);
  const exception = new TooManyRequestsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var serializeAws_json1_1GetCredentialsForIdentityInput = (input, context) => {
  return {
    ...input.CustomRoleArn != null && { CustomRoleArn: input.CustomRoleArn },
    ...input.IdentityId != null && { IdentityId: input.IdentityId },
    ...input.Logins != null && { Logins: serializeAws_json1_1LoginsMap(input.Logins, context) }
  };
};
var serializeAws_json1_1GetIdInput = (input, context) => {
  return {
    ...input.AccountId != null && { AccountId: input.AccountId },
    ...input.IdentityPoolId != null && { IdentityPoolId: input.IdentityPoolId },
    ...input.Logins != null && { Logins: serializeAws_json1_1LoginsMap(input.Logins, context) }
  };
};
var serializeAws_json1_1LoginsMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};
var deserializeAws_json1_1Credentials = (output, context) => {
  return {
    AccessKeyId: expectString(output.AccessKeyId),
    Expiration: output.Expiration != null ? expectNonNull(parseEpochTimestamp(expectNumber(output.Expiration))) : void 0,
    SecretKey: expectString(output.SecretKey),
    SessionToken: expectString(output.SessionToken)
  };
};
var deserializeAws_json1_1ExternalServiceException = (output, context) => {
  return {
    message: expectString(output.message)
  };
};
var deserializeAws_json1_1GetCredentialsForIdentityResponse = (output, context) => {
  return {
    Credentials: output.Credentials != null ? deserializeAws_json1_1Credentials(output.Credentials, context) : void 0,
    IdentityId: expectString(output.IdentityId)
  };
};
var deserializeAws_json1_1GetIdResponse = (output, context) => {
  return {
    IdentityId: expectString(output.IdentityId)
  };
};
var deserializeAws_json1_1InternalErrorException = (output, context) => {
  return {
    message: expectString(output.message)
  };
};
var deserializeAws_json1_1InvalidIdentityPoolConfigurationException = (output, context) => {
  return {
    message: expectString(output.message)
  };
};
var deserializeAws_json1_1InvalidParameterException = (output, context) => {
  return {
    message: expectString(output.message)
  };
};
var deserializeAws_json1_1LimitExceededException = (output, context) => {
  return {
    message: expectString(output.message)
  };
};
var deserializeAws_json1_1NotAuthorizedException = (output, context) => {
  return {
    message: expectString(output.message)
  };
};
var deserializeAws_json1_1ResourceConflictException = (output, context) => {
  return {
    message: expectString(output.message)
  };
};
var deserializeAws_json1_1ResourceNotFoundException = (output, context) => {
  return {
    message: expectString(output.message)
  };
};
var deserializeAws_json1_1TooManyRequestsException = (output, context) => {
  return {
    message: expectString(output.message)
  };
};
var deserializeMetadata = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
var buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
};
var parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
var parseErrorBody = async (errorBody, context) => {
  const value = await parseBody(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};
var loadRestJsonErrorCode = (output, data) => {
  const findKey = (object, key) => Object.keys(object).find((k2) => k2.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetCredentialsForIdentityCommand.js
var GetCredentialsForIdentityCommand = class _GetCredentialsForIdentityCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _GetCredentialsForIdentityCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "CognitoIdentityClient";
    const commandName = "GetCredentialsForIdentityCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetCredentialsForIdentityInputFilterSensitiveLog,
      outputFilterSensitiveLog: GetCredentialsForIdentityResponseFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_json1_1GetCredentialsForIdentityCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_json1_1GetCredentialsForIdentityCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetIdCommand.js
var GetIdCommand = class _GetIdCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _GetIdCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const clientName = "CognitoIdentityClient";
    const commandName = "GetIdCommand";
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetIdInputFilterSensitiveLog,
      outputFilterSensitiveLog: GetIdResponseFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_json1_1GetIdCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_json1_1GetIdCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/resolveLogins.js
function resolveLogins(logins) {
  return Promise.all(Object.keys(logins).reduce((arr, name) => {
    const tokenOrProvider = logins[name];
    if (typeof tokenOrProvider === "string") {
      arr.push([name, tokenOrProvider]);
    } else {
      arr.push(tokenOrProvider().then((token) => [name, token]));
    }
    return arr;
  }, [])).then((resolvedPairs) => resolvedPairs.reduce((logins2, [key, value]) => {
    logins2[key] = value;
    return logins2;
  }, {}));
}

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/fromCognitoIdentity.js
function fromCognitoIdentity(parameters) {
  return async () => {
    const { Credentials: { AccessKeyId = throwOnMissingAccessKeyId(), Expiration, SecretKey = throwOnMissingSecretKey(), SessionToken } = throwOnMissingCredentials() } = await parameters.client.send(new GetCredentialsForIdentityCommand({
      CustomRoleArn: parameters.customRoleArn,
      IdentityId: parameters.identityId,
      Logins: parameters.logins ? await resolveLogins(parameters.logins) : void 0
    }));
    return {
      identityId: parameters.identityId,
      accessKeyId: AccessKeyId,
      secretAccessKey: SecretKey,
      sessionToken: SessionToken,
      expiration: Expiration
    };
  };
}
function throwOnMissingAccessKeyId() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no access key ID");
}
function throwOnMissingCredentials() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no credentials");
}
function throwOnMissingSecretKey() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no secret key");
}

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/IndexedDbStorage.js
var STORE_NAME = "IdentityIds";
var IndexedDbStorage = class {
  constructor(dbName = "aws:cognito-identity-ids") {
    this.dbName = dbName;
  }
  getItem(key) {
    return this.withObjectStore("readonly", (store) => {
      const req = store.get(key);
      return new Promise((resolve) => {
        req.onerror = () => resolve(null);
        req.onsuccess = () => resolve(req.result ? req.result.value : null);
      });
    }).catch(() => null);
  }
  removeItem(key) {
    return this.withObjectStore("readwrite", (store) => {
      const req = store.delete(key);
      return new Promise((resolve, reject) => {
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve();
      });
    });
  }
  setItem(id, value) {
    return this.withObjectStore("readwrite", (store) => {
      const req = store.put({ id, value });
      return new Promise((resolve, reject) => {
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve();
      });
    });
  }
  getDb() {
    const openDbRequest = self.indexedDB.open(this.dbName, 1);
    return new Promise((resolve, reject) => {
      openDbRequest.onsuccess = () => {
        resolve(openDbRequest.result);
      };
      openDbRequest.onerror = () => {
        reject(openDbRequest.error);
      };
      openDbRequest.onblocked = () => {
        reject(new Error("Unable to access DB"));
      };
      openDbRequest.onupgradeneeded = () => {
        const db = openDbRequest.result;
        db.onerror = () => {
          reject(new Error("Failed to create object store"));
        };
        db.createObjectStore(STORE_NAME, { keyPath: "id" });
      };
    });
  }
  withObjectStore(mode, action) {
    return this.getDb().then((db) => {
      const tx = db.transaction(STORE_NAME, mode);
      tx.oncomplete = () => db.close();
      return new Promise((resolve, reject) => {
        tx.onerror = () => reject(tx.error);
        resolve(action(tx.objectStore(STORE_NAME)));
      }).catch((err) => {
        db.close();
        throw err;
      });
    });
  }
};

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/InMemoryStorage.js
var InMemoryStorage = class {
  constructor(store = {}) {
    this.store = store;
  }
  getItem(key) {
    if (key in this.store) {
      return this.store[key];
    }
    return null;
  }
  removeItem(key) {
    delete this.store[key];
  }
  setItem(key, value) {
    this.store[key] = value;
  }
};

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/localStorage.js
var inMemoryStorage = new InMemoryStorage();
function localStorage() {
  if (typeof self === "object" && self.indexedDB) {
    return new IndexedDbStorage();
  }
  if (typeof window === "object" && window.localStorage) {
    return window.localStorage;
  }
  return inMemoryStorage;
}

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/fromCognitoIdentityPool.js
function fromCognitoIdentityPool({ accountId, cache = localStorage(), client, customRoleArn, identityPoolId, logins, userIdentifier = !logins || Object.keys(logins).length === 0 ? "ANONYMOUS" : void 0 }) {
  const cacheKey = userIdentifier ? `aws:cognito-identity-credentials:${identityPoolId}:${userIdentifier}` : void 0;
  let provider = async () => {
    let identityId = cacheKey && await cache.getItem(cacheKey);
    if (!identityId) {
      const { IdentityId = throwOnMissingId() } = await client.send(new GetIdCommand({
        AccountId: accountId,
        IdentityPoolId: identityPoolId,
        Logins: logins ? await resolveLogins(logins) : void 0
      }));
      identityId = IdentityId;
      if (cacheKey) {
        Promise.resolve(cache.setItem(cacheKey, identityId)).catch(() => {
        });
      }
    }
    provider = fromCognitoIdentity({
      client,
      customRoleArn,
      logins,
      identityId
    });
    return provider();
  };
  return () => provider().catch(async (err) => {
    if (cacheKey) {
      Promise.resolve(cache.removeItem(cacheKey)).catch(() => {
      });
    }
    throw err;
  });
}
function throwOnMissingId() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no identity ID");
}

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromCognitoIdentity.js
var fromCognitoIdentity2 = (options) => fromCognitoIdentity({
  ...options,
  client: new CognitoIdentityClient(options.clientConfig ?? {})
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromCognitoIdentityPool.js
var fromCognitoIdentityPool2 = (options) => fromCognitoIdentityPool({
  ...options,
  client: new CognitoIdentityClient(options.clientConfig ?? {})
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromContainerMetadata.js
var fromContainerMetadata2 = (init) => fromContainerMetadata(init);

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromEnv.js
var fromEnv2 = () => fromEnv();

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromIni.js
var fromIni2 = (init = {}) => fromIni({
  ...init,
  roleAssumer: init.roleAssumer ?? getDefaultRoleAssumer(init.clientConfig, init.clientPlugins),
  roleAssumerWithWebIdentity: init.roleAssumerWithWebIdentity ?? getDefaultRoleAssumerWithWebIdentity(init.clientConfig, init.clientPlugins)
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromInstanceMetadata.js
var fromInstanceMetadata2 = (init) => fromInstanceMetadata(init);

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromNodeProviderChain.js
var fromNodeProviderChain = (init = {}) => defaultProvider({
  ...init,
  roleAssumer: init.roleAssumer ?? getDefaultRoleAssumer(init.clientConfig, init.clientPlugins),
  roleAssumerWithWebIdentity: init.roleAssumerWithWebIdentity ?? getDefaultRoleAssumerWithWebIdentity(init.clientConfig, init.clientPlugins)
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromProcess.js
var fromProcess2 = (init) => fromProcess(init);

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromSSO.js
var fromSSO2 = (init = {}) => fromSSO({ ...{ ssoClient: init.clientConfig ? new SSOClient(init.clientConfig) : void 0 }, ...init });

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromTemporaryCredentials.js
var fromTemporaryCredentials = (options) => {
  let stsClient;
  return async () => {
    const params = { ...options.params, RoleSessionName: options.params.RoleSessionName ?? "aws-sdk-js-" + Date.now() };
    if (params?.SerialNumber) {
      if (!options.mfaCodeProvider) {
        throw new CredentialsProviderError(`Temporary credential requires multi-factor authentication, but no MFA code callback was provided.`, false);
      }
      params.TokenCode = await options.mfaCodeProvider(params?.SerialNumber);
    }
    if (!stsClient)
      stsClient = new STSClient({ ...options.clientConfig, credentials: options.masterCredentials });
    if (options.clientPlugins) {
      for (const plugin of options.clientPlugins) {
        stsClient.middlewareStack.use(plugin);
      }
    }
    const { Credentials } = await stsClient.send(new AssumeRoleCommand(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new CredentialsProviderError(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
};

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromTokenFile.js
var fromTokenFile2 = (init = {}) => fromTokenFile({
  ...init,
  roleAssumerWithWebIdentity: init.roleAssumerWithWebIdentity ?? getDefaultRoleAssumerWithWebIdentity(init.clientConfig, init.clientPlugins)
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromWebToken.js
var fromWebToken2 = (init) => fromWebToken({
  ...init,
  roleAssumerWithWebIdentity: init.roleAssumerWithWebIdentity ?? getDefaultRoleAssumerWithWebIdentity(init.clientConfig, init.clientPlugins)
});
export {
  fromCognitoIdentity2 as fromCognitoIdentity,
  fromCognitoIdentityPool2 as fromCognitoIdentityPool,
  fromContainerMetadata2 as fromContainerMetadata,
  fromEnv2 as fromEnv,
  fromIni2 as fromIni,
  fromInstanceMetadata2 as fromInstanceMetadata,
  fromNodeProviderChain,
  fromProcess2 as fromProcess,
  fromSSO2 as fromSSO,
  fromTemporaryCredentials,
  fromTokenFile2 as fromTokenFile,
  fromWebToken2 as fromWebToken
};
