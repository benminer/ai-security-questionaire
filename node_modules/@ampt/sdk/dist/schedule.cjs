"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/cron-validate/lib/result.js
var require_result = __commonJS({
  "../../node_modules/cron-validate/lib/result.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Err = exports.Valid = exports.err = exports.valid = void 0;
    var valid = (value) => new Valid(value);
    exports.valid = valid;
    var err = (error) => new Err(error);
    exports.err = err;
    var Valid = class {
      constructor(value) {
        this.value = value;
      }
      isValid() {
        return true;
      }
      isError() {
        return !this.isValid();
      }
      getValue() {
        return this.value;
      }
      getError() {
        throw new Error("Tried to get error from a valid.");
      }
      map(func) {
        return (0, exports.valid)(func(this.value));
      }
      mapErr(func) {
        return (0, exports.valid)(this.value);
      }
    };
    exports.Valid = Valid;
    var Err = class {
      constructor(error) {
        this.error = error;
      }
      isError() {
        return true;
      }
      isValid() {
        return !this.isError();
      }
      getValue() {
        throw new Error("Tried to get success value from an error.");
      }
      getError() {
        return this.error;
      }
      map(func) {
        return (0, exports.err)(this.error);
      }
      mapErr(func) {
        return (0, exports.err)(func(this.error));
      }
    };
    exports.Err = Err;
  }
});

// ../../node_modules/cron-validate/lib/types.js
var require_types = __commonJS({
  "../../node_modules/cron-validate/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/cron-validate/lib/helper.js
var require_helper = __commonJS({
  "../../node_modules/cron-validate/lib/helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    require_types();
    var monthAliases = [
      "jan",
      "feb",
      "mar",
      "apr",
      "may",
      "jun",
      "jul",
      "aug",
      "sep",
      "oct",
      "nov",
      "dec"
    ];
    var daysOfWeekAliases = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
    var checkWildcardLimit = (cronFieldType, options) => options[cronFieldType].lowerLimit === options.preset[cronFieldType].minValue && options[cronFieldType].upperLimit === options.preset[cronFieldType].maxValue;
    var checkSingleElementWithinLimits = (element, cronFieldType, options) => {
      if (cronFieldType === "months" && options.useAliases && monthAliases.indexOf(element.toLowerCase()) !== -1) {
        return (0, result_1.valid)(true);
      }
      if (cronFieldType === "daysOfWeek" && options.useAliases && daysOfWeekAliases.indexOf(element.toLowerCase()) !== -1) {
        return (0, result_1.valid)(true);
      }
      const number2 = Number(element);
      if (isNaN(number2)) {
        return (0, result_1.err)(`Element '${element} of ${cronFieldType} field is invalid.`);
      }
      const { lowerLimit } = options[cronFieldType];
      const { upperLimit } = options[cronFieldType];
      if (lowerLimit && number2 < lowerLimit) {
        return (0, result_1.err)(`Number ${number2} of ${cronFieldType} field is smaller than lower limit '${lowerLimit}'`);
      }
      if (upperLimit && number2 > upperLimit) {
        return (0, result_1.err)(`Number ${number2} of ${cronFieldType} field is bigger than upper limit '${upperLimit}'`);
      }
      return (0, result_1.valid)(true);
    };
    var checkSingleElement = (element, cronFieldType, options) => {
      if (element === "*") {
        if (!checkWildcardLimit(cronFieldType, options)) {
          return (0, result_1.err)(`Field ${cronFieldType} uses wildcard '*', but is limited to ${options[cronFieldType].lowerLimit}-${options[cronFieldType].upperLimit}`);
        }
        return (0, result_1.valid)(true);
      }
      if (element === "") {
        return (0, result_1.err)(`One of the elements is empty in ${cronFieldType} field.`);
      }
      if (cronFieldType === "daysOfMonth" && options.useLastDayOfMonth && element === "L") {
        return (0, result_1.valid)(true);
      }
      if (cronFieldType === "daysOfWeek" && options.useLastDayOfWeek && element.endsWith("L")) {
        const day = element.slice(0, -1);
        if (day === "") {
          return (0, result_1.valid)(true);
        }
        return checkSingleElementWithinLimits(day, cronFieldType, options);
      }
      if (cronFieldType === "daysOfMonth" && options.useNearestWeekday && element.endsWith("W")) {
        const day = element.slice(0, -1);
        if (day === "") {
          return (0, result_1.err)(`The 'W' must be preceded by a day`);
        }
        if (options.useLastDayOfMonth && day === "L") {
          return (0, result_1.valid)(true);
        }
        return checkSingleElementWithinLimits(day, cronFieldType, options);
      }
      if (cronFieldType === "daysOfWeek" && options.useNthWeekdayOfMonth && element.indexOf("#") !== -1) {
        const [day, occurrence, ...leftOvers] = element.split("#");
        if (leftOvers.length !== 0) {
          return (0, result_1.err)(`Unexpected number of '#' in ${element}, can only be used once.`);
        }
        const occurrenceNum = Number(occurrence);
        if (!occurrence || isNaN(occurrenceNum)) {
          return (0, result_1.err)(`Unexpected value following the '#' symbol, a positive number was expected but found ${occurrence}.`);
        }
        if (occurrenceNum > 5) {
          return (0, result_1.err)(`Number of occurrence of the day of the week cannot be greater than 5.`);
        }
        return checkSingleElementWithinLimits(day, cronFieldType, options);
      }
      return checkSingleElementWithinLimits(element, cronFieldType, options);
    };
    var checkRangeElement = (element, cronFieldType, options, position) => {
      if (element === "*") {
        return (0, result_1.err)(`'*' can't be part of a range in ${cronFieldType} field.`);
      }
      if (element === "") {
        return (0, result_1.err)(`One of the range elements is empty in ${cronFieldType} field.`);
      }
      if (options.useLastDayOfMonth && cronFieldType === "daysOfMonth" && element === "L" && position === 0) {
        return (0, result_1.valid)(true);
      }
      return checkSingleElementWithinLimits(element, cronFieldType, options);
    };
    var checkFirstStepElement = (firstStepElement, cronFieldType, options) => {
      const rangeArray = firstStepElement.split("-");
      if (rangeArray.length > 2) {
        return (0, result_1.err)(`List element '${firstStepElement}' is not valid. (More than one '-')`);
      }
      if (rangeArray.length === 1) {
        return checkSingleElement(rangeArray[0], cronFieldType, options);
      }
      if (rangeArray.length === 2) {
        const firstRangeElementResult = checkRangeElement(rangeArray[0], cronFieldType, options, 0);
        const secondRangeElementResult = checkRangeElement(rangeArray[1], cronFieldType, options, 1);
        if (firstRangeElementResult.isError()) {
          return firstRangeElementResult;
        }
        if (secondRangeElementResult.isError()) {
          return secondRangeElementResult;
        }
        if (Number(rangeArray[0]) > Number(rangeArray[1])) {
          return (0, result_1.err)(`Lower range end '${rangeArray[0]}' is bigger than upper range end '${rangeArray[1]}' of ${cronFieldType} field.`);
        }
        return (0, result_1.valid)(true);
      }
      return (0, result_1.err)("Some other error in checkFirstStepElement (rangeArray less than 1)");
    };
    var checkListElement = (listElement, cronFieldType, options) => {
      const stepArray = listElement.split("/");
      if (stepArray.length > 2) {
        return (0, result_1.err)(`List element '${listElement}' is not valid. (More than one '/')`);
      }
      const firstElementResult = checkFirstStepElement(stepArray[0], cronFieldType, options);
      if (firstElementResult.isError()) {
        return firstElementResult;
      }
      if (stepArray.length === 2) {
        const secondStepElement = stepArray[1];
        if (!secondStepElement) {
          return (0, result_1.err)(`Second step element '${secondStepElement}' of '${listElement}' is not valid (doesnt exist).`);
        }
        if (isNaN(Number(secondStepElement))) {
          return (0, result_1.err)(`Second step element '${secondStepElement}' of '${listElement}' is not valid (not a number).`);
        }
        if (Number(secondStepElement) === 0) {
          return (0, result_1.err)(`Second step element '${secondStepElement}' of '${listElement}' cannot be zero.`);
        }
      }
      return (0, result_1.valid)(true);
    };
    var checkField = (cronField, cronFieldType, options) => {
      if (![
        "seconds",
        "minutes",
        "hours",
        "daysOfMonth",
        "months",
        "daysOfWeek",
        "years"
      ].includes(cronFieldType)) {
        return (0, result_1.err)([`Cron field type '${cronFieldType}' does not exist.`]);
      }
      if (cronField === "?") {
        if (cronFieldType === "daysOfMonth" || cronFieldType === "daysOfWeek") {
          if (options.useBlankDay) {
            return (0, result_1.valid)(true);
          }
          return (0, result_1.err)([
            `useBlankDay is not enabled, but is used in ${cronFieldType} field`
          ]);
        }
        return (0, result_1.err)([`blank notation is not allowed in ${cronFieldType} field`]);
      }
      const listArray = cronField.split(",");
      const checkResults = [];
      listArray.forEach((listElement) => {
        checkResults.push(checkListElement(listElement, cronFieldType, options));
      });
      if (checkResults.every((value) => value.isValid())) {
        return (0, result_1.valid)(true);
      }
      const errorArray = [];
      checkResults.forEach((result) => {
        if (result.isError()) {
          errorArray.push(result.getError());
        }
      });
      return (0, result_1.err)(errorArray);
    };
    exports.default = checkField;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/secondChecker.js
var require_secondChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/secondChecker.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault2(require_helper());
    require_types();
    var checkSeconds = (cronData, options) => {
      if (!cronData.seconds) {
        return (0, result_1.err)([
          "seconds field is undefined, but useSeconds options is enabled."
        ]);
      }
      const { seconds } = cronData;
      return (0, helper_1.default)(seconds, "seconds", options);
    };
    exports.default = checkSeconds;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/minuteChecker.js
var require_minuteChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/minuteChecker.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault2(require_helper());
    require_types();
    var checkMinutes = (cronData, options) => {
      if (!cronData.minutes) {
        return (0, result_1.err)(["minutes field is undefined."]);
      }
      const { minutes } = cronData;
      return (0, helper_1.default)(minutes, "minutes", options);
    };
    exports.default = checkMinutes;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/hourChecker.js
var require_hourChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/hourChecker.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault2(require_helper());
    require_types();
    var checkHours = (cronData, options) => {
      if (!cronData.hours) {
        return (0, result_1.err)(["hours field is undefined."]);
      }
      const { hours } = cronData;
      return (0, helper_1.default)(hours, "hours", options);
    };
    exports.default = checkHours;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/dayOfMonthChecker.js
var require_dayOfMonthChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/dayOfMonthChecker.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault2(require_helper());
    require_types();
    var checkDaysOfMonth = (cronData, options) => {
      if (!cronData.daysOfMonth) {
        return (0, result_1.err)(["daysOfMonth field is undefined."]);
      }
      const { daysOfMonth } = cronData;
      if (options.allowOnlyOneBlankDayField && options.useBlankDay && cronData.daysOfMonth === "?" && cronData.daysOfWeek === "?") {
        return (0, result_1.err)([
          `Cannot use blank value in daysOfMonth and daysOfWeek field when allowOnlyOneBlankDayField option is enabled.`
        ]);
      }
      if (options.mustHaveBlankDayField && cronData.daysOfMonth !== "?" && cronData.daysOfWeek !== "?") {
        return (0, result_1.err)([
          `Cannot specify both daysOfMonth and daysOfWeek field when mustHaveBlankDayField option is enabled.`
        ]);
      }
      if (options.useLastDayOfMonth && cronData.daysOfMonth.indexOf("L") !== -1 && cronData.daysOfMonth.match(/[,/]/)) {
        return (0, result_1.err)([
          `Cannot specify last day of month with lists, or ranges (symbols ,/).`
        ]);
      }
      if (options.useNearestWeekday && cronData.daysOfMonth.indexOf("W") !== -1 && cronData.daysOfMonth.match(/[,/-]/)) {
        return (0, result_1.err)([
          `Cannot specify nearest weekday with lists, steps or ranges (symbols ,-/).`
        ]);
      }
      return (0, helper_1.default)(daysOfMonth, "daysOfMonth", options);
    };
    exports.default = checkDaysOfMonth;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/monthChecker.js
var require_monthChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/monthChecker.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault2(require_helper());
    require_types();
    var checkMonths = (cronData, options) => {
      if (!cronData.months) {
        return (0, result_1.err)(["months field is undefined."]);
      }
      const { months } = cronData;
      return (0, helper_1.default)(months, "months", options);
    };
    exports.default = checkMonths;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/dayOfWeekChecker.js
var require_dayOfWeekChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/dayOfWeekChecker.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault2(require_helper());
    require_types();
    var checkDaysOfWeek = (cronData, options) => {
      if (!cronData.daysOfWeek) {
        return (0, result_1.err)(["daysOfWeek field is undefined."]);
      }
      const { daysOfWeek } = cronData;
      if (options.allowOnlyOneBlankDayField && cronData.daysOfMonth === "?" && cronData.daysOfWeek === "?") {
        return (0, result_1.err)([
          `Cannot use blank value in daysOfMonth and daysOfWeek field when allowOnlyOneBlankDayField option is enabled.`
        ]);
      }
      if (options.mustHaveBlankDayField && cronData.daysOfMonth !== "?" && cronData.daysOfWeek !== "?") {
        return (0, result_1.err)([
          `Cannot specify both daysOfMonth and daysOfWeek field when mustHaveBlankDayField option is enabled.`
        ]);
      }
      if (options.useLastDayOfWeek && cronData.daysOfWeek.indexOf("L") !== -1 && cronData.daysOfWeek.match(/[,/-]/)) {
        return (0, result_1.err)([
          `Cannot specify last day of week with lists, steps or ranges (symbols ,-/).`
        ]);
      }
      if (options.useNthWeekdayOfMonth && cronData.daysOfWeek.indexOf("#") !== -1 && cronData.daysOfWeek.match(/[,/-]/)) {
        return (0, result_1.err)([
          `Cannot specify Nth weekday of month with lists, steps or ranges (symbols ,-/).`
        ]);
      }
      return (0, helper_1.default)(daysOfWeek, "daysOfWeek", options);
    };
    exports.default = checkDaysOfWeek;
  }
});

// ../../node_modules/cron-validate/lib/fieldCheckers/yearChecker.js
var require_yearChecker = __commonJS({
  "../../node_modules/cron-validate/lib/fieldCheckers/yearChecker.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    require_lib();
    var result_1 = require_result();
    var helper_1 = __importDefault2(require_helper());
    require_types();
    var checkYears = (cronData, options) => {
      if (!cronData.years) {
        return (0, result_1.err)(["years field is undefined, but useYears option is enabled."]);
      }
      const { years } = cronData;
      return (0, helper_1.default)(years, "years", options);
    };
    exports.default = checkYears;
  }
});

// ../../node_modules/nanoclone/src/index.js
function baseClone(src, circulars, clones) {
  if (!src || typeof src !== "object" || typeof src === "function") {
    return src;
  }
  if (src.nodeType && "cloneNode" in src) {
    return src.cloneNode(true);
  }
  if (src instanceof Date) {
    return new Date(src.getTime());
  }
  if (src instanceof RegExp) {
    return new RegExp(src);
  }
  if (Array.isArray(src)) {
    return src.map(clone);
  }
  if (map && src instanceof map) {
    return new Map(Array.from(src.entries()));
  }
  if (set && src instanceof set) {
    return new Set(Array.from(src.values()));
  }
  if (src instanceof Object) {
    circulars.push(src);
    var obj = Object.create(src);
    clones.push(obj);
    for (var key in src) {
      var idx = circulars.findIndex(function(i10) {
        return i10 === src[key];
      });
      obj[key] = idx > -1 ? clones[idx] : baseClone(src[key], circulars, clones);
    }
    return obj;
  }
  return src;
}
function clone(src) {
  return baseClone(src, [], []);
}
var map, set;
var init_src = __esm({
  "../../node_modules/nanoclone/src/index.js"() {
    "use strict";
    try {
      map = Map;
    } catch (_) {
    }
    try {
      set = Set;
    } catch (_) {
    }
  }
});

// ../../node_modules/yup/es/util/printValue.js
function printNumber(val2) {
  if (val2 != +val2)
    return "NaN";
  const isNegativeZero = val2 === 0 && 1 / val2 < 0;
  return isNegativeZero ? "-0" : "" + val2;
}
function printSimpleValue(val2, quoteStrings = false) {
  if (val2 == null || val2 === true || val2 === false)
    return "" + val2;
  const typeOf = typeof val2;
  if (typeOf === "number")
    return printNumber(val2);
  if (typeOf === "string")
    return quoteStrings ? `"${val2}"` : val2;
  if (typeOf === "function")
    return "[Function " + (val2.name || "anonymous") + "]";
  if (typeOf === "symbol")
    return symbolToString.call(val2).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString.call(val2).slice(8, -1);
  if (tag === "Date")
    return isNaN(val2.getTime()) ? "" + val2 : val2.toISOString(val2);
  if (tag === "Error" || val2 instanceof Error)
    return "[" + errorToString.call(val2) + "]";
  if (tag === "RegExp")
    return regExpToString.call(val2);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null)
    return result;
  return JSON.stringify(value, function(key, value2) {
    let result2 = printSimpleValue(this[key], quoteStrings);
    if (result2 !== null)
      return result2;
    return value2;
  }, 2);
}
var toString, errorToString, regExpToString, symbolToString, SYMBOL_REGEXP;
var init_printValue = __esm({
  "../../node_modules/yup/es/util/printValue.js"() {
    "use strict";
    toString = Object.prototype.toString;
    errorToString = Error.prototype.toString;
    regExpToString = RegExp.prototype.toString;
    symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
    SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
  }
});

// ../../node_modules/yup/es/locale.js
var mixed, string, number, date, boolean, object, array, locale_default;
var init_locale = __esm({
  "../../node_modules/yup/es/locale.js"() {
    "use strict";
    init_printValue();
    mixed = {
      default: "${path} is invalid",
      required: "${path} is a required field",
      oneOf: "${path} must be one of the following values: ${values}",
      notOneOf: "${path} must not be one of the following values: ${values}",
      notType: ({
        path,
        type,
        value,
        originalValue
      }) => {
        let isCast = originalValue != null && originalValue !== value;
        let msg = `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + (isCast ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".");
        if (value === null) {
          msg += `
 If "null" is intended as an empty value be sure to mark the schema as \`.nullable()\``;
        }
        return msg;
      },
      defined: "${path} must be defined"
    };
    string = {
      length: "${path} must be exactly ${length} characters",
      min: "${path} must be at least ${min} characters",
      max: "${path} must be at most ${max} characters",
      matches: '${path} must match the following: "${regex}"',
      email: "${path} must be a valid email",
      url: "${path} must be a valid URL",
      uuid: "${path} must be a valid UUID",
      trim: "${path} must be a trimmed string",
      lowercase: "${path} must be a lowercase string",
      uppercase: "${path} must be a upper case string"
    };
    number = {
      min: "${path} must be greater than or equal to ${min}",
      max: "${path} must be less than or equal to ${max}",
      lessThan: "${path} must be less than ${less}",
      moreThan: "${path} must be greater than ${more}",
      positive: "${path} must be a positive number",
      negative: "${path} must be a negative number",
      integer: "${path} must be an integer"
    };
    date = {
      min: "${path} field must be later than ${min}",
      max: "${path} field must be at earlier than ${max}"
    };
    boolean = {
      isValue: "${path} field must be ${value}"
    };
    object = {
      noUnknown: "${path} field has unspecified keys: ${unknown}"
    };
    array = {
      min: "${path} field must have at least ${min} items",
      max: "${path} field must have less than or equal to ${max} items",
      length: "${path} must be have ${length} items"
    };
    locale_default = Object.assign(/* @__PURE__ */ Object.create(null), {
      mixed,
      string,
      number,
      date,
      object,
      array,
      boolean
    });
  }
});

// ../../node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "../../node_modules/lodash/_baseHas.js"(exports, module2) {
    "use strict";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object2, key) {
      return object2 != null && hasOwnProperty.call(object2, key);
    }
    module2.exports = baseHas;
  }
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/lodash/isArray.js"(exports, module2) {
    "use strict";
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports, module2) {
    "use strict";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports, module2) {
    "use strict";
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports, module2) {
    "use strict";
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e10) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports, module2) {
    "use strict";
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports, module2) {
    "use strict";
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../node_modules/lodash/isSymbol.js"(exports, module2) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// ../../node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "../../node_modules/lodash/_isKey.js"(exports, module2) {
    "use strict";
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    module2.exports = isKey;
  }
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/lodash/isObject.js"(exports, module2) {
    "use strict";
    function isObject3(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject3;
  }
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/lodash/isFunction.js"(exports, module2) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObject3 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction3(value) {
      if (!isObject3(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction3;
  }
});

// ../../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/lodash/_coreJsData.js"(exports, module2) {
    "use strict";
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/lodash/_isMasked.js"(exports, module2) {
    "use strict";
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/lodash/_toSource.js"(exports, module2) {
    "use strict";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e10) {
        }
        try {
          return func + "";
        } catch (e10) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/lodash/_baseIsNative.js"(exports, module2) {
    "use strict";
    var isFunction3 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject3 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject3(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/lodash/_getValue.js"(exports, module2) {
    "use strict";
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    module2.exports = getValue;
  }
});

// ../../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/lodash/_getNative.js"(exports, module2) {
    "use strict";
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../../node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/lodash/_nativeCreate.js"(exports, module2) {
    "use strict";
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// ../../node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/lodash/_hashClear.js"(exports, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// ../../node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/lodash/_hashDelete.js"(exports, module2) {
    "use strict";
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// ../../node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/lodash/_hashGet.js"(exports, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// ../../node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/lodash/_hashHas.js"(exports, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// ../../node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/lodash/_hashSet.js"(exports, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// ../../node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/lodash/_Hash.js"(exports, module2) {
    "use strict";
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash3(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash3.prototype.clear = hashClear;
    Hash3.prototype["delete"] = hashDelete;
    Hash3.prototype.get = hashGet;
    Hash3.prototype.has = hashHas;
    Hash3.prototype.set = hashSet;
    module2.exports = Hash3;
  }
});

// ../../node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/lodash/_listCacheClear.js"(exports, module2) {
    "use strict";
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// ../../node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../node_modules/lodash/eq.js"(exports, module2) {
    "use strict";
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// ../../node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/lodash/_assocIndexOf.js"(exports, module2) {
    "use strict";
    var eq = require_eq();
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// ../../node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/lodash/_listCacheDelete.js"(exports, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// ../../node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/lodash/_listCacheGet.js"(exports, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// ../../node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/lodash/_listCacheHas.js"(exports, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// ../../node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/lodash/_listCacheSet.js"(exports, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// ../../node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/lodash/_ListCache.js"(exports, module2) {
    "use strict";
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// ../../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/lodash/_Map.js"(exports, module2) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// ../../node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/lodash/_mapCacheClear.js"(exports, module2) {
    "use strict";
    var Hash3 = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash3(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash3()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// ../../node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/lodash/_isKeyable.js"(exports, module2) {
    "use strict";
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// ../../node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/lodash/_getMapData.js"(exports, module2) {
    "use strict";
    var isKeyable = require_isKeyable();
    function getMapData(map6, key) {
      var data = map6.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// ../../node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/lodash/_mapCacheGet.js"(exports, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// ../../node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/lodash/_mapCacheHas.js"(exports, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// ../../node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/lodash/_mapCacheSet.js"(exports, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// ../../node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/lodash/_MapCache.js"(exports, module2) {
    "use strict";
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// ../../node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "../../node_modules/lodash/memoize.js"(exports, module2) {
    "use strict";
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize3(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize3.Cache || MapCache)();
      return memoized;
    }
    memoize3.Cache = MapCache;
    module2.exports = memoize3;
  }
});

// ../../node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "../../node_modules/lodash/_memoizeCapped.js"(exports, module2) {
    "use strict";
    var memoize3 = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize3(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// ../../node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "../../node_modules/lodash/_stringToPath.js"(exports, module2) {
    "use strict";
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// ../../node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../node_modules/lodash/_arrayMap.js"(exports, module2) {
    "use strict";
    function arrayMap(array2, iteratee) {
      var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// ../../node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../../node_modules/lodash/_baseToString.js"(exports, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString2 ? symbolToString2.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// ../../node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../../node_modules/lodash/toString.js"(exports, module2) {
    "use strict";
    var baseToString = require_baseToString();
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString2;
  }
});

// ../../node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "../../node_modules/lodash/_castPath.js"(exports, module2) {
    "use strict";
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString2 = require_toString();
    function castPath(value, object2) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath(toString2(value));
    }
    module2.exports = castPath;
  }
});

// ../../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/lodash/_baseIsArguments.js"(exports, module2) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/lodash/isArguments.js"(exports, module2) {
    "use strict";
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/lodash/_isIndex.js"(exports, module2) {
    "use strict";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/lodash/isLength.js"(exports, module2) {
    "use strict";
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../../node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "../../node_modules/lodash/_toKey.js"(exports, module2) {
    "use strict";
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// ../../node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "../../node_modules/lodash/_hasPath.js"(exports, module2) {
    "use strict";
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object2, path, hasFunc) {
      path = castPath(path, object2);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object2 == null ? 0 : object2.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
    }
    module2.exports = hasPath;
  }
});

// ../../node_modules/lodash/has.js
var require_has = __commonJS({
  "../../node_modules/lodash/has.js"(exports, module2) {
    "use strict";
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has4(object2, path) {
      return object2 != null && hasPath(object2, path, baseHas);
    }
    module2.exports = has4;
  }
});

// ../../node_modules/yup/es/util/isSchema.js
var isSchema_default;
var init_isSchema = __esm({
  "../../node_modules/yup/es/util/isSchema.js"() {
    "use strict";
    isSchema_default = (obj) => obj && obj.__isYupSchema__;
  }
});

// ../../node_modules/yup/es/Condition.js
var import_has, Condition, Condition_default;
var init_Condition = __esm({
  "../../node_modules/yup/es/Condition.js"() {
    "use strict";
    import_has = __toESM(require_has());
    init_isSchema();
    Condition = class {
      constructor(refs, options) {
        this.refs = refs;
        this.refs = refs;
        if (typeof options === "function") {
          this.fn = options;
          return;
        }
        if (!(0, import_has.default)(options, "is"))
          throw new TypeError("`is:` is required for `when()` conditions");
        if (!options.then && !options.otherwise)
          throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
        let {
          is,
          then,
          otherwise
        } = options;
        let check = typeof is === "function" ? is : (...values) => values.every((value) => value === is);
        this.fn = function(...args) {
          let options2 = args.pop();
          let schema = args.pop();
          let branch = check(...args) ? then : otherwise;
          if (!branch)
            return void 0;
          if (typeof branch === "function")
            return branch(schema);
          return schema.concat(branch.resolve(options2));
        };
      }
      resolve(base, options) {
        let values = this.refs.map((ref) => ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
        let schema = this.fn.apply(base, values.concat(base, options));
        if (schema === void 0 || schema === base)
          return base;
        if (!isSchema_default(schema))
          throw new TypeError("conditions must return a schema object");
        return schema.resolve(options);
      }
    };
    Condition_default = Condition;
  }
});

// ../../node_modules/yup/es/util/toArray.js
function toArray(value) {
  return value == null ? [] : [].concat(value);
}
var init_toArray = __esm({
  "../../node_modules/yup/es/util/toArray.js"() {
    "use strict";
  }
});

// ../../node_modules/yup/es/ValidationError.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i10 = 1; i10 < arguments.length; i10++) {
      var source = arguments[i10];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var strReg, ValidationError;
var init_ValidationError = __esm({
  "../../node_modules/yup/es/ValidationError.js"() {
    "use strict";
    init_printValue();
    init_toArray();
    strReg = /\$\{\s*(\w+)\s*\}/g;
    ValidationError = class _ValidationError extends Error {
      static formatError(message, params) {
        const path = params.label || params.path || "this";
        if (path !== params.path)
          params = _extends({}, params, {
            path
          });
        if (typeof message === "string")
          return message.replace(strReg, (_, key) => printValue(params[key]));
        if (typeof message === "function")
          return message(params);
        return message;
      }
      static isError(err) {
        return err && err.name === "ValidationError";
      }
      constructor(errorOrErrors, value, field, type) {
        super();
        this.name = "ValidationError";
        this.value = value;
        this.path = field;
        this.type = type;
        this.errors = [];
        this.inner = [];
        toArray(errorOrErrors).forEach((err) => {
          if (_ValidationError.isError(err)) {
            this.errors.push(...err.errors);
            this.inner = this.inner.concat(err.inner.length ? err.inner : err);
          } else {
            this.errors.push(err);
          }
        });
        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, _ValidationError);
      }
    };
  }
});

// ../../node_modules/yup/es/util/runTests.js
function runTests(options, cb) {
  let {
    endEarly,
    tests,
    args,
    value,
    errors,
    sort,
    path
  } = options;
  let callback = once(cb);
  let count2 = tests.length;
  const nestedErrors = [];
  errors = errors ? errors : [];
  if (!count2)
    return errors.length ? callback(new ValidationError(errors, value, path)) : callback(null, value);
  for (let i10 = 0; i10 < tests.length; i10++) {
    const test = tests[i10];
    test(args, function finishTestRun(err) {
      if (err) {
        if (!ValidationError.isError(err)) {
          return callback(err, value);
        }
        if (endEarly) {
          err.value = value;
          return callback(err, value);
        }
        nestedErrors.push(err);
      }
      if (--count2 <= 0) {
        if (nestedErrors.length) {
          if (sort)
            nestedErrors.sort(sort);
          if (errors.length)
            nestedErrors.push(...errors);
          errors = nestedErrors;
        }
        if (errors.length) {
          callback(new ValidationError(errors, value, path), value);
          return;
        }
        callback(null, value);
      }
    });
  }
}
var once;
var init_runTests = __esm({
  "../../node_modules/yup/es/util/runTests.js"() {
    "use strict";
    init_ValidationError();
    once = (cb) => {
      let fired = false;
      return (...args) => {
        if (fired)
          return;
        fired = true;
        cb(...args);
      };
    };
  }
});

// ../../node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/lodash/_defineProperty.js"(exports, module2) {
    "use strict";
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e10) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// ../../node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "../../node_modules/lodash/_baseAssignValue.js"(exports, module2) {
    "use strict";
    var defineProperty = require_defineProperty();
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// ../../node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "../../node_modules/lodash/_createBaseFor.js"(exports, module2) {
    "use strict";
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    module2.exports = createBaseFor;
  }
});

// ../../node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "../../node_modules/lodash/_baseFor.js"(exports, module2) {
    "use strict";
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// ../../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/lodash/_baseTimes.js"(exports, module2) {
    "use strict";
    function baseTimes(n10, iteratee) {
      var index = -1, result = Array(n10);
      while (++index < n10) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/lodash/stubFalse.js"(exports, module2) {
    "use strict";
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/lodash/isBuffer.js"(exports, module2) {
    "use strict";
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer8 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer8 ? Buffer8.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/lodash/_baseIsTypedArray.js"(exports, module2) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/lodash/_baseUnary.js"(exports, module2) {
    "use strict";
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/lodash/_nodeUtil.js"(exports, module2) {
    "use strict";
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e10) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/lodash/isTypedArray.js"(exports, module2) {
    "use strict";
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/lodash/_arrayLikeKeys.js"(exports, module2) {
    "use strict";
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/lodash/_isPrototype.js"(exports, module2) {
    "use strict";
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// ../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/lodash/_overArg.js"(exports, module2) {
    "use strict";
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../../node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../node_modules/lodash/_nativeKeys.js"(exports, module2) {
    "use strict";
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../../node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../node_modules/lodash/_baseKeys.js"(exports, module2) {
    "use strict";
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/lodash/isArrayLike.js"(exports, module2) {
    "use strict";
    var isFunction3 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../../node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../node_modules/lodash/keys.js"(exports, module2) {
    "use strict";
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    module2.exports = keys;
  }
});

// ../../node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "../../node_modules/lodash/_baseForOwn.js"(exports, module2) {
    "use strict";
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object2, iteratee) {
      return object2 && baseFor(object2, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// ../../node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../../node_modules/lodash/_stackClear.js"(exports, module2) {
    "use strict";
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// ../../node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../../node_modules/lodash/_stackDelete.js"(exports, module2) {
    "use strict";
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// ../../node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../../node_modules/lodash/_stackGet.js"(exports, module2) {
    "use strict";
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// ../../node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../../node_modules/lodash/_stackHas.js"(exports, module2) {
    "use strict";
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// ../../node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../../node_modules/lodash/_stackSet.js"(exports, module2) {
    "use strict";
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// ../../node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../../node_modules/lodash/_Stack.js"(exports, module2) {
    "use strict";
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// ../../node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../../node_modules/lodash/_setCacheAdd.js"(exports, module2) {
    "use strict";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// ../../node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../../node_modules/lodash/_setCacheHas.js"(exports, module2) {
    "use strict";
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// ../../node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../../node_modules/lodash/_SetCache.js"(exports, module2) {
    "use strict";
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// ../../node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "../../node_modules/lodash/_arraySome.js"(exports, module2) {
    "use strict";
    function arraySome(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (predicate(array2[index], index, array2)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// ../../node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../../node_modules/lodash/_cacheHas.js"(exports, module2) {
    "use strict";
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// ../../node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "../../node_modules/lodash/_equalArrays.js"(exports, module2) {
    "use strict";
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index < arrLength) {
        var arrValue = array2[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// ../../node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../../node_modules/lodash/_Uint8Array.js"(exports, module2) {
    "use strict";
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// ../../node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../../node_modules/lodash/_mapToArray.js"(exports, module2) {
    "use strict";
    function mapToArray(map6) {
      var index = -1, result = Array(map6.size);
      map6.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// ../../node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../../node_modules/lodash/_setToArray.js"(exports, module2) {
    "use strict";
    function setToArray(set5) {
      var index = -1, result = Array(set5.size);
      set5.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// ../../node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "../../node_modules/lodash/_equalByTag.js"(exports, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// ../../node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../node_modules/lodash/_arrayPush.js"(exports, module2) {
    "use strict";
    function arrayPush(array2, values) {
      var index = -1, length = values.length, offset = array2.length;
      while (++index < length) {
        array2[offset + index] = values[index];
      }
      return array2;
    }
    module2.exports = arrayPush;
  }
});

// ../../node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../../node_modules/lodash/_baseGetAllKeys.js"(exports, module2) {
    "use strict";
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    module2.exports = baseGetAllKeys;
  }
});

// ../../node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../../node_modules/lodash/_arrayFilter.js"(exports, module2) {
    "use strict";
    function arrayFilter(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// ../../node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../../node_modules/lodash/stubArray.js"(exports, module2) {
    "use strict";
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// ../../node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../../node_modules/lodash/_getSymbols.js"(exports, module2) {
    "use strict";
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// ../../node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../../node_modules/lodash/_getAllKeys.js"(exports, module2) {
    "use strict";
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// ../../node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "../../node_modules/lodash/_equalObjects.js"(exports, module2) {
    "use strict";
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// ../../node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../../node_modules/lodash/_DataView.js"(exports, module2) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module2.exports = DataView2;
  }
});

// ../../node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../../node_modules/lodash/_Promise.js"(exports, module2) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// ../../node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../node_modules/lodash/_Set.js"(exports, module2) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// ../../node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../../node_modules/lodash/_WeakMap.js"(exports, module2) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap = getNative(root, "WeakMap");
    module2.exports = WeakMap;
  }
});

// ../../node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../../node_modules/lodash/_getTag.js"(exports, module2) {
    "use strict";
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// ../../node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "../../node_modules/lodash/_baseIsEqualDeep.js"(exports, module2) {
    "use strict";
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// ../../node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "../../node_modules/lodash/_baseIsEqual.js"(exports, module2) {
    "use strict";
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// ../../node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "../../node_modules/lodash/_baseIsMatch.js"(exports, module2) {
    "use strict";
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object2, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object2 == null) {
        return !length;
      }
      object2 = Object(object2);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// ../../node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "../../node_modules/lodash/_isStrictComparable.js"(exports, module2) {
    "use strict";
    var isObject3 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject3(value);
    }
    module2.exports = isStrictComparable;
  }
});

// ../../node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "../../node_modules/lodash/_getMatchData.js"(exports, module2) {
    "use strict";
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object2) {
      var result = keys(object2), length = result.length;
      while (length--) {
        var key = result[length], value = object2[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// ../../node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "../../node_modules/lodash/_matchesStrictComparable.js"(exports, module2) {
    "use strict";
    function matchesStrictComparable(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// ../../node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "../../node_modules/lodash/_baseMatches.js"(exports, module2) {
    "use strict";
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// ../../node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "../../node_modules/lodash/_baseGet.js"(exports, module2) {
    "use strict";
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object2, path) {
      path = castPath(path, object2);
      var index = 0, length = path.length;
      while (object2 != null && index < length) {
        object2 = object2[toKey(path[index++])];
      }
      return index && index == length ? object2 : void 0;
    }
    module2.exports = baseGet;
  }
});

// ../../node_modules/lodash/get.js
var require_get = __commonJS({
  "../../node_modules/lodash/get.js"(exports, module2) {
    "use strict";
    var baseGet = require_baseGet();
    function get3(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get3;
  }
});

// ../../node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "../../node_modules/lodash/_baseHasIn.js"(exports, module2) {
    "use strict";
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    module2.exports = baseHasIn;
  }
});

// ../../node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "../../node_modules/lodash/hasIn.js"(exports, module2) {
    "use strict";
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object2, path) {
      return object2 != null && hasPath(object2, path, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// ../../node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "../../node_modules/lodash/_baseMatchesProperty.js"(exports, module2) {
    "use strict";
    var baseIsEqual = require_baseIsEqual();
    var get3 = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object2) {
        var objValue = get3(object2, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// ../../node_modules/lodash/identity.js
var require_identity = __commonJS({
  "../../node_modules/lodash/identity.js"(exports, module2) {
    "use strict";
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// ../../node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "../../node_modules/lodash/_baseProperty.js"(exports, module2) {
    "use strict";
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    module2.exports = baseProperty;
  }
});

// ../../node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "../../node_modules/lodash/_basePropertyDeep.js"(exports, module2) {
    "use strict";
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object2) {
        return baseGet(object2, path);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// ../../node_modules/lodash/property.js
var require_property = __commonJS({
  "../../node_modules/lodash/property.js"(exports, module2) {
    "use strict";
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = property;
  }
});

// ../../node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "../../node_modules/lodash/_baseIteratee.js"(exports, module2) {
    "use strict";
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// ../../node_modules/lodash/mapValues.js
var require_mapValues = __commonJS({
  "../../node_modules/lodash/mapValues.js"(exports, module2) {
    "use strict";
    var baseAssignValue = require_baseAssignValue();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    function mapValues3(object2, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);
      baseForOwn(object2, function(value, key, object3) {
        baseAssignValue(result, key, iteratee(value, key, object3));
      });
      return result;
    }
    module2.exports = mapValues3;
  }
});

// ../../node_modules/property-expr/index.js
var require_property_expr = __commonJS({
  "../../node_modules/property-expr/index.js"(exports, module2) {
    "use strict";
    function Cache(maxSize) {
      this._maxSize = maxSize;
      this.clear();
    }
    Cache.prototype.clear = function() {
      this._size = 0;
      this._values = /* @__PURE__ */ Object.create(null);
    };
    Cache.prototype.get = function(key) {
      return this._values[key];
    };
    Cache.prototype.set = function(key, value) {
      this._size >= this._maxSize && this.clear();
      if (!(key in this._values))
        this._size++;
      return this._values[key] = value;
    };
    var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
    var DIGIT_REGEX = /^\d+$/;
    var LEAD_DIGIT_REGEX = /^\d/;
    var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
    var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
    var MAX_CACHE_SIZE3 = 512;
    var pathCache = new Cache(MAX_CACHE_SIZE3);
    var setCache = new Cache(MAX_CACHE_SIZE3);
    var getCache = new Cache(MAX_CACHE_SIZE3);
    module2.exports = {
      Cache,
      split: split2,
      normalizePath,
      setter: function(path) {
        var parts = normalizePath(path);
        return setCache.get(path) || setCache.set(path, function setter(obj, value) {
          var index = 0;
          var len = parts.length;
          var data = obj;
          while (index < len - 1) {
            var part = parts[index];
            if (part === "__proto__" || part === "constructor" || part === "prototype") {
              return obj;
            }
            data = data[parts[index++]];
          }
          data[parts[index]] = value;
        });
      },
      getter: function(path, safe) {
        var parts = normalizePath(path);
        return getCache.get(path) || getCache.set(path, function getter3(data) {
          var index = 0, len = parts.length;
          while (index < len) {
            if (data != null || !safe)
              data = data[parts[index++]];
            else
              return;
          }
          return data;
        });
      },
      join: function(segments) {
        return segments.reduce(function(path, part) {
          return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
        }, "");
      },
      forEach: function(path, cb, thisArg) {
        forEach2(Array.isArray(path) ? path : split2(path), cb, thisArg);
      }
    };
    function normalizePath(path) {
      return pathCache.get(path) || pathCache.set(
        path,
        split2(path).map(function(part) {
          return part.replace(CLEAN_QUOTES_REGEX, "$2");
        })
      );
    }
    function split2(path) {
      return path.match(SPLIT_REGEX) || [""];
    }
    function forEach2(parts, iter, thisArg) {
      var len = parts.length, part, idx, isArray, isBracket;
      for (idx = 0; idx < len; idx++) {
        part = parts[idx];
        if (part) {
          if (shouldBeQuoted(part)) {
            part = '"' + part + '"';
          }
          isBracket = isQuoted(part);
          isArray = !isBracket && /^\d+$/.test(part);
          iter.call(thisArg, part, isBracket, isArray, idx, parts);
        }
      }
    }
    function isQuoted(str) {
      return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
    }
    function hasLeadingNumber(part) {
      return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
    }
    function hasSpecialChars(part) {
      return SPEC_CHAR_REGEX.test(part);
    }
    function shouldBeQuoted(part) {
      return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
    }
  }
});

// ../../node_modules/yup/es/Reference.js
function create(key, options) {
  return new Reference(key, options);
}
var import_property_expr, prefixes, Reference;
var init_Reference = __esm({
  "../../node_modules/yup/es/Reference.js"() {
    "use strict";
    import_property_expr = __toESM(require_property_expr());
    prefixes = {
      context: "$",
      value: "."
    };
    Reference = class {
      constructor(key, options = {}) {
        if (typeof key !== "string")
          throw new TypeError("ref must be a string, got: " + key);
        this.key = key.trim();
        if (key === "")
          throw new TypeError("ref must be a non-empty string");
        this.isContext = this.key[0] === prefixes.context;
        this.isValue = this.key[0] === prefixes.value;
        this.isSibling = !this.isContext && !this.isValue;
        let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
        this.path = this.key.slice(prefix.length);
        this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
        this.map = options.map;
      }
      getValue(value, parent, context) {
        let result = this.isContext ? context : this.isValue ? value : parent;
        if (this.getter)
          result = this.getter(result || {});
        if (this.map)
          result = this.map(result);
        return result;
      }
      /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {Object=} options.context
       * @param {Object=} options.parent
       */
      cast(value, options) {
        return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
      }
      resolve() {
        return this;
      }
      describe() {
        return {
          type: "ref",
          key: this.key
        };
      }
      toString() {
        return `Ref(${this.key})`;
      }
      static isRef(value) {
        return value && value.__isYupRef;
      }
    };
    Reference.prototype.__isYupRef = true;
  }
});

// ../../node_modules/yup/es/util/createValidation.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i10 = 1; i10 < arguments.length; i10++) {
      var source = arguments[i10];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i10;
  for (i10 = 0; i10 < sourceKeys.length; i10++) {
    key = sourceKeys[i10];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createValidation(config) {
  function validate2(_ref, cb) {
    let {
      value,
      path = "",
      label,
      options,
      originalValue,
      sync
    } = _ref, rest = _objectWithoutPropertiesLoose(_ref, ["value", "path", "label", "options", "originalValue", "sync"]);
    const {
      name,
      test,
      params,
      message
    } = config;
    let {
      parent,
      context
    } = options;
    function resolve(item) {
      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
    }
    function createError2(overrides = {}) {
      const nextParams = (0, import_mapValues.default)(_extends2({
        value,
        originalValue,
        label,
        path: overrides.path || path
      }, params, overrides.params), resolve);
      const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name);
      error.params = nextParams;
      return error;
    }
    let ctx = _extends2({
      path,
      parent,
      type: name,
      createError: createError2,
      resolve,
      options,
      originalValue
    }, rest);
    if (!sync) {
      try {
        Promise.resolve(test.call(ctx, value, ctx)).then((validOrError) => {
          if (ValidationError.isError(validOrError))
            cb(validOrError);
          else if (!validOrError)
            cb(createError2());
          else
            cb(null, validOrError);
        });
      } catch (err) {
        cb(err);
      }
      return;
    }
    let result;
    try {
      var _ref2;
      result = test.call(ctx, value, ctx);
      if (typeof ((_ref2 = result) == null ? void 0 : _ref2.then) === "function") {
        throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
      }
    } catch (err) {
      cb(err);
      return;
    }
    if (ValidationError.isError(result))
      cb(result);
    else if (!result)
      cb(createError2());
    else
      cb(null, result);
  }
  validate2.OPTIONS = config;
  return validate2;
}
var import_mapValues;
var init_createValidation = __esm({
  "../../node_modules/yup/es/util/createValidation.js"() {
    "use strict";
    import_mapValues = __toESM(require_mapValues());
    init_ValidationError();
    init_Reference();
  }
});

// ../../node_modules/yup/es/util/reach.js
function getIn(schema, path, value, context = value) {
  let parent, lastPart, lastPartDebug;
  if (!path)
    return {
      parent,
      parentPath: path,
      schema
    };
  (0, import_property_expr2.forEach)(path, (_part, isBracket, isArray) => {
    let part = isBracket ? trim(_part) : _part;
    schema = schema.resolve({
      context,
      parent,
      value
    });
    if (schema.innerType) {
      let idx = isArray ? parseInt(part, 10) : 0;
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
      }
      parent = value;
      value = value && value[idx];
      schema = schema.innerType;
    }
    if (!isArray) {
      if (!schema.fields || !schema.fields[part])
        throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema._type}")`);
      parent = value;
      value = value && value[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
  });
  return {
    schema,
    parent,
    parentPath: lastPart
  };
}
var import_property_expr2, trim, reach, reach_default;
var init_reach = __esm({
  "../../node_modules/yup/es/util/reach.js"() {
    "use strict";
    import_property_expr2 = __toESM(require_property_expr());
    trim = (part) => part.substr(0, part.length - 1).substr(1);
    reach = (obj, path, value, context) => getIn(obj, path, value, context).schema;
    reach_default = reach;
  }
});

// ../../node_modules/yup/es/util/ReferenceSet.js
var ReferenceSet;
var init_ReferenceSet = __esm({
  "../../node_modules/yup/es/util/ReferenceSet.js"() {
    "use strict";
    init_Reference();
    ReferenceSet = class _ReferenceSet {
      constructor() {
        this.list = /* @__PURE__ */ new Set();
        this.refs = /* @__PURE__ */ new Map();
      }
      get size() {
        return this.list.size + this.refs.size;
      }
      describe() {
        const description = [];
        for (const item of this.list)
          description.push(item);
        for (const [, ref] of this.refs)
          description.push(ref.describe());
        return description;
      }
      toArray() {
        return Array.from(this.list).concat(Array.from(this.refs.values()));
      }
      add(value) {
        Reference.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
      }
      delete(value) {
        Reference.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);
      }
      has(value, resolve) {
        if (this.list.has(value))
          return true;
        let item, values = this.refs.values();
        while (item = values.next(), !item.done)
          if (resolve(item.value) === value)
            return true;
        return false;
      }
      clone() {
        const next = new _ReferenceSet();
        next.list = new Set(this.list);
        next.refs = new Map(this.refs);
        return next;
      }
      merge(newItems, removeItems) {
        const next = this.clone();
        newItems.list.forEach((value) => next.add(value));
        newItems.refs.forEach((value) => next.add(value));
        removeItems.list.forEach((value) => next.delete(value));
        removeItems.refs.forEach((value) => next.delete(value));
        return next;
      }
    };
  }
});

// ../../node_modules/yup/es/schema.js
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i10 = 1; i10 < arguments.length; i10++) {
      var source = arguments[i10];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
var BaseSchema;
var init_schema = __esm({
  "../../node_modules/yup/es/schema.js"() {
    "use strict";
    init_src();
    init_locale();
    init_Condition();
    init_runTests();
    init_createValidation();
    init_printValue();
    init_Reference();
    init_reach();
    init_toArray();
    init_ValidationError();
    init_ReferenceSet();
    BaseSchema = class {
      constructor(options) {
        this.deps = [];
        this.conditions = [];
        this._whitelist = new ReferenceSet();
        this._blacklist = new ReferenceSet();
        this.exclusiveTests = /* @__PURE__ */ Object.create(null);
        this.tests = [];
        this.transforms = [];
        this.withMutation(() => {
          this.typeError(mixed.notType);
        });
        this.type = (options == null ? void 0 : options.type) || "mixed";
        this.spec = _extends3({
          strip: false,
          strict: false,
          abortEarly: true,
          recursive: true,
          nullable: false,
          presence: "optional"
        }, options == null ? void 0 : options.spec);
      }
      // TODO: remove
      get _type() {
        return this.type;
      }
      _typeCheck(_value) {
        return true;
      }
      clone(spec) {
        if (this._mutate) {
          if (spec)
            Object.assign(this.spec, spec);
          return this;
        }
        const next = Object.create(Object.getPrototypeOf(this));
        next.type = this.type;
        next._typeError = this._typeError;
        next._whitelistError = this._whitelistError;
        next._blacklistError = this._blacklistError;
        next._whitelist = this._whitelist.clone();
        next._blacklist = this._blacklist.clone();
        next.exclusiveTests = _extends3({}, this.exclusiveTests);
        next.deps = [...this.deps];
        next.conditions = [...this.conditions];
        next.tests = [...this.tests];
        next.transforms = [...this.transforms];
        next.spec = clone(_extends3({}, this.spec, spec));
        return next;
      }
      label(label) {
        var next = this.clone();
        next.spec.label = label;
        return next;
      }
      meta(...args) {
        if (args.length === 0)
          return this.spec.meta;
        let next = this.clone();
        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
        return next;
      }
      // withContext<TContext extends AnyObject>(): BaseSchema<
      //   TCast,
      //   TContext,
      //   TOutput
      // > {
      //   return this as any;
      // }
      withMutation(fn) {
        let before = this._mutate;
        this._mutate = true;
        let result = fn(this);
        this._mutate = before;
        return result;
      }
      concat(schema) {
        if (!schema || schema === this)
          return this;
        if (schema.type !== this.type && this.type !== "mixed")
          throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
        let base = this;
        let combined = schema.clone();
        const mergedSpec = _extends3({}, base.spec, combined.spec);
        combined.spec = mergedSpec;
        combined._typeError || (combined._typeError = base._typeError);
        combined._whitelistError || (combined._whitelistError = base._whitelistError);
        combined._blacklistError || (combined._blacklistError = base._blacklistError);
        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
        combined.tests = base.tests;
        combined.exclusiveTests = base.exclusiveTests;
        combined.withMutation((next) => {
          schema.tests.forEach((fn) => {
            next.test(fn.OPTIONS);
          });
        });
        return combined;
      }
      isType(v6) {
        if (this.spec.nullable && v6 === null)
          return true;
        return this._typeCheck(v6);
      }
      resolve(options) {
        let schema = this;
        if (schema.conditions.length) {
          let conditions = schema.conditions;
          schema = schema.clone();
          schema.conditions = [];
          schema = conditions.reduce((schema2, condition) => condition.resolve(schema2, options), schema);
          schema = schema.resolve(options);
        }
        return schema;
      }
      /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {*=} options.parent
       * @param {*=} options.context
       */
      cast(value, options = {}) {
        let resolvedSchema = this.resolve(_extends3({
          value
        }, options));
        let result = resolvedSchema._cast(value, options);
        if (value !== void 0 && options.assert !== false && resolvedSchema.isType(result) !== true) {
          let formattedValue = printValue(value);
          let formattedResult = printValue(result);
          throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema._type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
        }
        return result;
      }
      _cast(rawValue, _options) {
        let value = rawValue === void 0 ? rawValue : this.transforms.reduce((value2, fn) => fn.call(this, value2, rawValue, this), rawValue);
        if (value === void 0) {
          value = this.getDefault();
        }
        return value;
      }
      _validate(_value, options = {}, cb) {
        let {
          sync,
          path,
          from = [],
          originalValue = _value,
          strict = this.spec.strict,
          abortEarly = this.spec.abortEarly
        } = options;
        let value = _value;
        if (!strict) {
          value = this._cast(value, _extends3({
            assert: false
          }, options));
        }
        let args = {
          value,
          path,
          options,
          originalValue,
          schema: this,
          label: this.spec.label,
          sync,
          from
        };
        let initialTests = [];
        if (this._typeError)
          initialTests.push(this._typeError);
        if (this._whitelistError)
          initialTests.push(this._whitelistError);
        if (this._blacklistError)
          initialTests.push(this._blacklistError);
        runTests({
          args,
          value,
          path,
          sync,
          tests: initialTests,
          endEarly: abortEarly
        }, (err) => {
          if (err)
            return void cb(err, value);
          runTests({
            tests: this.tests,
            args,
            path,
            sync,
            value,
            endEarly: abortEarly
          }, cb);
        });
      }
      validate(value, options, maybeCb) {
        let schema = this.resolve(_extends3({}, options, {
          value
        }));
        return typeof maybeCb === "function" ? schema._validate(value, options, maybeCb) : new Promise((resolve, reject) => schema._validate(value, options, (err, value2) => {
          if (err)
            reject(err);
          else
            resolve(value2);
        }));
      }
      validateSync(value, options) {
        let schema = this.resolve(_extends3({}, options, {
          value
        }));
        let result;
        schema._validate(value, _extends3({}, options, {
          sync: true
        }), (err, value2) => {
          if (err)
            throw err;
          result = value2;
        });
        return result;
      }
      isValid(value, options) {
        return this.validate(value, options).then(() => true, (err) => {
          if (ValidationError.isError(err))
            return false;
          throw err;
        });
      }
      isValidSync(value, options) {
        try {
          this.validateSync(value, options);
          return true;
        } catch (err) {
          if (ValidationError.isError(err))
            return false;
          throw err;
        }
      }
      _getDefault() {
        let defaultValue = this.spec.default;
        if (defaultValue == null) {
          return defaultValue;
        }
        return typeof defaultValue === "function" ? defaultValue.call(this) : clone(defaultValue);
      }
      getDefault(options) {
        let schema = this.resolve(options || {});
        return schema._getDefault();
      }
      default(def) {
        if (arguments.length === 0) {
          return this._getDefault();
        }
        let next = this.clone({
          default: def
        });
        return next;
      }
      strict(isStrict = true) {
        var next = this.clone();
        next.spec.strict = isStrict;
        return next;
      }
      _isPresent(value) {
        return value != null;
      }
      defined(message = mixed.defined) {
        return this.test({
          message,
          name: "defined",
          exclusive: true,
          test(value) {
            return value !== void 0;
          }
        });
      }
      required(message = mixed.required) {
        return this.clone({
          presence: "required"
        }).withMutation((s10) => s10.test({
          message,
          name: "required",
          exclusive: true,
          test(value) {
            return this.schema._isPresent(value);
          }
        }));
      }
      notRequired() {
        var next = this.clone({
          presence: "optional"
        });
        next.tests = next.tests.filter((test) => test.OPTIONS.name !== "required");
        return next;
      }
      nullable(isNullable = true) {
        var next = this.clone({
          nullable: isNullable !== false
        });
        return next;
      }
      transform(fn) {
        var next = this.clone();
        next.transforms.push(fn);
        return next;
      }
      /**
       * Adds a test function to the schema's queue of tests.
       * tests can be exclusive or non-exclusive.
       *
       * - exclusive tests, will replace any existing tests of the same name.
       * - non-exclusive: can be stacked
       *
       * If a non-exclusive test is added to a schema with an exclusive test of the same name
       * the exclusive test is removed and further tests of the same name will be stacked.
       *
       * If an exclusive test is added to a schema with non-exclusive tests of the same name
       * the previous tests are removed and further tests of the same name will replace each other.
       */
      test(...args) {
        let opts;
        if (args.length === 1) {
          if (typeof args[0] === "function") {
            opts = {
              test: args[0]
            };
          } else {
            opts = args[0];
          }
        } else if (args.length === 2) {
          opts = {
            name: args[0],
            test: args[1]
          };
        } else {
          opts = {
            name: args[0],
            message: args[1],
            test: args[2]
          };
        }
        if (opts.message === void 0)
          opts.message = mixed.default;
        if (typeof opts.test !== "function")
          throw new TypeError("`test` is a required parameters");
        let next = this.clone();
        let validate2 = createValidation(opts);
        let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
        if (opts.exclusive) {
          if (!opts.name)
            throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
        }
        if (opts.name)
          next.exclusiveTests[opts.name] = !!opts.exclusive;
        next.tests = next.tests.filter((fn) => {
          if (fn.OPTIONS.name === opts.name) {
            if (isExclusive)
              return false;
            if (fn.OPTIONS.test === validate2.OPTIONS.test)
              return false;
          }
          return true;
        });
        next.tests.push(validate2);
        return next;
      }
      when(keys, options) {
        if (!Array.isArray(keys) && typeof keys !== "string") {
          options = keys;
          keys = ".";
        }
        let next = this.clone();
        let deps = toArray(keys).map((key) => new Reference(key));
        deps.forEach((dep) => {
          if (dep.isSibling)
            next.deps.push(dep.key);
        });
        next.conditions.push(new Condition_default(deps, options));
        return next;
      }
      typeError(message) {
        var next = this.clone();
        next._typeError = createValidation({
          message,
          name: "typeError",
          test(value) {
            if (value !== void 0 && !this.schema.isType(value))
              return this.createError({
                params: {
                  type: this.schema._type
                }
              });
            return true;
          }
        });
        return next;
      }
      oneOf(enums, message = mixed.oneOf) {
        var next = this.clone();
        enums.forEach((val2) => {
          next._whitelist.add(val2);
          next._blacklist.delete(val2);
        });
        next._whitelistError = createValidation({
          message,
          name: "oneOf",
          test(value) {
            if (value === void 0)
              return true;
            let valids = this.schema._whitelist;
            return valids.has(value, this.resolve) ? true : this.createError({
              params: {
                values: valids.toArray().join(", ")
              }
            });
          }
        });
        return next;
      }
      notOneOf(enums, message = mixed.notOneOf) {
        var next = this.clone();
        enums.forEach((val2) => {
          next._blacklist.add(val2);
          next._whitelist.delete(val2);
        });
        next._blacklistError = createValidation({
          message,
          name: "notOneOf",
          test(value) {
            let invalids = this.schema._blacklist;
            if (invalids.has(value, this.resolve))
              return this.createError({
                params: {
                  values: invalids.toArray().join(", ")
                }
              });
            return true;
          }
        });
        return next;
      }
      strip(strip = true) {
        let next = this.clone();
        next.spec.strip = strip;
        return next;
      }
      describe() {
        const next = this.clone();
        const {
          label,
          meta
        } = next.spec;
        const description = {
          meta,
          label,
          type: next.type,
          oneOf: next._whitelist.describe(),
          notOneOf: next._blacklist.describe(),
          tests: next.tests.map((fn) => ({
            name: fn.OPTIONS.name,
            params: fn.OPTIONS.params
          })).filter((n10, idx, list) => list.findIndex((c10) => c10.name === n10.name) === idx)
        };
        return description;
      }
    };
    BaseSchema.prototype.__isYupSchema__ = true;
    for (const method of ["validate", "validateSync"])
      BaseSchema.prototype[`${method}At`] = function(path, value, options = {}) {
        const {
          parent,
          parentPath,
          schema
        } = getIn(this, path, value, options.context);
        return schema[method](parent && parent[parentPath], _extends3({}, options, {
          parent,
          path
        }));
      };
    for (const alias of ["equals", "is"])
      BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;
    for (const alias of ["not", "nope"])
      BaseSchema.prototype[alias] = BaseSchema.prototype.notOneOf;
    BaseSchema.prototype.optional = BaseSchema.prototype.notRequired;
  }
});

// ../../node_modules/yup/es/mixed.js
function create2() {
  return new Mixed();
}
var Mixed, mixed_default;
var init_mixed = __esm({
  "../../node_modules/yup/es/mixed.js"() {
    "use strict";
    init_schema();
    Mixed = BaseSchema;
    mixed_default = Mixed;
    create2.prototype = Mixed.prototype;
  }
});

// ../../node_modules/yup/es/util/isAbsent.js
var isAbsent_default;
var init_isAbsent = __esm({
  "../../node_modules/yup/es/util/isAbsent.js"() {
    "use strict";
    isAbsent_default = (value) => value == null;
  }
});

// ../../node_modules/yup/es/boolean.js
function create3() {
  return new BooleanSchema();
}
var BooleanSchema;
var init_boolean = __esm({
  "../../node_modules/yup/es/boolean.js"() {
    "use strict";
    init_schema();
    init_locale();
    init_isAbsent();
    BooleanSchema = class extends BaseSchema {
      constructor() {
        super({
          type: "boolean"
        });
        this.withMutation(() => {
          this.transform(function(value) {
            if (!this.isType(value)) {
              if (/^(true|1)$/i.test(String(value)))
                return true;
              if (/^(false|0)$/i.test(String(value)))
                return false;
            }
            return value;
          });
        });
      }
      _typeCheck(v6) {
        if (v6 instanceof Boolean)
          v6 = v6.valueOf();
        return typeof v6 === "boolean";
      }
      isTrue(message = boolean.isValue) {
        return this.test({
          message,
          name: "is-value",
          exclusive: true,
          params: {
            value: "true"
          },
          test(value) {
            return isAbsent_default(value) || value === true;
          }
        });
      }
      isFalse(message = boolean.isValue) {
        return this.test({
          message,
          name: "is-value",
          exclusive: true,
          params: {
            value: "false"
          },
          test(value) {
            return isAbsent_default(value) || value === false;
          }
        });
      }
    };
    create3.prototype = BooleanSchema.prototype;
  }
});

// ../../node_modules/yup/es/string.js
function create4() {
  return new StringSchema();
}
var rEmail, rUrl, rUUID, isTrimmed, objStringTag, StringSchema;
var init_string = __esm({
  "../../node_modules/yup/es/string.js"() {
    "use strict";
    init_locale();
    init_isAbsent();
    init_schema();
    rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
    rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
    rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    isTrimmed = (value) => isAbsent_default(value) || value === value.trim();
    objStringTag = {}.toString();
    StringSchema = class extends BaseSchema {
      constructor() {
        super({
          type: "string"
        });
        this.withMutation(() => {
          this.transform(function(value) {
            if (this.isType(value))
              return value;
            if (Array.isArray(value))
              return value;
            const strValue = value != null && value.toString ? value.toString() : value;
            if (strValue === objStringTag)
              return value;
            return strValue;
          });
        });
      }
      _typeCheck(value) {
        if (value instanceof String)
          value = value.valueOf();
        return typeof value === "string";
      }
      _isPresent(value) {
        return super._isPresent(value) && !!value.length;
      }
      length(length, message = string.length) {
        return this.test({
          message,
          name: "length",
          exclusive: true,
          params: {
            length
          },
          test(value) {
            return isAbsent_default(value) || value.length === this.resolve(length);
          }
        });
      }
      min(min, message = string.min) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          test(value) {
            return isAbsent_default(value) || value.length >= this.resolve(min);
          }
        });
      }
      max(max, message = string.max) {
        return this.test({
          name: "max",
          exclusive: true,
          message,
          params: {
            max
          },
          test(value) {
            return isAbsent_default(value) || value.length <= this.resolve(max);
          }
        });
      }
      matches(regex, options) {
        let excludeEmptyString = false;
        let message;
        let name;
        if (options) {
          if (typeof options === "object") {
            ({
              excludeEmptyString = false,
              message,
              name
            } = options);
          } else {
            message = options;
          }
        }
        return this.test({
          name: name || "matches",
          message: message || string.matches,
          params: {
            regex
          },
          test: (value) => isAbsent_default(value) || value === "" && excludeEmptyString || value.search(regex) !== -1
        });
      }
      email(message = string.email) {
        return this.matches(rEmail, {
          name: "email",
          message,
          excludeEmptyString: true
        });
      }
      url(message = string.url) {
        return this.matches(rUrl, {
          name: "url",
          message,
          excludeEmptyString: true
        });
      }
      uuid(message = string.uuid) {
        return this.matches(rUUID, {
          name: "uuid",
          message,
          excludeEmptyString: false
        });
      }
      //-- transforms --
      ensure() {
        return this.default("").transform((val2) => val2 === null ? "" : val2);
      }
      trim(message = string.trim) {
        return this.transform((val2) => val2 != null ? val2.trim() : val2).test({
          message,
          name: "trim",
          test: isTrimmed
        });
      }
      lowercase(message = string.lowercase) {
        return this.transform((value) => !isAbsent_default(value) ? value.toLowerCase() : value).test({
          message,
          name: "string_case",
          exclusive: true,
          test: (value) => isAbsent_default(value) || value === value.toLowerCase()
        });
      }
      uppercase(message = string.uppercase) {
        return this.transform((value) => !isAbsent_default(value) ? value.toUpperCase() : value).test({
          message,
          name: "string_case",
          exclusive: true,
          test: (value) => isAbsent_default(value) || value === value.toUpperCase()
        });
      }
    };
    create4.prototype = StringSchema.prototype;
  }
});

// ../../node_modules/yup/es/number.js
function create5() {
  return new NumberSchema();
}
var isNaN2, NumberSchema;
var init_number = __esm({
  "../../node_modules/yup/es/number.js"() {
    "use strict";
    init_locale();
    init_isAbsent();
    init_schema();
    isNaN2 = (value) => value != +value;
    NumberSchema = class extends BaseSchema {
      constructor() {
        super({
          type: "number"
        });
        this.withMutation(() => {
          this.transform(function(value) {
            let parsed = value;
            if (typeof parsed === "string") {
              parsed = parsed.replace(/\s/g, "");
              if (parsed === "")
                return NaN;
              parsed = +parsed;
            }
            if (this.isType(parsed))
              return parsed;
            return parseFloat(parsed);
          });
        });
      }
      _typeCheck(value) {
        if (value instanceof Number)
          value = value.valueOf();
        return typeof value === "number" && !isNaN2(value);
      }
      min(min, message = number.min) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          test(value) {
            return isAbsent_default(value) || value >= this.resolve(min);
          }
        });
      }
      max(max, message = number.max) {
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          test(value) {
            return isAbsent_default(value) || value <= this.resolve(max);
          }
        });
      }
      lessThan(less, message = number.lessThan) {
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            less
          },
          test(value) {
            return isAbsent_default(value) || value < this.resolve(less);
          }
        });
      }
      moreThan(more, message = number.moreThan) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            more
          },
          test(value) {
            return isAbsent_default(value) || value > this.resolve(more);
          }
        });
      }
      positive(msg = number.positive) {
        return this.moreThan(0, msg);
      }
      negative(msg = number.negative) {
        return this.lessThan(0, msg);
      }
      integer(message = number.integer) {
        return this.test({
          name: "integer",
          message,
          test: (val2) => isAbsent_default(val2) || Number.isInteger(val2)
        });
      }
      truncate() {
        return this.transform((value) => !isAbsent_default(value) ? value | 0 : value);
      }
      round(method) {
        var _method;
        var avail = ["ceil", "floor", "round", "trunc"];
        method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
        if (method === "trunc")
          return this.truncate();
        if (avail.indexOf(method.toLowerCase()) === -1)
          throw new TypeError("Only valid options for round() are: " + avail.join(", "));
        return this.transform((value) => !isAbsent_default(value) ? Math[method](value) : value);
      }
    };
    create5.prototype = NumberSchema.prototype;
  }
});

// ../../node_modules/yup/es/util/isodate.js
function parseIsoDate(date2) {
  var numericKeys = [1, 4, 5, 6, 7, 10, 11], minutesOffset = 0, timestamp, struct;
  if (struct = isoReg.exec(date2)) {
    for (var i10 = 0, k10; k10 = numericKeys[i10]; ++i10)
      struct[k10] = +struct[k10] || 0;
    struct[2] = (+struct[2] || 1) - 1;
    struct[3] = +struct[3] || 1;
    struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0;
    if ((struct[8] === void 0 || struct[8] === "") && (struct[9] === void 0 || struct[9] === ""))
      timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
    else {
      if (struct[8] !== "Z" && struct[9] !== void 0) {
        minutesOffset = struct[10] * 60 + struct[11];
        if (struct[9] === "+")
          minutesOffset = 0 - minutesOffset;
      }
      timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
    }
  } else
    timestamp = Date.parse ? Date.parse(date2) : NaN;
  return timestamp;
}
var isoReg;
var init_isodate = __esm({
  "../../node_modules/yup/es/util/isodate.js"() {
    "use strict";
    isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
  }
});

// ../../node_modules/yup/es/date.js
function create6() {
  return new DateSchema();
}
var invalidDate, isDate, DateSchema;
var init_date = __esm({
  "../../node_modules/yup/es/date.js"() {
    "use strict";
    init_isodate();
    init_locale();
    init_isAbsent();
    init_Reference();
    init_schema();
    invalidDate = /* @__PURE__ */ new Date("");
    isDate = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
    DateSchema = class extends BaseSchema {
      constructor() {
        super({
          type: "date"
        });
        this.withMutation(() => {
          this.transform(function(value) {
            if (this.isType(value))
              return value;
            value = parseIsoDate(value);
            return !isNaN(value) ? new Date(value) : invalidDate;
          });
        });
      }
      _typeCheck(v6) {
        return isDate(v6) && !isNaN(v6.getTime());
      }
      prepareParam(ref, name) {
        let param;
        if (!Reference.isRef(ref)) {
          let cast = this.cast(ref);
          if (!this._typeCheck(cast))
            throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
          param = cast;
        } else {
          param = ref;
        }
        return param;
      }
      min(min, message = date.min) {
        let limit = this.prepareParam(min, "min");
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          test(value) {
            return isAbsent_default(value) || value >= this.resolve(limit);
          }
        });
      }
      max(max, message = date.max) {
        var limit = this.prepareParam(max, "max");
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          test(value) {
            return isAbsent_default(value) || value <= this.resolve(limit);
          }
        });
      }
    };
    DateSchema.INVALID_DATE = invalidDate;
    create6.prototype = DateSchema.prototype;
    create6.INVALID_DATE = invalidDate;
  }
});

// ../../node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "../../node_modules/lodash/_arrayReduce.js"(exports, module2) {
    "use strict";
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array2[index], index, array2);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// ../../node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "../../node_modules/lodash/_basePropertyOf.js"(exports, module2) {
    "use strict";
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    module2.exports = basePropertyOf;
  }
});

// ../../node_modules/lodash/_deburrLetter.js
var require_deburrLetter = __commonJS({
  "../../node_modules/lodash/_deburrLetter.js"(exports, module2) {
    "use strict";
    var basePropertyOf = require_basePropertyOf();
    var deburredLetters = {
      // Latin-1 Supplement block.
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      // Latin Extended-A block.
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    module2.exports = deburrLetter;
  }
});

// ../../node_modules/lodash/deburr.js
var require_deburr = __commonJS({
  "../../node_modules/lodash/deburr.js"(exports, module2) {
    "use strict";
    var deburrLetter = require_deburrLetter();
    var toString2 = require_toString();
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsCombo = "[" + rsComboRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    function deburr(string2) {
      string2 = toString2(string2);
      return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module2.exports = deburr;
  }
});

// ../../node_modules/lodash/_asciiWords.js
var require_asciiWords = __commonJS({
  "../../node_modules/lodash/_asciiWords.js"(exports, module2) {
    "use strict";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    module2.exports = asciiWords;
  }
});

// ../../node_modules/lodash/_hasUnicodeWord.js
var require_hasUnicodeWord = __commonJS({
  "../../node_modules/lodash/_hasUnicodeWord.js"(exports, module2) {
    "use strict";
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    module2.exports = hasUnicodeWord;
  }
});

// ../../node_modules/lodash/_unicodeWords.js
var require_unicodeWords = __commonJS({
  "../../node_modules/lodash/_unicodeWords.js"(exports, module2) {
    "use strict";
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    module2.exports = unicodeWords;
  }
});

// ../../node_modules/lodash/words.js
var require_words = __commonJS({
  "../../node_modules/lodash/words.js"(exports, module2) {
    "use strict";
    var asciiWords = require_asciiWords();
    var hasUnicodeWord = require_hasUnicodeWord();
    var toString2 = require_toString();
    var unicodeWords = require_unicodeWords();
    function words(string2, pattern, guard) {
      string2 = toString2(string2);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
      }
      return string2.match(pattern) || [];
    }
    module2.exports = words;
  }
});

// ../../node_modules/lodash/_createCompounder.js
var require_createCompounder = __commonJS({
  "../../node_modules/lodash/_createCompounder.js"(exports, module2) {
    "use strict";
    var arrayReduce = require_arrayReduce();
    var deburr = require_deburr();
    var words = require_words();
    var rsApos = "['\u2019]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string2) {
        return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
      };
    }
    module2.exports = createCompounder;
  }
});

// ../../node_modules/lodash/snakeCase.js
var require_snakeCase = __commonJS({
  "../../node_modules/lodash/snakeCase.js"(exports, module2) {
    "use strict";
    var createCompounder = require_createCompounder();
    var snakeCase2 = createCompounder(function(result, word, index) {
      return result + (index ? "_" : "") + word.toLowerCase();
    });
    module2.exports = snakeCase2;
  }
});

// ../../node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "../../node_modules/lodash/_baseSlice.js"(exports, module2) {
    "use strict";
    function baseSlice(array2, start, end) {
      var index = -1, length = array2.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array2[index + start];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// ../../node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "../../node_modules/lodash/_castSlice.js"(exports, module2) {
    "use strict";
    var baseSlice = require_baseSlice();
    function castSlice(array2, start, end) {
      var length = array2.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array2 : baseSlice(array2, start, end);
    }
    module2.exports = castSlice;
  }
});

// ../../node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "../../node_modules/lodash/_hasUnicode.js"(exports, module2) {
    "use strict";
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    module2.exports = hasUnicode;
  }
});

// ../../node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "../../node_modules/lodash/_asciiToArray.js"(exports, module2) {
    "use strict";
    function asciiToArray(string2) {
      return string2.split("");
    }
    module2.exports = asciiToArray;
  }
});

// ../../node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "../../node_modules/lodash/_unicodeToArray.js"(exports, module2) {
    "use strict";
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// ../../node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "../../node_modules/lodash/_stringToArray.js"(exports, module2) {
    "use strict";
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    module2.exports = stringToArray;
  }
});

// ../../node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "../../node_modules/lodash/_createCaseFirst.js"(exports, module2) {
    "use strict";
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString2 = require_toString();
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString2(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  }
});

// ../../node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "../../node_modules/lodash/upperFirst.js"(exports, module2) {
    "use strict";
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  }
});

// ../../node_modules/lodash/capitalize.js
var require_capitalize = __commonJS({
  "../../node_modules/lodash/capitalize.js"(exports, module2) {
    "use strict";
    var toString2 = require_toString();
    var upperFirst = require_upperFirst();
    function capitalize(string2) {
      return upperFirst(toString2(string2).toLowerCase());
    }
    module2.exports = capitalize;
  }
});

// ../../node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "../../node_modules/lodash/camelCase.js"(exports, module2) {
    "use strict";
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase2 = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    module2.exports = camelCase2;
  }
});

// ../../node_modules/lodash/mapKeys.js
var require_mapKeys = __commonJS({
  "../../node_modules/lodash/mapKeys.js"(exports, module2) {
    "use strict";
    var baseAssignValue = require_baseAssignValue();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    function mapKeys2(object2, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);
      baseForOwn(object2, function(value, key, object3) {
        baseAssignValue(result, iteratee(value, key, object3), value);
      });
      return result;
    }
    module2.exports = mapKeys2;
  }
});

// ../../node_modules/toposort/index.js
var require_toposort = __commonJS({
  "../../node_modules/toposort/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(edges) {
      return toposort2(uniqueNodes(edges), edges);
    };
    module2.exports.array = toposort2;
    function toposort2(nodes, edges) {
      var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i10 = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
      edges.forEach(function(edge) {
        if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
          throw new Error("Unknown node. There is an unknown node in the supplied edges.");
        }
      });
      while (i10--) {
        if (!visited[i10])
          visit(nodes[i10], i10, /* @__PURE__ */ new Set());
      }
      return sorted;
      function visit(node, i11, predecessors) {
        if (predecessors.has(node)) {
          var nodeRep;
          try {
            nodeRep = ", node was:" + JSON.stringify(node);
          } catch (e10) {
            nodeRep = "";
          }
          throw new Error("Cyclic dependency" + nodeRep);
        }
        if (!nodesHash.has(node)) {
          throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
        }
        if (visited[i11])
          return;
        visited[i11] = true;
        var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
        outgoing = Array.from(outgoing);
        if (i11 = outgoing.length) {
          predecessors.add(node);
          do {
            var child = outgoing[--i11];
            visit(child, nodesHash.get(child), predecessors);
          } while (i11);
          predecessors.delete(node);
        }
        sorted[--cursor] = node;
      }
    }
    function uniqueNodes(arr) {
      var res = /* @__PURE__ */ new Set();
      for (var i10 = 0, len = arr.length; i10 < len; i10++) {
        var edge = arr[i10];
        res.add(edge[0]);
        res.add(edge[1]);
      }
      return Array.from(res);
    }
    function makeOutgoingEdges(arr) {
      var edges = /* @__PURE__ */ new Map();
      for (var i10 = 0, len = arr.length; i10 < len; i10++) {
        var edge = arr[i10];
        if (!edges.has(edge[0]))
          edges.set(edge[0], /* @__PURE__ */ new Set());
        if (!edges.has(edge[1]))
          edges.set(edge[1], /* @__PURE__ */ new Set());
        edges.get(edge[0]).add(edge[1]);
      }
      return edges;
    }
    function makeNodesHash(arr) {
      var res = /* @__PURE__ */ new Map();
      for (var i10 = 0, len = arr.length; i10 < len; i10++) {
        res.set(arr[i10], i10);
      }
      return res;
    }
  }
});

// ../../node_modules/yup/es/util/sortFields.js
function sortFields(fields, excludes = []) {
  let edges = [];
  let nodes = [];
  function addNode(depPath, key) {
    var node = (0, import_property_expr3.split)(depPath)[0];
    if (!~nodes.indexOf(node))
      nodes.push(node);
    if (!~excludes.indexOf(`${key}-${node}`))
      edges.push([key, node]);
  }
  for (const key in fields)
    if ((0, import_has2.default)(fields, key)) {
      let value = fields[key];
      if (!~nodes.indexOf(key))
        nodes.push(key);
      if (Reference.isRef(value) && value.isSibling)
        addNode(value.path, key);
      else if (isSchema_default(value) && "deps" in value)
        value.deps.forEach((path) => addNode(path, key));
    }
  return import_toposort.default.array(nodes, edges).reverse();
}
var import_has2, import_toposort, import_property_expr3;
var init_sortFields = __esm({
  "../../node_modules/yup/es/util/sortFields.js"() {
    "use strict";
    import_has2 = __toESM(require_has());
    import_toposort = __toESM(require_toposort());
    import_property_expr3 = __toESM(require_property_expr());
    init_Reference();
    init_isSchema();
  }
});

// ../../node_modules/yup/es/util/sortByKeyOrder.js
function findIndex(arr, err) {
  let idx = Infinity;
  arr.some((key, ii) => {
    var _err$path;
    if (((_err$path = err.path) == null ? void 0 : _err$path.indexOf(key)) !== -1) {
      idx = ii;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys) {
  return (a10, b10) => {
    return findIndex(keys, a10) - findIndex(keys, b10);
  };
}
var init_sortByKeyOrder = __esm({
  "../../node_modules/yup/es/util/sortByKeyOrder.js"() {
    "use strict";
  }
});

// ../../node_modules/yup/es/object.js
function _extends4() {
  _extends4 = Object.assign || function(target) {
    for (var i10 = 1; i10 < arguments.length; i10++) {
      var source = arguments[i10];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
function unknown(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter((key) => known.indexOf(key) === -1);
}
function create7(spec) {
  return new ObjectSchema(spec);
}
var import_has3, import_snakeCase, import_camelCase, import_mapKeys, import_mapValues2, import_property_expr4, isObject, defaultSort, ObjectSchema;
var init_object = __esm({
  "../../node_modules/yup/es/object.js"() {
    "use strict";
    import_has3 = __toESM(require_has());
    import_snakeCase = __toESM(require_snakeCase());
    import_camelCase = __toESM(require_camelCase());
    import_mapKeys = __toESM(require_mapKeys());
    import_mapValues2 = __toESM(require_mapValues());
    import_property_expr4 = __toESM(require_property_expr());
    init_locale();
    init_sortFields();
    init_sortByKeyOrder();
    init_runTests();
    init_ValidationError();
    init_schema();
    isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
    defaultSort = sortByKeyOrder([]);
    ObjectSchema = class extends BaseSchema {
      constructor(spec) {
        super({
          type: "object"
        });
        this.fields = /* @__PURE__ */ Object.create(null);
        this._sortErrors = defaultSort;
        this._nodes = [];
        this._excludedEdges = [];
        this.withMutation(() => {
          this.transform(function coerce(value) {
            if (typeof value === "string") {
              try {
                value = JSON.parse(value);
              } catch (err) {
                value = null;
              }
            }
            if (this.isType(value))
              return value;
            return null;
          });
          if (spec) {
            this.shape(spec);
          }
        });
      }
      _typeCheck(value) {
        return isObject(value) || typeof value === "function";
      }
      _cast(_value, options = {}) {
        var _options$stripUnknown;
        let value = super._cast(_value, options);
        if (value === void 0)
          return this.getDefault();
        if (!this._typeCheck(value))
          return value;
        let fields = this.fields;
        let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
        let props = this._nodes.concat(Object.keys(value).filter((v6) => this._nodes.indexOf(v6) === -1));
        let intermediateValue = {};
        let innerOptions = _extends4({}, options, {
          parent: intermediateValue,
          __validating: options.__validating || false
        });
        let isChanged = false;
        for (const prop of props) {
          let field = fields[prop];
          let exists = (0, import_has3.default)(value, prop);
          if (field) {
            let fieldValue;
            let inputValue = value[prop];
            innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
            field = field.resolve({
              value: inputValue,
              context: options.context,
              parent: intermediateValue
            });
            let fieldSpec = "spec" in field ? field.spec : void 0;
            let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
            if (fieldSpec == null ? void 0 : fieldSpec.strip) {
              isChanged = isChanged || prop in value;
              continue;
            }
            fieldValue = !options.__validating || !strict ? (
              // TODO: use _cast, this is double resolving
              field.cast(value[prop], innerOptions)
            ) : value[prop];
            if (fieldValue !== void 0) {
              intermediateValue[prop] = fieldValue;
            }
          } else if (exists && !strip) {
            intermediateValue[prop] = value[prop];
          }
          if (intermediateValue[prop] !== value[prop]) {
            isChanged = true;
          }
        }
        return isChanged ? intermediateValue : value;
      }
      _validate(_value, opts = {}, callback) {
        let errors = [];
        let {
          sync,
          from = [],
          originalValue = _value,
          abortEarly = this.spec.abortEarly,
          recursive = this.spec.recursive
        } = opts;
        from = [{
          schema: this,
          value: originalValue
        }, ...from];
        opts.__validating = true;
        opts.originalValue = originalValue;
        opts.from = from;
        super._validate(_value, opts, (err, value) => {
          if (err) {
            if (!ValidationError.isError(err) || abortEarly) {
              return void callback(err, value);
            }
            errors.push(err);
          }
          if (!recursive || !isObject(value)) {
            callback(errors[0] || null, value);
            return;
          }
          originalValue = originalValue || value;
          let tests = this._nodes.map((key) => (_, cb) => {
            let path = key.indexOf(".") === -1 ? (opts.path ? `${opts.path}.` : "") + key : `${opts.path || ""}["${key}"]`;
            let field = this.fields[key];
            if (field && "validate" in field) {
              field.validate(value[key], _extends4({}, opts, {
                // @ts-ignore
                path,
                from,
                // inner fields are always strict:
                // 1. this isn't strict so the casting will also have cast inner values
                // 2. this is strict in which case the nested values weren't cast either
                strict: true,
                parent: value,
                originalValue: originalValue[key]
              }), cb);
              return;
            }
            cb(null);
          });
          runTests({
            sync,
            tests,
            value,
            errors,
            endEarly: abortEarly,
            sort: this._sortErrors,
            path: opts.path
          }, callback);
        });
      }
      clone(spec) {
        const next = super.clone(spec);
        next.fields = _extends4({}, this.fields);
        next._nodes = this._nodes;
        next._excludedEdges = this._excludedEdges;
        next._sortErrors = this._sortErrors;
        return next;
      }
      concat(schema) {
        let next = super.concat(schema);
        let nextFields = next.fields;
        for (let [field, schemaOrRef] of Object.entries(this.fields)) {
          const target = nextFields[field];
          if (target === void 0) {
            nextFields[field] = schemaOrRef;
          } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {
            nextFields[field] = schemaOrRef.concat(target);
          }
        }
        return next.withMutation(() => next.shape(nextFields));
      }
      getDefaultFromShape() {
        let dft = {};
        this._nodes.forEach((key) => {
          const field = this.fields[key];
          dft[key] = "default" in field ? field.getDefault() : void 0;
        });
        return dft;
      }
      _getDefault() {
        if ("default" in this.spec) {
          return super._getDefault();
        }
        if (!this._nodes.length) {
          return void 0;
        }
        return this.getDefaultFromShape();
      }
      shape(additions, excludes = []) {
        let next = this.clone();
        let fields = Object.assign(next.fields, additions);
        next.fields = fields;
        next._sortErrors = sortByKeyOrder(Object.keys(fields));
        if (excludes.length) {
          if (!Array.isArray(excludes[0]))
            excludes = [excludes];
          let keys = excludes.map(([first, second]) => `${first}-${second}`);
          next._excludedEdges = next._excludedEdges.concat(keys);
        }
        next._nodes = sortFields(fields, next._excludedEdges);
        return next;
      }
      pick(keys) {
        const picked = {};
        for (const key of keys) {
          if (this.fields[key])
            picked[key] = this.fields[key];
        }
        return this.clone().withMutation((next) => {
          next.fields = {};
          return next.shape(picked);
        });
      }
      omit(keys) {
        const next = this.clone();
        const fields = next.fields;
        next.fields = {};
        for (const key of keys) {
          delete fields[key];
        }
        return next.withMutation(() => next.shape(fields));
      }
      from(from, to, alias) {
        let fromGetter = (0, import_property_expr4.getter)(from, true);
        return this.transform((obj) => {
          if (obj == null)
            return obj;
          let newObj = obj;
          if ((0, import_has3.default)(obj, from)) {
            newObj = _extends4({}, obj);
            if (!alias)
              delete newObj[from];
            newObj[to] = fromGetter(obj);
          }
          return newObj;
        });
      }
      noUnknown(noAllow = true, message = object.noUnknown) {
        if (typeof noAllow === "string") {
          message = noAllow;
          noAllow = true;
        }
        let next = this.test({
          name: "noUnknown",
          exclusive: true,
          message,
          test(value) {
            if (value == null)
              return true;
            const unknownKeys = unknown(this.schema, value);
            return !noAllow || unknownKeys.length === 0 || this.createError({
              params: {
                unknown: unknownKeys.join(", ")
              }
            });
          }
        });
        next.spec.noUnknown = noAllow;
        return next;
      }
      unknown(allow = true, message = object.noUnknown) {
        return this.noUnknown(!allow, message);
      }
      transformKeys(fn) {
        return this.transform((obj) => obj && (0, import_mapKeys.default)(obj, (_, key) => fn(key)));
      }
      camelCase() {
        return this.transformKeys(import_camelCase.default);
      }
      snakeCase() {
        return this.transformKeys(import_snakeCase.default);
      }
      constantCase() {
        return this.transformKeys((key) => (0, import_snakeCase.default)(key).toUpperCase());
      }
      describe() {
        let base = super.describe();
        base.fields = (0, import_mapValues2.default)(this.fields, (value) => value.describe());
        return base;
      }
    };
    create7.prototype = ObjectSchema.prototype;
  }
});

// ../../node_modules/yup/es/array.js
function _extends5() {
  _extends5 = Object.assign || function(target) {
    for (var i10 = 1; i10 < arguments.length; i10++) {
      var source = arguments[i10];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}
function create8(type) {
  return new ArraySchema(type);
}
var ArraySchema;
var init_array = __esm({
  "../../node_modules/yup/es/array.js"() {
    "use strict";
    init_isAbsent();
    init_isSchema();
    init_printValue();
    init_locale();
    init_runTests();
    init_ValidationError();
    init_schema();
    ArraySchema = class extends BaseSchema {
      constructor(type) {
        super({
          type: "array"
        });
        this.innerType = type;
        this.withMutation(() => {
          this.transform(function(values) {
            if (typeof values === "string")
              try {
                values = JSON.parse(values);
              } catch (err) {
                values = null;
              }
            return this.isType(values) ? values : null;
          });
        });
      }
      _typeCheck(v6) {
        return Array.isArray(v6);
      }
      get _subType() {
        return this.innerType;
      }
      _cast(_value, _opts) {
        const value = super._cast(_value, _opts);
        if (!this._typeCheck(value) || !this.innerType)
          return value;
        let isChanged = false;
        const castArray = value.map((v6, idx) => {
          const castElement = this.innerType.cast(v6, _extends5({}, _opts, {
            path: `${_opts.path || ""}[${idx}]`
          }));
          if (castElement !== v6) {
            isChanged = true;
          }
          return castElement;
        });
        return isChanged ? castArray : value;
      }
      _validate(_value, options = {}, callback) {
        var _options$abortEarly, _options$recursive;
        let errors = [];
        let sync = options.sync;
        let path = options.path;
        let innerType = this.innerType;
        let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;
        let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
        let originalValue = options.originalValue != null ? options.originalValue : _value;
        super._validate(_value, options, (err, value) => {
          if (err) {
            if (!ValidationError.isError(err) || endEarly) {
              return void callback(err, value);
            }
            errors.push(err);
          }
          if (!recursive || !innerType || !this._typeCheck(value)) {
            callback(errors[0] || null, value);
            return;
          }
          originalValue = originalValue || value;
          let tests = new Array(value.length);
          for (let idx = 0; idx < value.length; idx++) {
            let item = value[idx];
            let path2 = `${options.path || ""}[${idx}]`;
            let innerOptions = _extends5({}, options, {
              path: path2,
              strict: true,
              parent: value,
              index: idx,
              originalValue: originalValue[idx]
            });
            tests[idx] = (_, cb) => innerType.validate(item, innerOptions, cb);
          }
          runTests({
            sync,
            path,
            value,
            errors,
            endEarly,
            tests
          }, callback);
        });
      }
      clone(spec) {
        const next = super.clone(spec);
        next.innerType = this.innerType;
        return next;
      }
      concat(schema) {
        let next = super.concat(schema);
        next.innerType = this.innerType;
        if (schema.innerType)
          next.innerType = next.innerType ? (
            // @ts-expect-error Lazy doesn't have concat()
            next.innerType.concat(schema.innerType)
          ) : schema.innerType;
        return next;
      }
      of(schema) {
        let next = this.clone();
        if (!isSchema_default(schema))
          throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
        next.innerType = schema;
        return next;
      }
      length(length, message = array.length) {
        return this.test({
          message,
          name: "length",
          exclusive: true,
          params: {
            length
          },
          test(value) {
            return isAbsent_default(value) || value.length === this.resolve(length);
          }
        });
      }
      min(min, message) {
        message = message || array.min;
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          // FIXME(ts): Array<typeof T>
          test(value) {
            return isAbsent_default(value) || value.length >= this.resolve(min);
          }
        });
      }
      max(max, message) {
        message = message || array.max;
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          test(value) {
            return isAbsent_default(value) || value.length <= this.resolve(max);
          }
        });
      }
      ensure() {
        return this.default(() => []).transform((val2, original) => {
          if (this._typeCheck(val2))
            return val2;
          return original == null ? [] : [].concat(original);
        });
      }
      compact(rejector) {
        let reject = !rejector ? (v6) => !!v6 : (v6, i10, a10) => !rejector(v6, i10, a10);
        return this.transform((values) => values != null ? values.filter(reject) : values);
      }
      describe() {
        let base = super.describe();
        if (this.innerType)
          base.innerType = this.innerType.describe();
        return base;
      }
      nullable(isNullable = true) {
        return super.nullable(isNullable);
      }
      defined() {
        return super.defined();
      }
      required(msg) {
        return super.required(msg);
      }
    };
    create8.prototype = ArraySchema.prototype;
  }
});

// ../../node_modules/yup/es/Lazy.js
function create9(builder) {
  return new Lazy(builder);
}
var Lazy;
var init_Lazy = __esm({
  "../../node_modules/yup/es/Lazy.js"() {
    "use strict";
    init_isSchema();
    Lazy = class {
      constructor(builder) {
        this.type = "lazy";
        this.__isYupSchema__ = true;
        this._resolve = (value, options = {}) => {
          let schema = this.builder(value, options);
          if (!isSchema_default(schema))
            throw new TypeError("lazy() functions must return a valid schema");
          return schema.resolve(options);
        };
        this.builder = builder;
      }
      resolve(options) {
        return this._resolve(options.value, options);
      }
      cast(value, options) {
        return this._resolve(value, options).cast(value, options);
      }
      validate(value, options, maybeCb) {
        return this._resolve(value, options).validate(value, options, maybeCb);
      }
      validateSync(value, options) {
        return this._resolve(value, options).validateSync(value, options);
      }
      validateAt(path, value, options) {
        return this._resolve(value, options).validateAt(path, value, options);
      }
      validateSyncAt(path, value, options) {
        return this._resolve(value, options).validateSyncAt(path, value, options);
      }
      describe() {
        return null;
      }
      isValid(value, options) {
        return this._resolve(value, options).isValid(value, options);
      }
      isValidSync(value, options) {
        return this._resolve(value, options).isValidSync(value, options);
      }
    };
  }
});

// ../../node_modules/yup/es/setLocale.js
function setLocale(custom) {
  Object.keys(custom).forEach((type) => {
    Object.keys(custom[type]).forEach((method) => {
      locale_default[type][method] = custom[type][method];
    });
  });
}
var init_setLocale = __esm({
  "../../node_modules/yup/es/setLocale.js"() {
    "use strict";
    init_locale();
  }
});

// ../../node_modules/yup/es/index.js
var es_exports = {};
__export(es_exports, {
  ArraySchema: () => ArraySchema,
  BaseSchema: () => BaseSchema,
  BooleanSchema: () => BooleanSchema,
  DateSchema: () => DateSchema,
  MixedSchema: () => mixed_default,
  NumberSchema: () => NumberSchema,
  ObjectSchema: () => ObjectSchema,
  StringSchema: () => StringSchema,
  ValidationError: () => ValidationError,
  addMethod: () => addMethod,
  array: () => create8,
  bool: () => create3,
  boolean: () => create3,
  date: () => create6,
  isSchema: () => isSchema_default,
  lazy: () => create9,
  mixed: () => create2,
  number: () => create5,
  object: () => create7,
  reach: () => reach_default,
  ref: () => create,
  setLocale: () => setLocale,
  string: () => create4
});
function addMethod(schemaType, name, fn) {
  if (!schemaType || !isSchema_default(schemaType.prototype))
    throw new TypeError("You must provide a yup schema constructor function");
  if (typeof name !== "string")
    throw new TypeError("A Method name must be provided");
  if (typeof fn !== "function")
    throw new TypeError("Method function must be provided");
  schemaType.prototype[name] = fn;
}
var init_es = __esm({
  "../../node_modules/yup/es/index.js"() {
    "use strict";
    init_mixed();
    init_boolean();
    init_string();
    init_number();
    init_date();
    init_object();
    init_array();
    init_Reference();
    init_Lazy();
    init_ValidationError();
    init_reach();
    init_isSchema();
    init_setLocale();
    init_schema();
  }
});

// ../../node_modules/cron-validate/lib/presets.js
var require_presets = __commonJS({
  "../../node_modules/cron-validate/lib/presets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var option_1 = require_option();
    exports.default = () => {
      (0, option_1.registerOptionPreset)("npm-node-cron", {
        // https://github.com/kelektiv/node-cron
        presetId: "npm-node-cron",
        useSeconds: true,
        useYears: false,
        useAliases: true,
        useBlankDay: false,
        allowOnlyOneBlankDayField: false,
        mustHaveBlankDayField: false,
        useLastDayOfMonth: false,
        useLastDayOfWeek: false,
        useNearestWeekday: false,
        useNthWeekdayOfMonth: false,
        seconds: {
          minValue: 0,
          maxValue: 59
        },
        minutes: {
          minValue: 0,
          maxValue: 59
        },
        hours: {
          minValue: 0,
          maxValue: 23
        },
        daysOfMonth: {
          minValue: 1,
          maxValue: 31
        },
        months: {
          minValue: 0,
          maxValue: 11
        },
        daysOfWeek: {
          minValue: 0,
          maxValue: 6
        },
        years: {
          minValue: 1970,
          maxValue: 2099
        }
      });
      (0, option_1.registerOptionPreset)("aws-cloud-watch", {
        // https://docs.aws.amazon.com/de_de/AmazonCloudWatch/latest/events/ScheduledEvents.html
        presetId: "aws-cloud-watch",
        useSeconds: false,
        useYears: true,
        useAliases: true,
        useBlankDay: true,
        allowOnlyOneBlankDayField: true,
        mustHaveBlankDayField: true,
        useLastDayOfMonth: true,
        useLastDayOfWeek: true,
        useNearestWeekday: true,
        useNthWeekdayOfMonth: true,
        seconds: {
          minValue: 0,
          maxValue: 59
        },
        minutes: {
          minValue: 0,
          maxValue: 59
        },
        hours: {
          minValue: 0,
          maxValue: 23
        },
        daysOfMonth: {
          minValue: 1,
          maxValue: 31
        },
        months: {
          minValue: 1,
          maxValue: 12
        },
        daysOfWeek: {
          minValue: 1,
          maxValue: 7
        },
        years: {
          minValue: 1970,
          maxValue: 2199
        }
      });
      (0, option_1.registerOptionPreset)("npm-cron-schedule", {
        // https://github.com/P4sca1/cron-schedule
        presetId: "npm-cron-schedule",
        useSeconds: true,
        useYears: false,
        useAliases: true,
        useBlankDay: false,
        allowOnlyOneBlankDayField: false,
        mustHaveBlankDayField: false,
        useLastDayOfMonth: false,
        useLastDayOfWeek: false,
        useNearestWeekday: false,
        useNthWeekdayOfMonth: false,
        seconds: {
          minValue: 0,
          maxValue: 59
        },
        minutes: {
          minValue: 0,
          maxValue: 59
        },
        hours: {
          minValue: 0,
          maxValue: 23
        },
        daysOfMonth: {
          minValue: 1,
          maxValue: 31
        },
        months: {
          minValue: 1,
          maxValue: 12
        },
        daysOfWeek: {
          minValue: 0,
          maxValue: 7
        },
        years: {
          minValue: 1970,
          maxValue: 2099
        }
      });
    };
  }
});

// ../../node_modules/cron-validate/lib/option.js
var require_option = __commonJS({
  "../../node_modules/cron-validate/lib/option.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m10, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc = Object.getOwnPropertyDescriptor(m10, k10);
      if (!desc || ("get" in desc ? !m10.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m10[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc);
    } : function(o10, m10, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m10[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v6) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v6 });
    } : function(o10, v6) {
      o10["default"] = v6;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding2(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateOptions = exports.registerOptionPreset = exports.getOptionPresets = exports.getOptionPreset = void 0;
    var yup = __importStar2((init_es(), __toCommonJS(es_exports)));
    init_es();
    var result_1 = require_result();
    var presets_1 = __importDefault2(require_presets());
    require_types();
    var optionPresets = {
      // http://crontab.org/
      default: {
        presetId: "default",
        useSeconds: false,
        useYears: false,
        useAliases: false,
        useBlankDay: false,
        allowOnlyOneBlankDayField: false,
        mustHaveBlankDayField: false,
        useLastDayOfMonth: false,
        useLastDayOfWeek: false,
        useNearestWeekday: false,
        useNthWeekdayOfMonth: false,
        seconds: {
          minValue: 0,
          maxValue: 59
        },
        minutes: {
          minValue: 0,
          maxValue: 59
        },
        hours: {
          minValue: 0,
          maxValue: 23
        },
        daysOfMonth: {
          minValue: 0,
          maxValue: 31
        },
        months: {
          minValue: 0,
          maxValue: 12
        },
        daysOfWeek: {
          minValue: 0,
          maxValue: 7
        },
        years: {
          minValue: 1970,
          maxValue: 2099
        }
      }
    };
    var optionPresetSchema = yup.object({
      presetId: yup.string().required(),
      useSeconds: yup.boolean().required(),
      useYears: yup.boolean().required(),
      useAliases: yup.boolean(),
      useBlankDay: yup.boolean().required(),
      allowOnlyOneBlankDayField: yup.boolean().required(),
      mustHaveBlankDayField: yup.boolean(),
      useLastDayOfMonth: yup.boolean(),
      useLastDayOfWeek: yup.boolean(),
      useNearestWeekday: yup.boolean(),
      useNthWeekdayOfMonth: yup.boolean(),
      seconds: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      minutes: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      hours: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      daysOfMonth: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      months: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      daysOfWeek: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required(),
      years: yup.object({
        minValue: yup.number().min(0).required(),
        maxValue: yup.number().min(0).required(),
        lowerLimit: yup.number().min(0),
        upperLimit: yup.number().min(0)
      }).required()
    }).required();
    var getOptionPreset = (presetId) => {
      if (optionPresets[presetId]) {
        return (0, result_1.valid)(optionPresets[presetId]);
      }
      return (0, result_1.err)(`Option preset '${presetId}' not found.`);
    };
    exports.getOptionPreset = getOptionPreset;
    var getOptionPresets = () => optionPresets;
    exports.getOptionPresets = getOptionPresets;
    var registerOptionPreset = (presetName, preset) => {
      optionPresets[presetName] = optionPresetSchema.validateSync(preset, {
        strict: false,
        abortEarly: false,
        stripUnknown: true,
        recursive: true
      });
    };
    exports.registerOptionPreset = registerOptionPreset;
    var validateOptions = (inputOptions) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
      try {
        (0, presets_1.default)();
        let preset;
        if (inputOptions.preset) {
          if (typeof inputOptions.preset === "string") {
            if (!optionPresets[inputOptions.preset]) {
              return (0, result_1.err)([`Option preset ${inputOptions.preset} does not exist.`]);
            }
            preset = optionPresets[inputOptions.preset];
          } else {
            preset = inputOptions.preset;
          }
        } else {
          preset = optionPresets.default;
        }
        const unvalidatedConfig = Object.assign(Object.assign({ presetId: preset.presetId, preset }, {
          useSeconds: preset.useSeconds,
          useYears: preset.useYears,
          useAliases: (_a = preset.useAliases) !== null && _a !== void 0 ? _a : false,
          useBlankDay: preset.useBlankDay,
          allowOnlyOneBlankDayField: preset.allowOnlyOneBlankDayField,
          mustHaveBlankDayField: (_b = preset.mustHaveBlankDayField) !== null && _b !== void 0 ? _b : false,
          useLastDayOfMonth: (_c = preset.useLastDayOfMonth) !== null && _c !== void 0 ? _c : false,
          useLastDayOfWeek: (_d = preset.useLastDayOfWeek) !== null && _d !== void 0 ? _d : false,
          useNearestWeekday: (_e = preset.useNearestWeekday) !== null && _e !== void 0 ? _e : false,
          useNthWeekdayOfMonth: (_f = preset.useNthWeekdayOfMonth) !== null && _f !== void 0 ? _f : false,
          seconds: {
            lowerLimit: (_g = preset.seconds.lowerLimit) !== null && _g !== void 0 ? _g : preset.seconds.minValue,
            upperLimit: (_h = preset.seconds.upperLimit) !== null && _h !== void 0 ? _h : preset.seconds.maxValue
          },
          minutes: {
            lowerLimit: (_j = preset.minutes.lowerLimit) !== null && _j !== void 0 ? _j : preset.minutes.minValue,
            upperLimit: (_k = preset.minutes.upperLimit) !== null && _k !== void 0 ? _k : preset.minutes.maxValue
          },
          hours: {
            lowerLimit: (_l = preset.hours.lowerLimit) !== null && _l !== void 0 ? _l : preset.hours.minValue,
            upperLimit: (_m = preset.hours.upperLimit) !== null && _m !== void 0 ? _m : preset.hours.maxValue
          },
          daysOfMonth: {
            lowerLimit: (_o = preset.daysOfMonth.lowerLimit) !== null && _o !== void 0 ? _o : preset.daysOfMonth.minValue,
            upperLimit: (_p = preset.daysOfMonth.upperLimit) !== null && _p !== void 0 ? _p : preset.daysOfMonth.maxValue
          },
          months: {
            lowerLimit: (_q = preset.months.lowerLimit) !== null && _q !== void 0 ? _q : preset.months.minValue,
            upperLimit: (_r = preset.months.upperLimit) !== null && _r !== void 0 ? _r : preset.months.maxValue
          },
          daysOfWeek: {
            lowerLimit: (_s = preset.daysOfWeek.lowerLimit) !== null && _s !== void 0 ? _s : preset.daysOfWeek.minValue,
            upperLimit: (_t = preset.daysOfWeek.upperLimit) !== null && _t !== void 0 ? _t : preset.daysOfWeek.maxValue
          },
          years: {
            lowerLimit: (_u = preset.years.lowerLimit) !== null && _u !== void 0 ? _u : preset.years.minValue,
            upperLimit: (_v = preset.years.upperLimit) !== null && _v !== void 0 ? _v : preset.years.maxValue
          }
        }), inputOptions.override);
        const optionsSchema = yup.object({
          presetId: yup.string().required(),
          preset: optionPresetSchema.required(),
          useSeconds: yup.boolean().required(),
          useYears: yup.boolean().required(),
          useAliases: yup.boolean(),
          useBlankDay: yup.boolean().required(),
          allowOnlyOneBlankDayField: yup.boolean().required(),
          mustHaveBlankDayField: yup.boolean(),
          useLastDayOfMonth: yup.boolean(),
          useLastDayOfWeek: yup.boolean(),
          useNearestWeekday: yup.boolean(),
          useNthWeekdayOfMonth: yup.boolean(),
          seconds: yup.object({
            lowerLimit: yup.number().min(preset.seconds.minValue).max(preset.seconds.maxValue),
            upperLimit: yup.number().min(preset.seconds.minValue).max(preset.seconds.maxValue)
          }).required(),
          minutes: yup.object({
            lowerLimit: yup.number().min(preset.minutes.minValue).max(preset.minutes.maxValue),
            upperLimit: yup.number().min(preset.minutes.minValue).max(preset.minutes.maxValue)
          }).required(),
          hours: yup.object({
            lowerLimit: yup.number().min(preset.hours.minValue).max(preset.hours.maxValue),
            upperLimit: yup.number().min(preset.hours.minValue).max(preset.hours.maxValue)
          }).required(),
          daysOfMonth: yup.object({
            lowerLimit: yup.number().min(preset.daysOfMonth.minValue).max(preset.daysOfMonth.maxValue),
            upperLimit: yup.number().min(preset.daysOfMonth.minValue).max(preset.daysOfMonth.maxValue)
          }).required(),
          months: yup.object({
            lowerLimit: yup.number().min(preset.months.minValue).max(preset.months.maxValue),
            upperLimit: yup.number().min(preset.months.minValue).max(preset.months.maxValue)
          }).required(),
          daysOfWeek: yup.object({
            lowerLimit: yup.number().min(preset.daysOfWeek.minValue).max(preset.daysOfWeek.maxValue),
            upperLimit: yup.number().min(preset.daysOfWeek.minValue).max(preset.daysOfWeek.maxValue)
          }).required(),
          years: yup.object({
            lowerLimit: yup.number().min(preset.years.minValue).max(preset.years.maxValue),
            upperLimit: yup.number().min(preset.years.minValue).max(preset.years.maxValue)
          }).required()
        }).required();
        const validatedConfig = optionsSchema.validateSync(unvalidatedConfig, {
          strict: false,
          abortEarly: false,
          stripUnknown: true,
          recursive: true
        });
        return (0, result_1.valid)(validatedConfig);
      } catch (validationError) {
        return (0, result_1.err)(validationError.errors);
      }
    };
    exports.validateOptions = validateOptions;
  }
});

// ../../node_modules/cron-validate/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/cron-validate/lib/index.js"(exports, module2) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var result_1 = require_result();
    var secondChecker_1 = __importDefault2(require_secondChecker());
    var minuteChecker_1 = __importDefault2(require_minuteChecker());
    var hourChecker_1 = __importDefault2(require_hourChecker());
    var dayOfMonthChecker_1 = __importDefault2(require_dayOfMonthChecker());
    var monthChecker_1 = __importDefault2(require_monthChecker());
    var dayOfWeekChecker_1 = __importDefault2(require_dayOfWeekChecker());
    var yearChecker_1 = __importDefault2(require_yearChecker());
    var option_1 = require_option();
    require_types();
    var splitCronString = (cronString, options) => {
      const splittedCronString = cronString.trim().split(" ");
      if (options.useSeconds && options.useYears && splittedCronString.length !== 7) {
        return (0, result_1.err)(`Expected 7 values, but got ${splittedCronString.length}.`);
      }
      if ((options.useSeconds && !options.useYears || options.useYears && !options.useSeconds) && splittedCronString.length !== 6) {
        return (0, result_1.err)(`Expected 6 values, but got ${splittedCronString.length}.`);
      }
      if (!options.useSeconds && !options.useYears && splittedCronString.length !== 5) {
        return (0, result_1.err)(`Expected 5 values, but got ${splittedCronString.length}.`);
      }
      const cronData = {
        seconds: options.useSeconds ? splittedCronString[0] : void 0,
        minutes: splittedCronString[options.useSeconds ? 1 : 0],
        hours: splittedCronString[options.useSeconds ? 2 : 1],
        daysOfMonth: splittedCronString[options.useSeconds ? 3 : 2],
        months: splittedCronString[options.useSeconds ? 4 : 3],
        daysOfWeek: splittedCronString[options.useSeconds ? 5 : 4],
        years: options.useYears ? splittedCronString[options.useSeconds ? 6 : 5] : void 0
      };
      return (0, result_1.valid)(cronData);
    };
    var cron2 = (cronString, inputOptions = {}) => {
      const optionsResult = (0, option_1.validateOptions)(inputOptions);
      if (optionsResult.isError()) {
        return optionsResult;
      }
      const options = optionsResult.getValue();
      const cronDataResult = splitCronString(cronString, options);
      if (cronDataResult.isError()) {
        return (0, result_1.err)([`${cronDataResult.getError()} (Input cron: '${cronString}')`]);
      }
      const cronData = cronDataResult.getValue();
      const checkResults = [];
      if (options.useSeconds) {
        checkResults.push((0, secondChecker_1.default)(cronData, options));
      }
      checkResults.push((0, minuteChecker_1.default)(cronData, options));
      checkResults.push((0, hourChecker_1.default)(cronData, options));
      checkResults.push((0, dayOfMonthChecker_1.default)(cronData, options));
      checkResults.push((0, monthChecker_1.default)(cronData, options));
      checkResults.push((0, dayOfWeekChecker_1.default)(cronData, options));
      if (options.useYears) {
        checkResults.push((0, yearChecker_1.default)(cronData, options));
      }
      if (checkResults.every((value) => value.isValid())) {
        return (0, result_1.valid)(cronData);
      }
      const errorArray = [];
      checkResults.forEach((result) => {
        if (result.isError()) {
          result.getError().forEach((error) => {
            errorArray.push(error);
          });
        }
      });
      errorArray.forEach((error, index) => {
        errorArray[index] = `${error} (Input cron: '${cronString}')`;
      });
      return (0, result_1.err)(errorArray);
    };
    exports.default = cron2;
    module2.exports = cron2;
    module2.exports.default = cron2;
  }
});

// ../../node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "../../node_modules/dayjs/dayjs.min.js"(exports, module2) {
    "use strict";
    !function(t5, e10) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e10() : "function" == typeof define && define.amd ? define(e10) : (t5 = "undefined" != typeof globalThis ? globalThis : t5 || self).dayjs = e10();
    }(exports, function() {
      "use strict";
      var t5 = 1e3, e10 = 6e4, n10 = 36e5, r10 = "millisecond", i10 = "second", s10 = "minute", u5 = "hour", a10 = "day", o10 = "week", c10 = "month", f10 = "quarter", h10 = "year", d10 = "date", l10 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t6) {
        var e11 = ["th", "st", "nd", "rd"], n11 = t6 % 100;
        return "[" + t6 + (e11[(n11 - 20) % 10] || e11[n11] || e11[0]) + "]";
      } }, m10 = function(t6, e11, n11) {
        var r11 = String(t6);
        return !r11 || r11.length >= e11 ? t6 : "" + Array(e11 + 1 - r11.length).join(n11) + t6;
      }, v6 = { s: m10, z: function(t6) {
        var e11 = -t6.utcOffset(), n11 = Math.abs(e11), r11 = Math.floor(n11 / 60), i11 = n11 % 60;
        return (e11 <= 0 ? "+" : "-") + m10(r11, 2, "0") + ":" + m10(i11, 2, "0");
      }, m: function t6(e11, n11) {
        if (e11.date() < n11.date())
          return -t6(n11, e11);
        var r11 = 12 * (n11.year() - e11.year()) + (n11.month() - e11.month()), i11 = e11.clone().add(r11, c10), s11 = n11 - i11 < 0, u6 = e11.clone().add(r11 + (s11 ? -1 : 1), c10);
        return +(-(r11 + (n11 - i11) / (s11 ? i11 - u6 : u6 - i11)) || 0);
      }, a: function(t6) {
        return t6 < 0 ? Math.ceil(t6) || 0 : Math.floor(t6);
      }, p: function(t6) {
        return { M: c10, y: h10, w: o10, d: a10, D: d10, h: u5, m: s10, s: i10, ms: r10, Q: f10 }[t6] || String(t6 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t6) {
        return void 0 === t6;
      } }, g10 = "en", D3 = {};
      D3[g10] = M2;
      var p10 = "$isDayjsObject", S = function(t6) {
        return t6 instanceof _ || !(!t6 || !t6[p10]);
      }, w4 = function t6(e11, n11, r11) {
        var i11;
        if (!e11)
          return g10;
        if ("string" == typeof e11) {
          var s11 = e11.toLowerCase();
          D3[s11] && (i11 = s11), n11 && (D3[s11] = n11, i11 = s11);
          var u6 = e11.split("-");
          if (!i11 && u6.length > 1)
            return t6(u6[0]);
        } else {
          var a11 = e11.name;
          D3[a11] = e11, i11 = a11;
        }
        return !r11 && i11 && (g10 = i11), i11 || !r11 && g10;
      }, O = function(t6, e11) {
        if (S(t6))
          return t6.clone();
        var n11 = "object" == typeof e11 ? e11 : {};
        return n11.date = t6, n11.args = arguments, new _(n11);
      }, b10 = v6;
      b10.l = w4, b10.i = S, b10.w = function(t6, e11) {
        return O(t6, { locale: e11.$L, utc: e11.$u, x: e11.$x, $offset: e11.$offset });
      };
      var _ = function() {
        function M3(t6) {
          this.$L = w4(t6.locale, null, true), this.parse(t6), this.$x = this.$x || t6.x || {}, this[p10] = true;
        }
        var m11 = M3.prototype;
        return m11.parse = function(t6) {
          this.$d = function(t7) {
            var e11 = t7.date, n11 = t7.utc;
            if (null === e11)
              return /* @__PURE__ */ new Date(NaN);
            if (b10.u(e11))
              return /* @__PURE__ */ new Date();
            if (e11 instanceof Date)
              return new Date(e11);
            if ("string" == typeof e11 && !/Z$/i.test(e11)) {
              var r11 = e11.match($);
              if (r11) {
                var i11 = r11[2] - 1 || 0, s11 = (r11[7] || "0").substring(0, 3);
                return n11 ? new Date(Date.UTC(r11[1], i11, r11[3] || 1, r11[4] || 0, r11[5] || 0, r11[6] || 0, s11)) : new Date(r11[1], i11, r11[3] || 1, r11[4] || 0, r11[5] || 0, r11[6] || 0, s11);
              }
            }
            return new Date(e11);
          }(t6), this.init();
        }, m11.init = function() {
          var t6 = this.$d;
          this.$y = t6.getFullYear(), this.$M = t6.getMonth(), this.$D = t6.getDate(), this.$W = t6.getDay(), this.$H = t6.getHours(), this.$m = t6.getMinutes(), this.$s = t6.getSeconds(), this.$ms = t6.getMilliseconds();
        }, m11.$utils = function() {
          return b10;
        }, m11.isValid = function() {
          return !(this.$d.toString() === l10);
        }, m11.isSame = function(t6, e11) {
          var n11 = O(t6);
          return this.startOf(e11) <= n11 && n11 <= this.endOf(e11);
        }, m11.isAfter = function(t6, e11) {
          return O(t6) < this.startOf(e11);
        }, m11.isBefore = function(t6, e11) {
          return this.endOf(e11) < O(t6);
        }, m11.$g = function(t6, e11, n11) {
          return b10.u(t6) ? this[e11] : this.set(n11, t6);
        }, m11.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m11.valueOf = function() {
          return this.$d.getTime();
        }, m11.startOf = function(t6, e11) {
          var n11 = this, r11 = !!b10.u(e11) || e11, f11 = b10.p(t6), l11 = function(t7, e12) {
            var i11 = b10.w(n11.$u ? Date.UTC(n11.$y, e12, t7) : new Date(n11.$y, e12, t7), n11);
            return r11 ? i11 : i11.endOf(a10);
          }, $2 = function(t7, e12) {
            return b10.w(n11.toDate()[t7].apply(n11.toDate("s"), (r11 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e12)), n11);
          }, y4 = this.$W, M4 = this.$M, m12 = this.$D, v7 = "set" + (this.$u ? "UTC" : "");
          switch (f11) {
            case h10:
              return r11 ? l11(1, 0) : l11(31, 11);
            case c10:
              return r11 ? l11(1, M4) : l11(0, M4 + 1);
            case o10:
              var g11 = this.$locale().weekStart || 0, D4 = (y4 < g11 ? y4 + 7 : y4) - g11;
              return l11(r11 ? m12 - D4 : m12 + (6 - D4), M4);
            case a10:
            case d10:
              return $2(v7 + "Hours", 0);
            case u5:
              return $2(v7 + "Minutes", 1);
            case s10:
              return $2(v7 + "Seconds", 2);
            case i10:
              return $2(v7 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m11.endOf = function(t6) {
          return this.startOf(t6, false);
        }, m11.$set = function(t6, e11) {
          var n11, o11 = b10.p(t6), f11 = "set" + (this.$u ? "UTC" : ""), l11 = (n11 = {}, n11[a10] = f11 + "Date", n11[d10] = f11 + "Date", n11[c10] = f11 + "Month", n11[h10] = f11 + "FullYear", n11[u5] = f11 + "Hours", n11[s10] = f11 + "Minutes", n11[i10] = f11 + "Seconds", n11[r10] = f11 + "Milliseconds", n11)[o11], $2 = o11 === a10 ? this.$D + (e11 - this.$W) : e11;
          if (o11 === c10 || o11 === h10) {
            var y4 = this.clone().set(d10, 1);
            y4.$d[l11]($2), y4.init(), this.$d = y4.set(d10, Math.min(this.$D, y4.daysInMonth())).$d;
          } else
            l11 && this.$d[l11]($2);
          return this.init(), this;
        }, m11.set = function(t6, e11) {
          return this.clone().$set(t6, e11);
        }, m11.get = function(t6) {
          return this[b10.p(t6)]();
        }, m11.add = function(r11, f11) {
          var d11, l11 = this;
          r11 = Number(r11);
          var $2 = b10.p(f11), y4 = function(t6) {
            var e11 = O(l11);
            return b10.w(e11.date(e11.date() + Math.round(t6 * r11)), l11);
          };
          if ($2 === c10)
            return this.set(c10, this.$M + r11);
          if ($2 === h10)
            return this.set(h10, this.$y + r11);
          if ($2 === a10)
            return y4(1);
          if ($2 === o10)
            return y4(7);
          var M4 = (d11 = {}, d11[s10] = e10, d11[u5] = n10, d11[i10] = t5, d11)[$2] || 1, m12 = this.$d.getTime() + r11 * M4;
          return b10.w(m12, this);
        }, m11.subtract = function(t6, e11) {
          return this.add(-1 * t6, e11);
        }, m11.format = function(t6) {
          var e11 = this, n11 = this.$locale();
          if (!this.isValid())
            return n11.invalidDate || l10;
          var r11 = t6 || "YYYY-MM-DDTHH:mm:ssZ", i11 = b10.z(this), s11 = this.$H, u6 = this.$m, a11 = this.$M, o11 = n11.weekdays, c11 = n11.months, f11 = n11.meridiem, h11 = function(t7, n12, i12, s12) {
            return t7 && (t7[n12] || t7(e11, r11)) || i12[n12].slice(0, s12);
          }, d11 = function(t7) {
            return b10.s(s11 % 12 || 12, t7, "0");
          }, $2 = f11 || function(t7, e12, n12) {
            var r12 = t7 < 12 ? "AM" : "PM";
            return n12 ? r12.toLowerCase() : r12;
          };
          return r11.replace(y3, function(t7, r12) {
            return r12 || function(t8) {
              switch (t8) {
                case "YY":
                  return String(e11.$y).slice(-2);
                case "YYYY":
                  return b10.s(e11.$y, 4, "0");
                case "M":
                  return a11 + 1;
                case "MM":
                  return b10.s(a11 + 1, 2, "0");
                case "MMM":
                  return h11(n11.monthsShort, a11, c11, 3);
                case "MMMM":
                  return h11(c11, a11);
                case "D":
                  return e11.$D;
                case "DD":
                  return b10.s(e11.$D, 2, "0");
                case "d":
                  return String(e11.$W);
                case "dd":
                  return h11(n11.weekdaysMin, e11.$W, o11, 2);
                case "ddd":
                  return h11(n11.weekdaysShort, e11.$W, o11, 3);
                case "dddd":
                  return o11[e11.$W];
                case "H":
                  return String(s11);
                case "HH":
                  return b10.s(s11, 2, "0");
                case "h":
                  return d11(1);
                case "hh":
                  return d11(2);
                case "a":
                  return $2(s11, u6, true);
                case "A":
                  return $2(s11, u6, false);
                case "m":
                  return String(u6);
                case "mm":
                  return b10.s(u6, 2, "0");
                case "s":
                  return String(e11.$s);
                case "ss":
                  return b10.s(e11.$s, 2, "0");
                case "SSS":
                  return b10.s(e11.$ms, 3, "0");
                case "Z":
                  return i11;
              }
              return null;
            }(t7) || i11.replace(":", "");
          });
        }, m11.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m11.diff = function(r11, d11, l11) {
          var $2, y4 = this, M4 = b10.p(d11), m12 = O(r11), v7 = (m12.utcOffset() - this.utcOffset()) * e10, g11 = this - m12, D4 = function() {
            return b10.m(y4, m12);
          };
          switch (M4) {
            case h10:
              $2 = D4() / 12;
              break;
            case c10:
              $2 = D4();
              break;
            case f10:
              $2 = D4() / 3;
              break;
            case o10:
              $2 = (g11 - v7) / 6048e5;
              break;
            case a10:
              $2 = (g11 - v7) / 864e5;
              break;
            case u5:
              $2 = g11 / n10;
              break;
            case s10:
              $2 = g11 / e10;
              break;
            case i10:
              $2 = g11 / t5;
              break;
            default:
              $2 = g11;
          }
          return l11 ? $2 : b10.a($2);
        }, m11.daysInMonth = function() {
          return this.endOf(c10).$D;
        }, m11.$locale = function() {
          return D3[this.$L];
        }, m11.locale = function(t6, e11) {
          if (!t6)
            return this.$L;
          var n11 = this.clone(), r11 = w4(t6, e11, true);
          return r11 && (n11.$L = r11), n11;
        }, m11.clone = function() {
          return b10.w(this.$d, this);
        }, m11.toDate = function() {
          return new Date(this.valueOf());
        }, m11.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m11.toISOString = function() {
          return this.$d.toISOString();
        }, m11.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), k10 = _.prototype;
      return O.prototype = k10, [["$ms", r10], ["$s", i10], ["$m", s10], ["$H", u5], ["$W", a10], ["$M", c10], ["$y", h10], ["$D", d10]].forEach(function(t6) {
        k10[t6[1]] = function(e11) {
          return this.$g(e11, t6[0], t6[1]);
        };
      }), O.extend = function(t6, e11) {
        return t6.$i || (t6(e11, _, O), t6.$i = true), O;
      }, O.locale = w4, O.isDayjs = S, O.unix = function(t6) {
        return O(1e3 * t6);
      }, O.en = D3[g10], O.Ls = D3, O.p = {}, O;
    });
  }
});

// ../../node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS({
  "../../node_modules/dayjs/plugin/utc.js"(exports, module2) {
    "use strict";
    !function(t5, i10) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = i10() : "function" == typeof define && define.amd ? define(i10) : (t5 = "undefined" != typeof globalThis ? globalThis : t5 || self).dayjs_plugin_utc = i10();
    }(exports, function() {
      "use strict";
      var t5 = "minute", i10 = /[+-]\d\d(?::?\d\d)?/g, e10 = /([+-]|\d\d)/g;
      return function(s10, f10, n10) {
        var u5 = f10.prototype;
        n10.utc = function(t6) {
          var i11 = { date: t6, utc: true, args: arguments };
          return new f10(i11);
        }, u5.utc = function(i11) {
          var e11 = n10(this.toDate(), { locale: this.$L, utc: true });
          return i11 ? e11.add(this.utcOffset(), t5) : e11;
        }, u5.local = function() {
          return n10(this.toDate(), { locale: this.$L, utc: false });
        };
        var o10 = u5.parse;
        u5.parse = function(t6) {
          t6.utc && (this.$u = true), this.$utils().u(t6.$offset) || (this.$offset = t6.$offset), o10.call(this, t6);
        };
        var r10 = u5.init;
        u5.init = function() {
          if (this.$u) {
            var t6 = this.$d;
            this.$y = t6.getUTCFullYear(), this.$M = t6.getUTCMonth(), this.$D = t6.getUTCDate(), this.$W = t6.getUTCDay(), this.$H = t6.getUTCHours(), this.$m = t6.getUTCMinutes(), this.$s = t6.getUTCSeconds(), this.$ms = t6.getUTCMilliseconds();
          } else
            r10.call(this);
        };
        var a10 = u5.utcOffset;
        u5.utcOffset = function(s11, f11) {
          var n11 = this.$utils().u;
          if (n11(s11))
            return this.$u ? 0 : n11(this.$offset) ? a10.call(this) : this.$offset;
          if ("string" == typeof s11 && (s11 = function(t6) {
            void 0 === t6 && (t6 = "");
            var s12 = t6.match(i10);
            if (!s12)
              return null;
            var f12 = ("" + s12[0]).match(e10) || ["-", 0, 0], n12 = f12[0], u7 = 60 * +f12[1] + +f12[2];
            return 0 === u7 ? 0 : "+" === n12 ? u7 : -u7;
          }(s11), null === s11))
            return this;
          var u6 = Math.abs(s11) <= 16 ? 60 * s11 : s11, o11 = this;
          if (f11)
            return o11.$offset = u6, o11.$u = 0 === s11, o11;
          if (0 !== s11) {
            var r11 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
            (o11 = this.local().add(u6 + r11, t5)).$offset = u6, o11.$x.$localOffset = r11;
          } else
            o11 = this.utc();
          return o11;
        };
        var h10 = u5.format;
        u5.format = function(t6) {
          var i11 = t6 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return h10.call(this, i11);
        }, u5.valueOf = function() {
          var t6 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * t6;
        }, u5.isUTC = function() {
          return !!this.$u;
        }, u5.toISOString = function() {
          return this.toDate().toISOString();
        }, u5.toString = function() {
          return this.toDate().toUTCString();
        };
        var l10 = u5.toDate;
        u5.toDate = function(t6) {
          return "s" === t6 && this.$offset ? n10(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l10.call(this);
        };
        var c10 = u5.diff;
        u5.diff = function(t6, i11, e11) {
          if (t6 && this.$u === t6.$u)
            return c10.call(this, t6, i11, e11);
          var s11 = this.local(), f11 = n10(t6).local();
          return c10.call(s11, f11, i11, e11);
        };
      };
    });
  }
});

// ../../node_modules/dread/configure.js
var require_configure = __commonJS({
  "../../node_modules/dread/configure.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    module2.exports = function configure(arg, current) {
      if (arg.retries) {
        if (arg.attempts) {
          throw new Error("Specify attempts or retries, but not both");
        }
        arg.attempts = arg.retries + 1;
        delete arg.retries;
      }
      const {
        attempts = current.attempts,
        backoff = current.backoff,
        condition = current.condition,
        timeout = current.timeout
      } = arg;
      assert(Number.isInteger(attempts) && attempts > 0, "attempts must be an integer > 0");
      assert(typeof backoff === "function", "backoff must be a function");
      assert(typeof condition === "function", "condition must be a function");
      assert(timeout === void 0 || Number.isInteger(timeout), "timeout, if specified, must be a number");
      arg.attempts = attempts;
      arg.backoff = backoff;
      arg.condition = condition;
      arg.timeout = timeout;
      return arg;
    };
  }
});

// ../../node_modules/dread/execute.js
var require_execute = __commonJS({
  "../../node_modules/dread/execute.js"(exports, module2) {
    "use strict";
    var RETRYABLE = Symbol();
    module2.exports = async function execute(task2, { attempts, backoff, condition, timeout }) {
      let number2 = 1, result, control, operationHandle, attemptHandle, delayHandle;
      function abort(reason, retryable = true) {
        if (result) {
          return;
        }
        const error = typeof reason === "string" ? new Error(reason) : reason;
        error[RETRYABLE] = retryable;
        control(error);
      }
      const attempt = {
        get attempt() {
          return number2;
        },
        get number() {
          return number2;
        },
        cancel(reason = "Attempt cancelled") {
          abort(reason);
        },
        timeout(duration) {
          clearTimeout(attemptHandle);
          attemptHandle = setTimeout(function attemptTimeout() {
            abort(`Attempt timed out after ${duration} ms`);
          }, duration);
        }
      };
      if (timeout) {
        operationHandle = setTimeout(function operationTimeout() {
          abort(`Operation timed out after ${timeout} ms`, false);
        }, timeout);
      }
      for (; ; number2 += 1) {
        try {
          result = await Promise.race([
            new Promise((_, reject) => {
              control = reject;
            }),
            task2(attempt)
          ]);
          return result;
        } catch (error) {
          const retryable = error[RETRYABLE];
          delete error[RETRYABLE];
          if (number2 < attempts) {
            const shouldRetry = retryable === void 0 ? await condition(error) : retryable;
            if (shouldRetry) {
              const delay = await backoff(number2, error);
              await new Promise((resolve) => {
                delayHandle = setTimeout(resolve, delay);
              });
              continue;
            }
          }
          throw error;
        } finally {
          clearTimeout(delayHandle);
          clearTimeout(attemptHandle);
          clearTimeout(operationHandle);
        }
      }
    };
  }
});

// ../../node_modules/dread/backoff.js
var require_backoff = __commonJS({
  "../../node_modules/dread/backoff.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    var JitterType = Object.freeze({
      NONE: "NONE",
      // use full backoff
      FULL: "FULL",
      // random value between 0 and backoff
      HALF: "HALF"
      // random value between backoff/2 and backoff
    });
    function getJitter({ jitter = JitterType.FULL }) {
      if (typeof jitter === "boolean") {
        return jitter ? JitterType.FULL : JitterType.NONE;
      }
      return jitter.toUpperCase();
    }
    function backoff(number2, base, factor, cap) {
      return Math.min(base * Math.pow(factor, number2), cap);
    }
    function exp(options = {}) {
      const { base = 100, factor = 2, limit = 1e4 } = options;
      assert(Number.isInteger(base), "base must be an integer");
      assert(Number.isInteger(factor), "factor must be an integer");
      assert(Number.isInteger(limit), "limit must be an integer");
      const cap = limit || Number.MAX_SAFE_INTEGER;
      const jitter = getJitter(options);
      assert(typeof jitter === "string", "jitter must be string");
      assert(jitter in JitterType, `invalid jitter value, use JitterType ${Object.keys(JitterType)}`);
      switch (jitter) {
        case JitterType.FULL:
          return (number2) => Math.round(Math.random() * backoff(number2, base, factor, cap));
        case JitterType.HALF:
          return (number2) => {
            const halfBackoff = backoff(number2, base, factor, cap) / 2;
            return Math.round(halfBackoff + Math.random() * halfBackoff);
          };
        case JitterType.NONE:
        default:
          return (number2) => Math.round(backoff(number2, base, factor, cap));
      }
    }
    module2.exports = { exp, JitterType };
  }
});

// ../../node_modules/dread/condition.js
var require_condition = __commonJS({
  "../../node_modules/dread/condition.js"(exports, module2) {
    "use strict";
    function prop(n10) {
      return (err) => !!err[n10];
    }
    function is(t5) {
      return (err) => err instanceof t5;
    }
    function code(v6) {
      return (err) => err.code === v6;
    }
    function always() {
      return () => true;
    }
    module2.exports = { prop, is, code, always };
  }
});

// ../../node_modules/dread/dread.js
var require_dread = __commonJS({
  "../../node_modules/dread/dread.js"(exports, module2) {
    "use strict";
    var configure = require_configure();
    var execute = require_execute();
    var { exp, JitterType } = require_backoff();
    var { prop, is, code, always } = require_condition();
    var defaults = {
      attempts: 10,
      condition: prop("retryable"),
      backoff: exp(),
      timeout: void 0
    };
    module2.exports = function dread2() {
      let task2, config = defaults;
      for (const arg of arguments) {
        if (typeof arg === "function") {
          task2 = arg;
        } else {
          config = configure(arg, config);
        }
      }
      return typeof task2 === "function" ? execute(task2, config) : dread2.bind(null, config);
    };
    Object.assign(module2.exports, { prop, is, code, exp, always, JitterType });
  }
});

// ../../node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "../../node_modules/uuid/dist/esm-node/rng.js"() {
    "use strict";
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// ../../node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "../../node_modules/uuid/dist/esm-node/regex.js"() {
    "use strict";
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// ../../node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "../../node_modules/uuid/dist/esm-node/validate.js"() {
    "use strict";
    init_regex();
    validate_default = validate;
  }
});

// ../../node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "../../node_modules/uuid/dist/esm-node/stringify.js"() {
    "use strict";
    init_validate();
    byteToHex = [];
    for (let i10 = 0; i10 < 256; ++i10) {
      byteToHex.push((i10 + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// ../../node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i10 = 0; i10 < 16; ++i10) {
      buf[offset + i10] = rnds[i10];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "../../node_modules/uuid/dist/esm-node/v4.js"() {
    "use strict";
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// ../../node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "../../node_modules/uuid/dist/esm-node/index.js"() {
    "use strict";
    init_v4();
  }
});

// ../../node_modules/@aws-sdk/util-config-provider/dist-es/booleanSelector.js
var SelectorType, booleanSelector;
var init_booleanSelector = __esm({
  "../../node_modules/@aws-sdk/util-config-provider/dist-es/booleanSelector.js"() {
    "use strict";
    (function(SelectorType3) {
      SelectorType3["ENV"] = "env";
      SelectorType3["CONFIG"] = "shared config entry";
    })(SelectorType || (SelectorType = {}));
    booleanSelector = (obj, key, type) => {
      if (!(key in obj))
        return void 0;
      if (obj[key] === "true")
        return true;
      if (obj[key] === "false")
        return false;
      throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
    };
  }
});

// ../../node_modules/@aws-sdk/util-config-provider/dist-es/index.js
var init_dist_es = __esm({
  "../../node_modules/@aws-sdk/util-config-provider/dist-es/index.js"() {
    "use strict";
    init_booleanSelector();
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var ENV_USE_DUALSTACK_ENDPOINT, CONFIG_USE_DUALSTACK_ENDPOINT, NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS;
var init_NodeUseDualstackEndpointConfigOptions = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js"() {
    "use strict";
    init_dist_es();
    ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
    CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
    NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: (env3) => booleanSelector(env3, ENV_USE_DUALSTACK_ENDPOINT, SelectorType.ENV),
      configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, SelectorType.CONFIG),
      default: false
    };
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var ENV_USE_FIPS_ENDPOINT, CONFIG_USE_FIPS_ENDPOINT, NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS;
var init_NodeUseFipsEndpointConfigOptions = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js"() {
    "use strict";
    init_dist_es();
    ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
    CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
    NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: (env3) => booleanSelector(env3, ENV_USE_FIPS_ENDPOINT, SelectorType.ENV),
      configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, SelectorType.CONFIG),
      default: false
    };
  }
});

// ../../node_modules/@aws-sdk/util-middleware/dist-es/normalizeProvider.js
var normalizeProvider;
var init_normalizeProvider = __esm({
  "../../node_modules/@aws-sdk/util-middleware/dist-es/normalizeProvider.js"() {
    "use strict";
    normalizeProvider = (input) => {
      if (typeof input === "function")
        return input;
      const promisified = Promise.resolve(input);
      return () => promisified;
    };
  }
});

// ../../node_modules/@aws-sdk/util-middleware/dist-es/index.js
var init_dist_es2 = __esm({
  "../../node_modules/@aws-sdk/util-middleware/dist-es/index.js"() {
    "use strict";
    init_normalizeProvider();
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js
var init_resolveCustomEndpointsConfig = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js"() {
    "use strict";
    init_dist_es2();
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/utils/getEndpointFromRegion.js
var init_getEndpointFromRegion = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/utils/getEndpointFromRegion.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js
var init_resolveEndpointsConfig = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js"() {
    "use strict";
    init_dist_es2();
    init_getEndpointFromRegion();
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/index.js
var init_endpointsConfig = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/endpointsConfig/index.js"() {
    "use strict";
    init_NodeUseDualstackEndpointConfigOptions();
    init_NodeUseFipsEndpointConfigOptions();
    init_resolveCustomEndpointsConfig();
    init_resolveEndpointsConfig();
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/config.js
var REGION_ENV_NAME, REGION_INI_NAME, NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS;
var init_config = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/config.js"() {
    "use strict";
    REGION_ENV_NAME = "AWS_REGION";
    REGION_INI_NAME = "region";
    NODE_REGION_CONFIG_OPTIONS = {
      environmentVariableSelector: (env3) => env3[REGION_ENV_NAME],
      configFileSelector: (profile) => profile[REGION_INI_NAME],
      default: () => {
        throw new Error("Region is missing");
      }
    };
    NODE_REGION_CONFIG_FILE_OPTIONS = {
      preferredFile: "credentials"
    };
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/isFipsRegion.js
var isFipsRegion;
var init_isFipsRegion = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/isFipsRegion.js"() {
    "use strict";
    isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion;
var init_getRealRegion = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/getRealRegion.js"() {
    "use strict";
    init_isFipsRegion();
    getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig;
var init_resolveRegionConfig = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/resolveRegionConfig.js"() {
    "use strict";
    init_getRealRegion();
    init_isFipsRegion();
    resolveRegionConfig = (input) => {
      const { region, useFipsEndpoint } = input;
      if (!region) {
        throw new Error("Region is missing");
      }
      return {
        ...input,
        region: async () => {
          if (typeof region === "string") {
            return getRealRegion(region);
          }
          const providedRegion = await region();
          return getRealRegion(providedRegion);
        },
        useFipsEndpoint: async () => {
          const providedRegion = typeof region === "string" ? region : await region();
          if (isFipsRegion(providedRegion)) {
            return true;
          }
          return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        }
      };
    };
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/index.js
var init_regionConfig = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionConfig/index.js"() {
    "use strict";
    init_config();
    init_resolveRegionConfig();
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/PartitionHash.js
var init_PartitionHash = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/PartitionHash.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/RegionHash.js
var init_RegionHash = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/RegionHash.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/getHostnameFromVariants.js
var init_getHostnameFromVariants = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/getHostnameFromVariants.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/getResolvedHostname.js
var init_getResolvedHostname = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/getResolvedHostname.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/getResolvedPartition.js
var init_getResolvedPartition = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/getResolvedPartition.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/getResolvedSigningRegion.js
var init_getResolvedSigningRegion = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/getResolvedSigningRegion.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/getRegionInfo.js
var init_getRegionInfo = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/getRegionInfo.js"() {
    "use strict";
    init_getHostnameFromVariants();
    init_getResolvedHostname();
    init_getResolvedPartition();
    init_getResolvedSigningRegion();
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/index.js
var init_regionInfo = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/regionInfo/index.js"() {
    "use strict";
    init_PartitionHash();
    init_RegionHash();
    init_getRegionInfo();
  }
});

// ../../node_modules/@aws-sdk/config-resolver/dist-es/index.js
var init_dist_es3 = __esm({
  "../../node_modules/@aws-sdk/config-resolver/dist-es/index.js"() {
    "use strict";
    init_endpointsConfig();
    init_regionConfig();
    init_regionInfo();
  }
});

// ../../node_modules/@aws-sdk/protocol-http/dist-es/FieldPosition.js
var FieldPosition;
var init_FieldPosition = __esm({
  "../../node_modules/@aws-sdk/protocol-http/dist-es/FieldPosition.js"() {
    "use strict";
    (function(FieldPosition3) {
      FieldPosition3[FieldPosition3["HEADER"] = 0] = "HEADER";
      FieldPosition3[FieldPosition3["TRAILER"] = 1] = "TRAILER";
    })(FieldPosition || (FieldPosition = {}));
  }
});

// ../../node_modules/@aws-sdk/protocol-http/dist-es/Field.js
var init_Field = __esm({
  "../../node_modules/@aws-sdk/protocol-http/dist-es/Field.js"() {
    "use strict";
    init_FieldPosition();
  }
});

// ../../node_modules/@aws-sdk/protocol-http/dist-es/Fields.js
var init_Fields = __esm({
  "../../node_modules/@aws-sdk/protocol-http/dist-es/Fields.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/protocol-http/dist-es/httpHandler.js
var init_httpHandler = __esm({
  "../../node_modules/@aws-sdk/protocol-http/dist-es/httpHandler.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/protocol-http/dist-es/httpRequest.js
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}
var HttpRequest;
var init_httpRequest = __esm({
  "../../node_modules/@aws-sdk/protocol-http/dist-es/httpRequest.js"() {
    "use strict";
    HttpRequest = class _HttpRequest {
      constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
        this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
      }
      static isInstance(request3) {
        if (!request3)
          return false;
        const req = request3;
        return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
      }
      clone() {
        const cloned = new _HttpRequest({
          ...this,
          headers: { ...this.headers }
        });
        if (cloned.query)
          cloned.query = cloneQuery(cloned.query);
        return cloned;
      }
    };
  }
});

// ../../node_modules/@aws-sdk/protocol-http/dist-es/httpResponse.js
var HttpResponse;
var init_httpResponse = __esm({
  "../../node_modules/@aws-sdk/protocol-http/dist-es/httpResponse.js"() {
    "use strict";
    HttpResponse = class {
      constructor(options) {
        this.statusCode = options.statusCode;
        this.headers = options.headers || {};
        this.body = options.body;
      }
      static isInstance(response) {
        if (!response)
          return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
      }
    };
  }
});

// ../../node_modules/@aws-sdk/protocol-http/dist-es/isValidHostname.js
var init_isValidHostname = __esm({
  "../../node_modules/@aws-sdk/protocol-http/dist-es/isValidHostname.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/protocol-http/dist-es/index.js
var init_dist_es4 = __esm({
  "../../node_modules/@aws-sdk/protocol-http/dist-es/index.js"() {
    "use strict";
    init_Field();
    init_FieldPosition();
    init_Fields();
    init_httpHandler();
    init_httpRequest();
    init_httpResponse();
    init_isValidHostname();
  }
});

// ../../node_modules/@aws-sdk/middleware-content-length/dist-es/index.js
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request3 = args.request;
    if (HttpRequest.isInstance(request3)) {
      const { body, headers } = request3;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request3.headers = {
            ...request3.headers,
            [CONTENT_LENGTH_HEADER]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request: request3
    });
  };
}
var CONTENT_LENGTH_HEADER, contentLengthMiddlewareOptions, getContentLengthPlugin;
var init_dist_es5 = __esm({
  "../../node_modules/@aws-sdk/middleware-content-length/dist-es/index.js"() {
    "use strict";
    init_dist_es4();
    CONTENT_LENGTH_HEADER = "content-length";
    contentLengthMiddlewareOptions = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: true
    };
    getContentLengthPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
      }
    });
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/service-customizations/s3.js
var resolveParamsForS3, DOMAIN_PATTERN, IP_ADDRESS_PATTERN, DOTS_PATTERN, isDnsCompatibleBucketName, isArnBucketName;
var init_s3 = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/service-customizations/s3.js"() {
    "use strict";
    resolveParamsForS3 = async (endpointParams) => {
      const bucket = endpointParams?.Bucket || "";
      if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
      }
      if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
          throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
      } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
      }
      if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
      }
      return endpointParams;
    };
    DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
    IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
    DOTS_PATTERN = /\.\./;
    isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
    isArnBucketName = (bucketName) => {
      const [arn, partition3, service, region, account, typeOrId] = bucketName.split(":");
      const isArn = arn === "arn" && bucketName.split(":").length >= 6;
      const isValidArn = [arn, partition3, service, account, typeOrId].filter(Boolean).length === 5;
      if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
      }
      return arn === "arn" && !!partition3 && !!service && !!account && !!typeOrId;
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/service-customizations/index.js
var init_service_customizations = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/service-customizations/index.js"() {
    "use strict";
    init_s3();
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
var createConfigValueProvider;
var init_createConfigValueProvider = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js"() {
    "use strict";
    createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
      const configProvider = async () => {
        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
          return configValue();
        }
        return configValue;
      };
      if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
          const endpoint = await configProvider();
          if (endpoint && typeof endpoint === "object") {
            if ("url" in endpoint) {
              return endpoint.url.href;
            }
            if ("hostname" in endpoint) {
              const { protocol, hostname, port, path } = endpoint;
              return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
            }
          }
          return endpoint;
        };
      }
      return configProvider;
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions, resolveParams;
var init_getEndpointFromInstructions = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js"() {
    "use strict";
    init_service_customizations();
    init_createConfigValueProvider();
    getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
      const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
      if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
      }
      const endpoint = clientConfig.endpointProvider(endpointParams, context);
      return endpoint;
    };
    resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
      const endpointParams = {};
      const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
      for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
          case "staticContextParams":
            endpointParams[name] = instruction.value;
            break;
          case "contextParams":
            endpointParams[name] = commandInput[instruction.name];
            break;
          case "clientContextParams":
          case "builtInParams":
            endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
            break;
          default:
            throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
      }
      if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
      }
      if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
      }
      return endpointParams;
    };
  }
});

// ../../node_modules/@aws-sdk/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}
var init_dist_es6 = __esm({
  "../../node_modules/@aws-sdk/querystring-parser/dist-es/index.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/url-parser/dist-es/index.js
var parseUrl;
var init_dist_es7 = __esm({
  "../../node_modules/@aws-sdk/url-parser/dist-es/index.js"() {
    "use strict";
    init_dist_es6();
    parseUrl = (url) => {
      if (typeof url === "string") {
        return parseUrl(new URL(url));
      }
      const { hostname, pathname, port, protocol, search } = url;
      let query;
      if (search) {
        query = parseQueryString(search);
      }
      return {
        hostname,
        port: port ? parseInt(port) : void 0,
        protocol,
        path: pathname,
        query
      };
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV1;
var init_toEndpointV1 = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/toEndpointV1.js"() {
    "use strict";
    init_dist_es7();
    toEndpointV1 = (endpoint) => {
      if (typeof endpoint === "object") {
        if ("url" in endpoint) {
          return parseUrl(endpoint.url);
        }
        return endpoint;
      }
      return parseUrl(endpoint);
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/index.js
var init_adaptors = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/adaptors/index.js"() {
    "use strict";
    init_getEndpointFromInstructions();
    init_toEndpointV1();
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/endpointMiddleware.js
var endpointMiddleware;
var init_endpointMiddleware = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/endpointMiddleware.js"() {
    "use strict";
    init_getEndpointFromInstructions();
    endpointMiddleware = ({ config, instructions }) => {
      return (next, context) => async (args) => {
        const endpoint = await getEndpointFromInstructions(args.input, {
          getEndpointParameterInstructions() {
            return instructions;
          }
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
          context["signing_region"] = authScheme.signingRegion;
          context["signing_service"] = authScheme.signingName;
        }
        return next({
          ...args
        });
      };
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-serde/dist-es/deserializerMiddleware.js
var deserializerMiddleware;
var init_deserializerMiddleware = __esm({
  "../../node_modules/@aws-sdk/middleware-serde/dist-es/deserializerMiddleware.js"() {
    "use strict";
    deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
      const { response } = await next(args);
      try {
        const parsed = await deserializer(response, options);
        return {
          response,
          output: parsed
        };
      } catch (error) {
        Object.defineProperty(error, "$response", {
          value: response
        });
        throw error;
      }
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-serde/dist-es/serializerMiddleware.js
var serializerMiddleware;
var init_serializerMiddleware = __esm({
  "../../node_modules/@aws-sdk/middleware-serde/dist-es/serializerMiddleware.js"() {
    "use strict";
    serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
      const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
      if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
      }
      const request3 = await serializer(args.input, { ...options, endpoint });
      return next({
        ...args,
        request: request3
      });
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-serde/dist-es/serdePlugin.js
function getSerdePlugin(config, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
    }
  };
}
var deserializerMiddlewareOption, serializerMiddlewareOption;
var init_serdePlugin = __esm({
  "../../node_modules/@aws-sdk/middleware-serde/dist-es/serdePlugin.js"() {
    "use strict";
    init_deserializerMiddleware();
    init_serializerMiddleware();
    deserializerMiddlewareOption = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: true
    };
    serializerMiddlewareOption = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: true
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-serde/dist-es/index.js
var init_dist_es8 = __esm({
  "../../node_modules/@aws-sdk/middleware-serde/dist-es/index.js"() {
    "use strict";
    init_deserializerMiddleware();
    init_serdePlugin();
    init_serializerMiddleware();
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions, getEndpointPlugin;
var init_getEndpointPlugin = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/getEndpointPlugin.js"() {
    "use strict";
    init_dist_es8();
    init_endpointMiddleware();
    endpointMiddlewareOptions = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: true,
      relation: "before",
      toMiddleware: serializerMiddlewareOption.name
    };
    getEndpointPlugin = (config, instructions) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
          config,
          instructions
        }), endpointMiddlewareOptions);
      }
    });
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/resolveEndpointConfig.js
var resolveEndpointConfig;
var init_resolveEndpointConfig = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/resolveEndpointConfig.js"() {
    "use strict";
    init_dist_es2();
    init_toEndpointV1();
    resolveEndpointConfig = (input) => {
      const tls = input.tls ?? true;
      const { endpoint } = input;
      const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : void 0;
      const isCustomEndpoint = !!endpoint;
      return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
        useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false)
      };
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/types.js
var init_types = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/types.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/middleware-endpoint/dist-es/index.js
var init_dist_es9 = __esm({
  "../../node_modules/@aws-sdk/middleware-endpoint/dist-es/index.js"() {
    "use strict";
    init_adaptors();
    init_endpointMiddleware();
    init_getEndpointPlugin();
    init_resolveEndpointConfig();
    init_types();
  }
});

// ../../node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig(input) {
  return input;
}
var hostHeaderMiddleware, hostHeaderMiddlewareOptions, getHostHeaderPlugin;
var init_dist_es10 = __esm({
  "../../node_modules/@aws-sdk/middleware-host-header/dist-es/index.js"() {
    "use strict";
    init_dist_es4();
    hostHeaderMiddleware = (options) => (next) => async (args) => {
      if (!HttpRequest.isInstance(args.request))
        return next(args);
      const { request: request3 } = args;
      const { handlerProtocol = "" } = options.requestHandler.metadata || {};
      if (handlerProtocol.indexOf("h2") >= 0 && !request3.headers[":authority"]) {
        delete request3.headers["host"];
        request3.headers[":authority"] = "";
      } else if (!request3.headers["host"]) {
        request3.headers["host"] = request3.hostname;
      }
      return next(args);
    };
    hostHeaderMiddlewareOptions = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: true
    };
    getHostHeaderPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
      }
    });
  }
});

// ../../node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
var loggerMiddleware, loggerMiddlewareOptions, getLoggerPlugin;
var init_loggerMiddleware = __esm({
  "../../node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js"() {
    "use strict";
    loggerMiddleware = () => (next, context) => async (args) => {
      const response = await next(args);
      const { clientName, commandName, logger: logger3, inputFilterSensitiveLog, outputFilterSensitiveLog, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      if (!logger3) {
        return response;
      }
      if (typeof logger3.info === "function") {
        const { $metadata, ...outputWithoutMetadata } = response.output;
        logger3.info({
          clientName,
          commandName,
          input: (overrideInputFilterSensitiveLog ?? inputFilterSensitiveLog)(args.input),
          output: (overrideOutputFilterSensitiveLog ?? outputFilterSensitiveLog)(outputWithoutMetadata),
          metadata: $metadata
        });
      }
      return response;
    };
    loggerMiddlewareOptions = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: true
    };
    getLoggerPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
      }
    });
  }
});

// ../../node_modules/@aws-sdk/middleware-logger/dist-es/index.js
var init_dist_es11 = __esm({
  "../../node_modules/@aws-sdk/middleware-logger/dist-es/index.js"() {
    "use strict";
    init_loggerMiddleware();
  }
});

// ../../node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var TRACE_ID_HEADER_NAME, ENV_LAMBDA_FUNCTION_NAME, ENV_TRACE_ID, recursionDetectionMiddleware, addRecursionDetectionMiddlewareOptions, getRecursionDetectionPlugin;
var init_dist_es12 = __esm({
  "../../node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js"() {
    "use strict";
    init_dist_es4();
    TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
    ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
    ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
    recursionDetectionMiddleware = (options) => (next) => async (args) => {
      const { request: request3 } = args;
      if (!HttpRequest.isInstance(request3) || options.runtime !== "node" || request3.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
        return next(args);
      }
      const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
      const traceId = process.env[ENV_TRACE_ID];
      const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
      if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
        request3.headers[TRACE_ID_HEADER_NAME] = traceId;
      }
      return next({
        ...args,
        request: request3
      });
    };
    addRecursionDetectionMiddlewareOptions = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: true,
      priority: "low"
    };
    getRecursionDetectionPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
      }
    });
  }
});

// ../../node_modules/@aws-sdk/util-retry/dist-es/config.js
var RETRY_MODES, DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_MODE;
var init_config2 = __esm({
  "../../node_modules/@aws-sdk/util-retry/dist-es/config.js"() {
    "use strict";
    (function(RETRY_MODES3) {
      RETRY_MODES3["STANDARD"] = "standard";
      RETRY_MODES3["ADAPTIVE"] = "adaptive";
    })(RETRY_MODES || (RETRY_MODES = {}));
    DEFAULT_MAX_ATTEMPTS = 3;
    DEFAULT_RETRY_MODE = "STANDARD";
  }
});

// ../../node_modules/@aws-sdk/service-error-classification/dist-es/constants.js
var THROTTLING_ERROR_CODES, TRANSIENT_ERROR_CODES, TRANSIENT_ERROR_STATUS_CODES, NODEJS_TIMEOUT_ERROR_CODES;
var init_constants = __esm({
  "../../node_modules/@aws-sdk/service-error-classification/dist-es/constants.js"() {
    "use strict";
    THROTTLING_ERROR_CODES = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException"
    ];
    TRANSIENT_ERROR_CODES = ["AbortError", "TimeoutError", "RequestTimeout", "RequestTimeoutException"];
    TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
    NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  }
});

// ../../node_modules/@aws-sdk/service-error-classification/dist-es/index.js
var isThrottlingError, isTransientError, isServerError;
var init_dist_es13 = __esm({
  "../../node_modules/@aws-sdk/service-error-classification/dist-es/index.js"() {
    "use strict";
    init_constants();
    isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true;
    isTransientError = (error) => TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0);
    isServerError = (error) => {
      if (error.$metadata?.httpStatusCode !== void 0) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
          return true;
        }
        return false;
      }
      return false;
    };
  }
});

// ../../node_modules/@aws-sdk/util-retry/dist-es/DefaultRateLimiter.js
var DefaultRateLimiter;
var init_DefaultRateLimiter = __esm({
  "../../node_modules/@aws-sdk/util-retry/dist-es/DefaultRateLimiter.js"() {
    "use strict";
    init_dist_es13();
    DefaultRateLimiter = class {
      constructor(options) {
        this.currentCapacity = 0;
        this.enabled = false;
        this.lastMaxRate = 0;
        this.measuredTxRate = 0;
        this.requestCount = 0;
        this.lastTimestamp = 0;
        this.timeWindow = 0;
        this.beta = options?.beta ?? 0.7;
        this.minCapacity = options?.minCapacity ?? 1;
        this.minFillRate = options?.minFillRate ?? 0.5;
        this.scaleConstant = options?.scaleConstant ?? 0.4;
        this.smooth = options?.smooth ?? 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(amount) {
        if (!this.enabled) {
          return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
          const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
      }
      refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = timestamp;
          return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
      }
      updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if (isThrottlingError(response)) {
          const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
          this.lastMaxRate = rateToUse;
          this.calculateTimeWindow();
          this.lastThrottleTime = this.getCurrentTimeInSeconds();
          calculatedRate = this.cubicThrottle(rateToUse);
          this.enableTokenBucket();
        } else {
          this.calculateTimeWindow();
          calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
      }
      cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
      }
      cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
      }
      enableTokenBucket() {
        this.enabled = true;
      }
      updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
      }
      updateMeasuredRate() {
        const t5 = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t5 * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
          const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
          this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
          this.requestCount = 0;
          this.lastTxRateBucket = timeBucket;
        }
      }
      getPrecise(num) {
        return parseFloat(num.toFixed(8));
      }
    };
  }
});

// ../../node_modules/@aws-sdk/util-retry/dist-es/constants.js
var DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY, THROTTLING_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, RETRY_COST, TIMEOUT_RETRY_COST, NO_RETRY_INCREMENT, INVOCATION_ID_HEADER, REQUEST_HEADER;
var init_constants2 = __esm({
  "../../node_modules/@aws-sdk/util-retry/dist-es/constants.js"() {
    "use strict";
    DEFAULT_RETRY_DELAY_BASE = 100;
    MAXIMUM_RETRY_DELAY = 20 * 1e3;
    THROTTLING_RETRY_DELAY_BASE = 500;
    INITIAL_RETRY_TOKENS = 500;
    RETRY_COST = 5;
    TIMEOUT_RETRY_COST = 10;
    NO_RETRY_INCREMENT = 1;
    INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
    REQUEST_HEADER = "amz-sdk-request";
  }
});

// ../../node_modules/@aws-sdk/util-retry/dist-es/defaultRetryBackoffStrategy.js
var getDefaultRetryBackoffStrategy;
var init_defaultRetryBackoffStrategy = __esm({
  "../../node_modules/@aws-sdk/util-retry/dist-es/defaultRetryBackoffStrategy.js"() {
    "use strict";
    init_constants2();
    getDefaultRetryBackoffStrategy = () => {
      let delayBase = DEFAULT_RETRY_DELAY_BASE;
      const computeNextBackoffDelay = (attempts) => {
        return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
      };
      const setDelayBase = (delay) => {
        delayBase = delay;
      };
      return {
        computeNextBackoffDelay,
        setDelayBase
      };
    };
  }
});

// ../../node_modules/@aws-sdk/util-retry/dist-es/defaultRetryToken.js
var getDefaultRetryToken;
var init_defaultRetryToken = __esm({
  "../../node_modules/@aws-sdk/util-retry/dist-es/defaultRetryToken.js"() {
    "use strict";
    init_constants2();
    init_defaultRetryBackoffStrategy();
    getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {
      const MAX_CAPACITY = initialRetryTokens;
      const retryCost = options?.retryCost ?? RETRY_COST;
      const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;
      const retryBackoffStrategy = options?.retryBackoffStrategy ?? getDefaultRetryBackoffStrategy();
      let availableCapacity = initialRetryTokens;
      let retryDelay = Math.min(MAXIMUM_RETRY_DELAY, initialRetryDelay);
      let lastRetryCost = void 0;
      let retryCount = initialRetryCount ?? 0;
      const getCapacityAmount = (errorType) => errorType === "TRANSIENT" ? timeoutRetryCost : retryCost;
      const getRetryCount = () => retryCount;
      const getRetryDelay = () => retryDelay;
      const getLastRetryCost = () => lastRetryCost;
      const hasRetryTokens = (errorType) => getCapacityAmount(errorType) <= availableCapacity;
      const getRetryTokenCount = (errorInfo) => {
        const errorType = errorInfo.errorType;
        if (!hasRetryTokens(errorType)) {
          throw new Error("No retry token available");
        }
        const capacityAmount = getCapacityAmount(errorType);
        const delayBase = errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE;
        retryBackoffStrategy.setDelayBase(delayBase);
        const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);
        if (errorInfo.retryAfterHint) {
          const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();
          retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);
        } else {
          retryDelay = delayFromErrorType;
        }
        retryCount++;
        lastRetryCost = capacityAmount;
        availableCapacity -= capacityAmount;
        return capacityAmount;
      };
      const releaseRetryTokens = (releaseAmount) => {
        availableCapacity += releaseAmount ?? NO_RETRY_INCREMENT;
        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
      };
      return {
        getRetryCount,
        getRetryDelay,
        getLastRetryCost,
        hasRetryTokens,
        getRetryTokenCount,
        releaseRetryTokens
      };
    };
  }
});

// ../../node_modules/@aws-sdk/util-retry/dist-es/StandardRetryStrategy.js
var StandardRetryStrategy;
var init_StandardRetryStrategy = __esm({
  "../../node_modules/@aws-sdk/util-retry/dist-es/StandardRetryStrategy.js"() {
    "use strict";
    init_config2();
    init_constants2();
    init_defaultRetryToken();
    StandardRetryStrategy = class {
      constructor(maxAttemptsProvider) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = RETRY_MODES.STANDARD;
        this.retryToken = getDefaultRetryToken(INITIAL_RETRY_TOKENS, DEFAULT_RETRY_DELAY_BASE);
        this.maxAttemptsProvider = maxAttemptsProvider;
      }
      async acquireInitialRetryToken(retryTokenScope) {
        return this.retryToken;
      }
      async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {
          tokenToRenew.getRetryTokenCount(errorInfo);
          return tokenToRenew;
        }
        throw new Error("No retry token available");
      }
      recordSuccess(token) {
        this.retryToken.releaseRetryTokens(token.getLastRetryCost());
      }
      async getMaxAttempts() {
        let maxAttempts;
        try {
          return await this.maxAttemptsProvider();
        } catch (error) {
          console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
          return DEFAULT_MAX_ATTEMPTS;
        }
      }
      shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount();
        return attempts < maxAttempts && tokenToRenew.hasRetryTokens(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
      }
      isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
      }
    };
  }
});

// ../../node_modules/@aws-sdk/util-retry/dist-es/AdaptiveRetryStrategy.js
var AdaptiveRetryStrategy;
var init_AdaptiveRetryStrategy = __esm({
  "../../node_modules/@aws-sdk/util-retry/dist-es/AdaptiveRetryStrategy.js"() {
    "use strict";
    init_config2();
    init_DefaultRateLimiter();
    init_StandardRetryStrategy();
    AdaptiveRetryStrategy = class {
      constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = RETRY_MODES.ADAPTIVE;
        const { rateLimiter } = options ?? {};
        this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
      }
      async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
      }
      async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
      }
      recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/util-retry/dist-es/types.js
var init_types2 = __esm({
  "../../node_modules/@aws-sdk/util-retry/dist-es/types.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/util-retry/dist-es/index.js
var init_dist_es14 = __esm({
  "../../node_modules/@aws-sdk/util-retry/dist-es/index.js"() {
    "use strict";
    init_AdaptiveRetryStrategy();
    init_DefaultRateLimiter();
    init_StandardRetryStrategy();
    init_config2();
    init_constants2();
    init_types2();
  }
});

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/defaultRetryQuota.js
var init_defaultRetryQuota = __esm({
  "../../node_modules/@aws-sdk/middleware-retry/dist-es/defaultRetryQuota.js"() {
    "use strict";
    init_dist_es14();
  }
});

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/delayDecider.js
var init_delayDecider = __esm({
  "../../node_modules/@aws-sdk/middleware-retry/dist-es/delayDecider.js"() {
    "use strict";
    init_dist_es14();
  }
});

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/retryDecider.js
var init_retryDecider = __esm({
  "../../node_modules/@aws-sdk/middleware-retry/dist-es/retryDecider.js"() {
    "use strict";
    init_dist_es13();
  }
});

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/util.js
var asSdkError;
var init_util = __esm({
  "../../node_modules/@aws-sdk/middleware-retry/dist-es/util.js"() {
    "use strict";
    asSdkError = (error) => {
      if (error instanceof Error)
        return error;
      if (error instanceof Object)
        return Object.assign(new Error(), error);
      if (typeof error === "string")
        return new Error(error);
      return new Error(`AWS SDK error wrapper for ${error}`);
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/StandardRetryStrategy.js
var init_StandardRetryStrategy2 = __esm({
  "../../node_modules/@aws-sdk/middleware-retry/dist-es/StandardRetryStrategy.js"() {
    "use strict";
    init_dist_es4();
    init_dist_es13();
    init_dist_es14();
    init_defaultRetryQuota();
    init_delayDecider();
    init_retryDecider();
    init_util();
  }
});

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/AdaptiveRetryStrategy.js
var init_AdaptiveRetryStrategy2 = __esm({
  "../../node_modules/@aws-sdk/middleware-retry/dist-es/AdaptiveRetryStrategy.js"() {
    "use strict";
    init_dist_es14();
    init_StandardRetryStrategy2();
  }
});

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/configurations.js
var ENV_MAX_ATTEMPTS, CONFIG_MAX_ATTEMPTS, NODE_MAX_ATTEMPT_CONFIG_OPTIONS, resolveRetryConfig, ENV_RETRY_MODE, CONFIG_RETRY_MODE, NODE_RETRY_MODE_CONFIG_OPTIONS;
var init_configurations = __esm({
  "../../node_modules/@aws-sdk/middleware-retry/dist-es/configurations.js"() {
    "use strict";
    init_dist_es2();
    init_dist_es14();
    ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
    CONFIG_MAX_ATTEMPTS = "max_attempts";
    NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
      environmentVariableSelector: (env3) => {
        const value = env3[ENV_MAX_ATTEMPTS];
        if (!value)
          return void 0;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
          throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
      },
      configFileSelector: (profile) => {
        const value = profile[CONFIG_MAX_ATTEMPTS];
        if (!value)
          return void 0;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
          throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
      },
      default: DEFAULT_MAX_ATTEMPTS
    };
    resolveRetryConfig = (input) => {
      const { retryStrategy } = input;
      const maxAttempts = normalizeProvider(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
      return {
        ...input,
        maxAttempts,
        retryStrategy: async () => {
          if (retryStrategy) {
            return retryStrategy;
          }
          const retryMode = await normalizeProvider(input.retryMode)();
          if (retryMode === RETRY_MODES.ADAPTIVE) {
            return new AdaptiveRetryStrategy(maxAttempts);
          }
          return new StandardRetryStrategy(maxAttempts);
        }
      };
    };
    ENV_RETRY_MODE = "AWS_RETRY_MODE";
    CONFIG_RETRY_MODE = "retry_mode";
    NODE_RETRY_MODE_CONFIG_OPTIONS = {
      environmentVariableSelector: (env3) => env3[ENV_RETRY_MODE],
      configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
      default: DEFAULT_RETRY_MODE
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/omitRetryHeadersMiddleware.js
var init_omitRetryHeadersMiddleware = __esm({
  "../../node_modules/@aws-sdk/middleware-retry/dist-es/omitRetryHeadersMiddleware.js"() {
    "use strict";
    init_dist_es4();
    init_dist_es14();
  }
});

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware, isRetryStrategyV2, getRetyErrorInto, getRetryErrorType, retryMiddlewareOptions, getRetryPlugin, getRetryAfterHint;
var init_retryMiddleware = __esm({
  "../../node_modules/@aws-sdk/middleware-retry/dist-es/retryMiddleware.js"() {
    "use strict";
    init_dist_es4();
    init_dist_es13();
    init_dist_es14();
    init_esm_node();
    init_util();
    retryMiddleware = (options) => (next, context) => async (args) => {
      let retryStrategy = await options.retryStrategy();
      const maxAttempts = await options.maxAttempts();
      if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request: request3 } = args;
        if (HttpRequest.isInstance(request3)) {
          request3.headers[INVOCATION_ID_HEADER] = v4_default();
        }
        while (true) {
          try {
            if (HttpRequest.isInstance(request3)) {
              request3.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
            }
            const { response, output } = await next(args);
            retryStrategy.recordSuccess(retryToken);
            output.$metadata.attempts = attempts + 1;
            output.$metadata.totalRetryDelay = totalRetryDelay;
            return { response, output };
          } catch (e10) {
            const retryErrorInfo = getRetyErrorInto(e10);
            lastError = asSdkError(e10);
            try {
              retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
            } catch (refreshError) {
              if (!lastError.$metadata) {
                lastError.$metadata = {};
              }
              lastError.$metadata.attempts = attempts + 1;
              lastError.$metadata.totalRetryDelay = totalRetryDelay;
              throw lastError;
            }
            attempts = retryToken.getRetryCount();
            const delay = retryToken.getRetryDelay();
            totalRetryDelay += delay;
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      } else {
        retryStrategy = retryStrategy;
        if (retryStrategy?.mode)
          context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
      }
    };
    isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
    getRetyErrorInto = (error) => {
      const errorInfo = {
        errorType: getRetryErrorType(error)
      };
      const retryAfterHint = getRetryAfterHint(error.$response);
      if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
      }
      return errorInfo;
    };
    getRetryErrorType = (error) => {
      if (isThrottlingError(error))
        return "THROTTLING";
      if (isTransientError(error))
        return "TRANSIENT";
      if (isServerError(error))
        return "SERVER_ERROR";
      return "CLIENT_ERROR";
    };
    retryMiddlewareOptions = {
      name: "retryMiddleware",
      tags: ["RETRY"],
      step: "finalizeRequest",
      priority: "high",
      override: true
    };
    getRetryPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
      }
    });
    getRetryAfterHint = (response) => {
      if (!HttpResponse.isInstance(response))
        return;
      const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
      if (!retryAfterHeaderName)
        return;
      const retryAfter = response.headers[retryAfterHeaderName];
      const retryAfterSeconds = Number(retryAfter);
      if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1e3);
      const retryAfterDate = new Date(retryAfter);
      return retryAfterDate;
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-retry/dist-es/index.js
var init_dist_es15 = __esm({
  "../../node_modules/@aws-sdk/middleware-retry/dist-es/index.js"() {
    "use strict";
    init_AdaptiveRetryStrategy2();
    init_StandardRetryStrategy2();
    init_configurations();
    init_delayDecider();
    init_omitRetryHeadersMiddleware();
    init_retryDecider();
    init_retryMiddleware();
  }
});

// ../../node_modules/@aws-sdk/property-provider/dist-es/ProviderError.js
var ProviderError;
var init_ProviderError = __esm({
  "../../node_modules/@aws-sdk/property-provider/dist-es/ProviderError.js"() {
    "use strict";
    ProviderError = class _ProviderError extends Error {
      constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, _ProviderError.prototype);
      }
      static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/property-provider/dist-es/CredentialsProviderError.js
var CredentialsProviderError;
var init_CredentialsProviderError = __esm({
  "../../node_modules/@aws-sdk/property-provider/dist-es/CredentialsProviderError.js"() {
    "use strict";
    init_ProviderError();
    CredentialsProviderError = class _CredentialsProviderError extends ProviderError {
      constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, _CredentialsProviderError.prototype);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/property-provider/dist-es/TokenProviderError.js
var TokenProviderError;
var init_TokenProviderError = __esm({
  "../../node_modules/@aws-sdk/property-provider/dist-es/TokenProviderError.js"() {
    "use strict";
    init_ProviderError();
    TokenProviderError = class _TokenProviderError extends ProviderError {
      constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, _TokenProviderError.prototype);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/property-provider/dist-es/chain.js
function chain(...providers) {
  return () => {
    let promise = Promise.reject(new ProviderError("No providers in chain"));
    for (const provider of providers) {
      promise = promise.catch((err) => {
        if (err?.tryNextLink) {
          return provider();
        }
        throw err;
      });
    }
    return promise;
  };
}
var init_chain = __esm({
  "../../node_modules/@aws-sdk/property-provider/dist-es/chain.js"() {
    "use strict";
    init_ProviderError();
  }
});

// ../../node_modules/@aws-sdk/property-provider/dist-es/fromStatic.js
var fromStatic;
var init_fromStatic = __esm({
  "../../node_modules/@aws-sdk/property-provider/dist-es/fromStatic.js"() {
    "use strict";
    fromStatic = (staticValue) => () => Promise.resolve(staticValue);
  }
});

// ../../node_modules/@aws-sdk/property-provider/dist-es/memoize.js
var memoize;
var init_memoize = __esm({
  "../../node_modules/@aws-sdk/property-provider/dist-es/memoize.js"() {
    "use strict";
    memoize = (provider, isExpired, requiresRefresh) => {
      let resolved;
      let pending;
      let hasResult;
      let isConstant = false;
      const coalesceProvider = async () => {
        if (!pending) {
          pending = provider();
        }
        try {
          resolved = await pending;
          hasResult = true;
          isConstant = false;
        } finally {
          pending = void 0;
        }
        return resolved;
      };
      if (isExpired === void 0) {
        return async (options) => {
          if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
          }
          return resolved;
        };
      }
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider();
        }
        if (isConstant) {
          return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
          isConstant = true;
          return resolved;
        }
        if (isExpired(resolved)) {
          await coalesceProvider();
          return resolved;
        }
        return resolved;
      };
    };
  }
});

// ../../node_modules/@aws-sdk/property-provider/dist-es/index.js
var init_dist_es16 = __esm({
  "../../node_modules/@aws-sdk/property-provider/dist-es/index.js"() {
    "use strict";
    init_CredentialsProviderError();
    init_ProviderError();
    init_TokenProviderError();
    init_chain();
    init_fromStatic();
    init_memoize();
  }
});

// ../../node_modules/@aws-sdk/util-hex-encoding/dist-es/index.js
function toHex(bytes) {
  let out = "";
  for (let i10 = 0; i10 < bytes.byteLength; i10++) {
    out += SHORT_TO_HEX[bytes[i10]];
  }
  return out;
}
var SHORT_TO_HEX, HEX_TO_SHORT;
var init_dist_es17 = __esm({
  "../../node_modules/@aws-sdk/util-hex-encoding/dist-es/index.js"() {
    "use strict";
    SHORT_TO_HEX = {};
    HEX_TO_SHORT = {};
    for (let i10 = 0; i10 < 256; i10++) {
      let encodedByte = i10.toString(16).toLowerCase();
      if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
      }
      SHORT_TO_HEX[i10] = encodedByte;
      HEX_TO_SHORT[encodedByte] = i10;
    }
  }
});

// ../../node_modules/@aws-sdk/is-array-buffer/dist-es/index.js
var isArrayBuffer;
var init_dist_es18 = __esm({
  "../../node_modules/@aws-sdk/is-array-buffer/dist-es/index.js"() {
    "use strict";
    isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
  }
});

// ../../node_modules/@aws-sdk/util-buffer-from/dist-es/index.js
var import_buffer, fromArrayBuffer, fromString;
var init_dist_es19 = __esm({
  "../../node_modules/@aws-sdk/util-buffer-from/dist-es/index.js"() {
    "use strict";
    init_dist_es18();
    import_buffer = require("buffer");
    fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
      if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
      }
      return import_buffer.Buffer.from(input, offset, length);
    };
    fromString = (input, encoding) => {
      if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
      }
      return encoding ? import_buffer.Buffer.from(input, encoding) : import_buffer.Buffer.from(input);
    };
  }
});

// ../../node_modules/@aws-sdk/util-utf8/dist-es/fromUtf8.js
var fromUtf8;
var init_fromUtf8 = __esm({
  "../../node_modules/@aws-sdk/util-utf8/dist-es/fromUtf8.js"() {
    "use strict";
    init_dist_es19();
    fromUtf8 = (input) => {
      const buf = fromString(input, "utf8");
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    };
  }
});

// ../../node_modules/@aws-sdk/util-utf8/dist-es/toUint8Array.js
var toUint8Array;
var init_toUint8Array = __esm({
  "../../node_modules/@aws-sdk/util-utf8/dist-es/toUint8Array.js"() {
    "use strict";
    init_fromUtf8();
    toUint8Array = (data) => {
      if (typeof data === "string") {
        return fromUtf8(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    };
  }
});

// ../../node_modules/@aws-sdk/util-utf8/dist-es/toUtf8.js
var toUtf8;
var init_toUtf8 = __esm({
  "../../node_modules/@aws-sdk/util-utf8/dist-es/toUtf8.js"() {
    "use strict";
    init_dist_es19();
    toUtf8 = (input) => fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
  }
});

// ../../node_modules/@aws-sdk/util-utf8/dist-es/index.js
var init_dist_es20 = __esm({
  "../../node_modules/@aws-sdk/util-utf8/dist-es/index.js"() {
    "use strict";
    init_fromUtf8();
    init_toUint8Array();
    init_toUtf8();
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/constants.js
var ALGORITHM_QUERY_PARAM, CREDENTIAL_QUERY_PARAM, AMZ_DATE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, EXPIRES_QUERY_PARAM, SIGNATURE_QUERY_PARAM, TOKEN_QUERY_PARAM, AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER, GENERATED_HEADERS, SIGNATURE_HEADER, SHA256_HEADER, TOKEN_HEADER, ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN, ALGORITHM_IDENTIFIER, EVENT_ALGORITHM_IDENTIFIER, UNSIGNED_PAYLOAD, MAX_CACHE_SIZE, KEY_TYPE_IDENTIFIER, MAX_PRESIGNED_TTL;
var init_constants3 = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/constants.js"() {
    "use strict";
    ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
    CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
    AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
    SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
    EXPIRES_QUERY_PARAM = "X-Amz-Expires";
    SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
    TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
    AUTH_HEADER = "authorization";
    AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
    DATE_HEADER = "date";
    GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
    SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
    SHA256_HEADER = "x-amz-content-sha256";
    TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
    ALWAYS_UNSIGNABLE_HEADERS = {
      authorization: true,
      "cache-control": true,
      connection: true,
      expect: true,
      from: true,
      "keep-alive": true,
      "max-forwards": true,
      pragma: true,
      referer: true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true,
      "user-agent": true,
      "x-amzn-trace-id": true
    };
    PROXY_HEADER_PATTERN = /^proxy-/;
    SEC_HEADER_PATTERN = /^sec-/;
    ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
    EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
    UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
    MAX_CACHE_SIZE = 50;
    KEY_TYPE_IDENTIFIER = "aws4_request";
    MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/credentialDerivation.js
var signingKeyCache, cacheQueue, createScope, getSigningKey, hmac2;
var init_credentialDerivation = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/credentialDerivation.js"() {
    "use strict";
    init_dist_es17();
    init_dist_es20();
    init_constants3();
    signingKeyCache = {};
    cacheQueue = [];
    createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
    getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
      const credsHash = await hmac2(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
      const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
      if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
      }
      cacheQueue.push(cacheKey);
      while (cacheQueue.length > MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
      }
      let key = `AWS4${credentials.secretAccessKey}`;
      for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
        key = await hmac2(sha256Constructor, key, signable);
      }
      return signingKeyCache[cacheKey] = key;
    };
    hmac2 = (ctor, secret, data) => {
      const hash2 = new ctor(secret);
      hash2.update(toUint8Array(data));
      return hash2.digest();
    };
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/getCanonicalHeaders.js
var getCanonicalHeaders;
var init_getCanonicalHeaders = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/getCanonicalHeaders.js"() {
    "use strict";
    init_constants3();
    getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
      const canonical = {};
      for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == void 0) {
          continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
          if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
            continue;
          }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
      }
      return canonical;
    };
  }
});

// ../../node_modules/@aws-sdk/util-uri-escape/dist-es/escape-uri.js
var escapeUri, hexEncode;
var init_escape_uri = __esm({
  "../../node_modules/@aws-sdk/util-uri-escape/dist-es/escape-uri.js"() {
    "use strict";
    escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
    hexEncode = (c10) => `%${c10.charCodeAt(0).toString(16).toUpperCase()}`;
  }
});

// ../../node_modules/@aws-sdk/util-uri-escape/dist-es/escape-uri-path.js
var init_escape_uri_path = __esm({
  "../../node_modules/@aws-sdk/util-uri-escape/dist-es/escape-uri-path.js"() {
    "use strict";
    init_escape_uri();
  }
});

// ../../node_modules/@aws-sdk/util-uri-escape/dist-es/index.js
var init_dist_es21 = __esm({
  "../../node_modules/@aws-sdk/util-uri-escape/dist-es/index.js"() {
    "use strict";
    init_escape_uri();
    init_escape_uri_path();
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/getCanonicalQuery.js
var getCanonicalQuery;
var init_getCanonicalQuery = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/getCanonicalQuery.js"() {
    "use strict";
    init_dist_es21();
    init_constants3();
    getCanonicalQuery = ({ query = {} }) => {
      const keys = [];
      const serialized = {};
      for (const key of Object.keys(query).sort()) {
        if (key.toLowerCase() === SIGNATURE_HEADER) {
          continue;
        }
        keys.push(key);
        const value = query[key];
        if (typeof value === "string") {
          serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
        } else if (Array.isArray(value)) {
          serialized[key] = value.slice(0).sort().reduce((encoded, value2) => encoded.concat([`${escapeUri(key)}=${escapeUri(value2)}`]), []).join("&");
        }
      }
      return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
    };
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash;
var init_getPayloadHash = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/getPayloadHash.js"() {
    "use strict";
    init_dist_es18();
    init_dist_es17();
    init_dist_es20();
    init_constants3();
    getPayloadHash = async ({ headers, body }, hashConstructor) => {
      for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === SHA256_HEADER) {
          return headers[headerName];
        }
      }
      if (body == void 0) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update(toUint8Array(body));
        return toHex(await hashCtor.digest());
      }
      return UNSIGNED_PAYLOAD;
    };
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/headerUtil.js
var hasHeader;
var init_headerUtil = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/headerUtil.js"() {
    "use strict";
    hasHeader = (soughtHeader, headers) => {
      soughtHeader = soughtHeader.toLowerCase();
      for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
          return true;
        }
      }
      return false;
    };
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/cloneRequest.js
var cloneRequest, cloneQuery2;
var init_cloneRequest = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/cloneRequest.js"() {
    "use strict";
    cloneRequest = ({ headers, query, ...rest }) => ({
      ...rest,
      headers: { ...headers },
      query: query ? cloneQuery2(query) : void 0
    });
    cloneQuery2 = (query) => Object.keys(query).reduce((carry, paramName) => {
      const param = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param
      };
    }, {});
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/moveHeadersToQuery.js
var moveHeadersToQuery;
var init_moveHeadersToQuery = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/moveHeadersToQuery.js"() {
    "use strict";
    init_cloneRequest();
    moveHeadersToQuery = (request3, options = {}) => {
      const { headers, query = {} } = typeof request3.clone === "function" ? request3.clone() : cloneRequest(request3);
      for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
          query[name] = headers[name];
          delete headers[name];
        }
      }
      return {
        ...request3,
        headers,
        query
      };
    };
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/prepareRequest.js
var prepareRequest;
var init_prepareRequest = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/prepareRequest.js"() {
    "use strict";
    init_cloneRequest();
    init_constants3();
    prepareRequest = (request3) => {
      request3 = typeof request3.clone === "function" ? request3.clone() : cloneRequest(request3);
      for (const headerName of Object.keys(request3.headers)) {
        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
          delete request3.headers[headerName];
        }
      }
      return request3;
    };
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/utilDate.js
var iso8601, toDate;
var init_utilDate = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/utilDate.js"() {
    "use strict";
    iso8601 = (time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z");
    toDate = (time) => {
      if (typeof time === "number") {
        return new Date(time * 1e3);
      }
      if (typeof time === "string") {
        if (Number(time)) {
          return new Date(Number(time) * 1e3);
        }
        return new Date(time);
      }
      return time;
    };
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/SignatureV4.js
var SignatureV4, formatDate, getCanonicalHeaderList;
var init_SignatureV4 = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/SignatureV4.js"() {
    "use strict";
    init_dist_es17();
    init_dist_es2();
    init_dist_es20();
    init_constants3();
    init_credentialDerivation();
    init_getCanonicalHeaders();
    init_getCanonicalQuery();
    init_getPayloadHash();
    init_headerUtil();
    init_moveHeadersToQuery();
    init_prepareRequest();
    init_utilDate();
    SignatureV4 = class {
      constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = normalizeProvider(region);
        this.credentialProvider = normalizeProvider(credentials);
      }
      async presign(originalRequest, options = {}) {
        const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { longDate, shortDate } = formatDate(signingDate);
        if (expiresIn > MAX_PRESIGNED_TTL) {
          return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        }
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const request3 = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
        if (credentials.sessionToken) {
          request3.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request3.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
        request3.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request3.query[AMZ_DATE_QUERY_PARAM] = longDate;
        request3.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = getCanonicalHeaders(request3, unsignableHeaders, signableHeaders);
        request3.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request3.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request3, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
        return request3;
      }
      async sign(toSign, options) {
        if (typeof toSign === "string") {
          return this.signString(toSign, options);
        } else if (toSign.headers && toSign.payload) {
          return this.signEvent(toSign, options);
        } else {
          return this.signRequest(toSign, options);
        }
      }
      async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate, longDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
        const hash2 = new this.sha256();
        hash2.update(headers);
        const hashedHeaders = toHex(await hash2.digest());
        const stringToSign = [
          EVENT_ALGORITHM_IDENTIFIER,
          longDate,
          scope,
          priorSignature,
          hashedHeaders,
          hashedPayload
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
      }
      async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate } = formatDate(signingDate);
        const hash2 = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash2.update(toUint8Array(stringToSign));
        return toHex(await hash2.digest());
      }
      async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const request3 = prepareRequest(requestToSign);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        request3.headers[AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
          request3.headers[TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await getPayloadHash(request3, this.sha256);
        if (!hasHeader(SHA256_HEADER, request3.headers) && this.applyChecksum) {
          request3.headers[SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders(request3, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request3, canonicalHeaders, payloadHash));
        request3.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
        return request3;
      }
      createCanonicalRequest(request3, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request3.method}
${this.getCanonicalPath(request3)}
${getCanonicalQuery(request3)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
      }
      async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash2 = new this.sha256();
        hash2.update(toUint8Array(canonicalRequest));
        const hashedRequest = await hash2.digest();
        return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
      }
      getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
          const normalizedPathSegments = [];
          for (const pathSegment of path.split("/")) {
            if (pathSegment?.length === 0)
              continue;
            if (pathSegment === ".")
              continue;
            if (pathSegment === "..") {
              normalizedPathSegments.pop();
            } else {
              normalizedPathSegments.push(pathSegment);
            }
          }
          const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
          const doubleEncoded = encodeURIComponent(normalizedPath);
          return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
      }
      async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash2 = new this.sha256(await keyPromise);
        hash2.update(toUint8Array(stringToSign));
        return toHex(await hash2.digest());
      }
      getSigningKey(credentials, region, shortDate, service) {
        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
      }
      validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
          throw new Error("Resolved credential object is not valid");
        }
      }
    };
    formatDate = (now) => {
      const longDate = iso8601(now).replace(/[\-:]/g, "");
      return {
        longDate,
        shortDate: longDate.slice(0, 8)
      };
    };
    getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");
  }
});

// ../../node_modules/@aws-sdk/signature-v4/dist-es/index.js
var init_dist_es22 = __esm({
  "../../node_modules/@aws-sdk/signature-v4/dist-es/index.js"() {
    "use strict";
    init_SignatureV4();
    init_getCanonicalHeaders();
    init_getCanonicalQuery();
    init_getPayloadHash();
    init_moveHeadersToQuery();
    init_prepareRequest();
    init_credentialDerivation();
  }
});

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/configurations.js
var CREDENTIAL_EXPIRE_WINDOW, resolveAwsAuthConfig, normalizeCredentialProvider;
var init_configurations2 = __esm({
  "../../node_modules/@aws-sdk/middleware-signing/dist-es/configurations.js"() {
    "use strict";
    init_dist_es16();
    init_dist_es22();
    init_dist_es2();
    CREDENTIAL_EXPIRE_WINDOW = 3e5;
    resolveAwsAuthConfig = (input) => {
      const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
      const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
      let signer;
      if (input.signer) {
        signer = normalizeProvider(input.signer);
      } else if (input.regionInfoProvider) {
        signer = () => normalizeProvider(input.region)().then(async (region) => [
          await input.regionInfoProvider(region, {
            useFipsEndpoint: await input.useFipsEndpoint(),
            useDualstackEndpoint: await input.useDualstackEndpoint()
          }) || {},
          region
        ]).then(([regionInfo, region]) => {
          const { signingRegion, signingService } = regionInfo;
          input.signingRegion = input.signingRegion || signingRegion || region;
          input.signingName = input.signingName || signingService || input.serviceId;
          const params = {
            ...input,
            credentials: normalizedCreds,
            region: input.signingRegion,
            service: input.signingName,
            sha256,
            uriEscapePath: signingEscapePath
          };
          const SignerCtor = input.signerConstructor || SignatureV4;
          return new SignerCtor(params);
        });
      } else {
        signer = async (authScheme) => {
          authScheme = Object.assign({}, {
            name: "sigv4",
            signingName: input.signingName || input.defaultSigningName,
            signingRegion: await normalizeProvider(input.region)(),
            properties: {}
          }, authScheme);
          const signingRegion = authScheme.signingRegion;
          const signingService = authScheme.signingName;
          input.signingRegion = input.signingRegion || signingRegion;
          input.signingName = input.signingName || signingService || input.serviceId;
          const params = {
            ...input,
            credentials: normalizedCreds,
            region: input.signingRegion,
            service: input.signingName,
            sha256,
            uriEscapePath: signingEscapePath
          };
          const SignerCtor = input.signerConstructor || SignatureV4;
          return new SignerCtor(params);
        };
      }
      return {
        ...input,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer
      };
    };
    normalizeCredentialProvider = (credentials) => {
      if (typeof credentials === "function") {
        return memoize(credentials, (credentials2) => credentials2.expiration !== void 0 && credentials2.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials2) => credentials2.expiration !== void 0);
      }
      return normalizeProvider(credentials);
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate;
var init_getSkewCorrectedDate = __esm({
  "../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js"() {
    "use strict";
    getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
  }
});

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js
var isClockSkewed;
var init_isClockSkewed = __esm({
  "../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js"() {
    "use strict";
    init_getSkewCorrectedDate();
    isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;
  }
});

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset;
var init_getUpdatedSystemClockOffset = __esm({
  "../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js"() {
    "use strict";
    init_isClockSkewed();
    getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
      const clockTimeInMs = Date.parse(clockTime);
      if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
      }
      return currentSystemClockOffset;
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/middleware.js
var awsAuthMiddleware, getDateHeader, awsAuthMiddlewareOptions, getAwsAuthPlugin;
var init_middleware = __esm({
  "../../node_modules/@aws-sdk/middleware-signing/dist-es/middleware.js"() {
    "use strict";
    init_dist_es4();
    init_getSkewCorrectedDate();
    init_getUpdatedSystemClockOffset();
    awsAuthMiddleware = (options) => (next, context) => async function(args) {
      if (!HttpRequest.isInstance(args.request))
        return next(args);
      const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
      const multiRegionOverride = authScheme?.name === "sigv4a" ? authScheme?.signingRegionSet?.join(",") : void 0;
      const signer = await options.signer(authScheme);
      const output = await next({
        ...args,
        request: await signer.sign(args.request, {
          signingDate: getSkewCorrectedDate(options.systemClockOffset),
          signingRegion: multiRegionOverride || context["signing_region"],
          signingService: context["signing_service"]
        })
      }).catch((error) => {
        const serverTime = error.ServerTime ?? getDateHeader(error.$response);
        if (serverTime) {
          options.systemClockOffset = getUpdatedSystemClockOffset(serverTime, options.systemClockOffset);
        }
        throw error;
      });
      const dateHeader = getDateHeader(output.response);
      if (dateHeader) {
        options.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, options.systemClockOffset);
      }
      return output;
    };
    getDateHeader = (response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0;
    awsAuthMiddlewareOptions = {
      name: "awsAuthMiddleware",
      tags: ["SIGNATURE", "AWSAUTH"],
      relation: "after",
      toMiddleware: "retryMiddleware",
      override: true
    };
    getAwsAuthPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(awsAuthMiddleware(options), awsAuthMiddlewareOptions);
      }
    });
  }
});

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/index.js
var init_dist_es23 = __esm({
  "../../node_modules/@aws-sdk/middleware-signing/dist-es/index.js"() {
    "use strict";
    init_configurations2();
    init_middleware();
  }
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function resolveUserAgentConfig(input) {
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
  };
}
var init_configurations3 = __esm({
  "../../node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT, X_AMZ_USER_AGENT, SPACE, UA_ESCAPE_REGEX;
var init_constants4 = __esm({
  "../../node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js"() {
    "use strict";
    USER_AGENT = "user-agent";
    X_AMZ_USER_AGENT = "x-amz-user-agent";
    SPACE = " ";
    UA_ESCAPE_REGEX = /[^\!\#\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
  }
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware, escapeUserAgent, getUserAgentMiddlewareOptions, getUserAgentPlugin;
var init_user_agent_middleware = __esm({
  "../../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js"() {
    "use strict";
    init_dist_es4();
    init_constants4();
    userAgentMiddleware = (options) => (next, context) => async (args) => {
      const { request: request3 } = args;
      if (!HttpRequest.isInstance(request3))
        return next(args);
      const { headers } = request3;
      const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
      const defaultUserAgent3 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
      const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
      const sdkUserAgentValue = [...defaultUserAgent3, ...userAgent, ...customUserAgent].join(SPACE);
      const normalUAValue = [
        ...defaultUserAgent3.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent
      ].join(SPACE);
      if (options.runtime !== "browser") {
        if (normalUAValue) {
          headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
        }
        headers[USER_AGENT] = sdkUserAgentValue;
      } else {
        headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
      }
      return next({
        ...args,
        request: request3
      });
    };
    escapeUserAgent = ([name, version]) => {
      const prefixSeparatorIndex = name.indexOf("/");
      const prefix = name.substring(0, prefixSeparatorIndex);
      let uaName = name.substring(prefixSeparatorIndex + 1);
      if (prefix === "api") {
        uaName = uaName.toLowerCase();
      }
      return [prefix, uaName, version].filter((item) => item && item.length > 0).map((item) => item?.replace(UA_ESCAPE_REGEX, "_")).join("/");
    };
    getUserAgentMiddlewareOptions = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: true
    };
    getUserAgentPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
      }
    });
  }
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js
var init_dist_es24 = __esm({
  "../../node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js"() {
    "use strict";
    init_configurations3();
    init_user_agent_middleware();
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/NoOpLogger.js
var NoOpLogger;
var init_NoOpLogger = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/NoOpLogger.js"() {
    "use strict";
    NoOpLogger = class {
      trace() {
      }
      debug() {
      }
      info() {
      }
      warn() {
      }
      error() {
      }
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-stack/dist-es/MiddlewareStack.js
var constructStack, stepWeights, priorityWeights;
var init_MiddlewareStack = __esm({
  "../../node_modules/@aws-sdk/middleware-stack/dist-es/MiddlewareStack.js"() {
    "use strict";
    constructStack = () => {
      let absoluteEntries = [];
      let relativeEntries = [];
      const entriesNameSet = /* @__PURE__ */ new Set();
      const sort = (entries) => entries.sort((a10, b10) => stepWeights[b10.step] - stepWeights[a10.step] || priorityWeights[b10.priority || "normal"] - priorityWeights[a10.priority || "normal"]);
      const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          if (entry.name && entry.name === toRemove) {
            isRemoved = true;
            entriesNameSet.delete(toRemove);
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      };
      const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          if (entry.middleware === toRemove) {
            isRemoved = true;
            if (entry.name)
              entriesNameSet.delete(entry.name);
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      };
      const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
          toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
          toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        return toStack;
      };
      const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
          if (entry.before.length === 0 && entry.after.length === 0) {
            expandedMiddlewareList.push(entry);
          } else {
            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
          }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
          if (entry.before.length === 0 && entry.after.length === 0) {
            expandedMiddlewareList.push(entry);
          } else {
            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
          }
        });
        return expandedMiddlewareList;
      };
      const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
          const normalizedEntry = {
            ...entry,
            before: [],
            after: []
          };
          if (normalizedEntry.name)
            normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
          normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
          const normalizedEntry = {
            ...entry,
            before: [],
            after: []
          };
          if (normalizedEntry.name)
            normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
          normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
          if (entry.toMiddleware) {
            const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
            if (toMiddleware === void 0) {
              if (debug) {
                return;
              }
              throw new Error(`${entry.toMiddleware} is not found when adding ${entry.name || "anonymous"} middleware ${entry.relation} ${entry.toMiddleware}`);
            }
            if (entry.relation === "after") {
              toMiddleware.after.push(entry);
            }
            if (entry.relation === "before") {
              toMiddleware.before.push(entry);
            }
          }
        });
        const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expendedMiddlewareList) => {
          wholeList.push(...expendedMiddlewareList);
          return wholeList;
        }, []);
        return mainChain;
      };
      const stack = {
        add: (middleware, options = {}) => {
          const { name, override } = options;
          const entry = {
            step: "initialize",
            priority: "normal",
            middleware,
            ...options
          };
          if (name) {
            if (entriesNameSet.has(name)) {
              if (!override)
                throw new Error(`Duplicate middleware name '${name}'`);
              const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === name);
              const toOverride = absoluteEntries[toOverrideIndex];
              if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
                throw new Error(`"${name}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by same-name middleware with ${entry.priority} priority in ${entry.step} step.`);
              }
              absoluteEntries.splice(toOverrideIndex, 1);
            }
            entriesNameSet.add(name);
          }
          absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
          const { name, override } = options;
          const entry = {
            middleware,
            ...options
          };
          if (name) {
            if (entriesNameSet.has(name)) {
              if (!override)
                throw new Error(`Duplicate middleware name '${name}'`);
              const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === name);
              const toOverride = relativeEntries[toOverrideIndex];
              if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                throw new Error(`"${name}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by same-name middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
              }
              relativeEntries.splice(toOverrideIndex, 1);
            }
            entriesNameSet.add(name);
          }
          relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
          plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
          if (typeof toRemove === "string")
            return removeByName(toRemove);
          else
            return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
          let isRemoved = false;
          const filterCb = (entry) => {
            const { tags, name } = entry;
            if (tags && tags.includes(toRemove)) {
              if (name)
                entriesNameSet.delete(name);
              isRemoved = true;
              return false;
            }
            return true;
          };
          absoluteEntries = absoluteEntries.filter(filterCb);
          relativeEntries = relativeEntries.filter(filterCb);
          return isRemoved;
        },
        concat: (from) => {
          const cloned = cloneTo(constructStack());
          cloned.use(from);
          return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
          return getMiddlewareList(true).map((mw) => {
            return mw.name + ": " + (mw.tags || []).join(",");
          });
        },
        resolve: (handler, context) => {
          for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
            handler = middleware(handler, context);
          }
          return handler;
        }
      };
      return stack;
    };
    stepWeights = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1
    };
    priorityWeights = {
      high: 3,
      normal: 2,
      low: 1
    };
  }
});

// ../../node_modules/@aws-sdk/middleware-stack/dist-es/index.js
var init_dist_es25 = __esm({
  "../../node_modules/@aws-sdk/middleware-stack/dist-es/index.js"() {
    "use strict";
    init_MiddlewareStack();
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/client.js
var Client;
var init_client = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/client.js"() {
    "use strict";
    init_dist_es25();
    Client = class {
      constructor(config) {
        this.middlewareStack = constructStack();
        this.config = config;
      }
      send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
          handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
          });
        } else {
          return handler(command).then((result) => result.output);
        }
      }
      destroy() {
        if (this.config.requestHandler.destroy)
          this.config.requestHandler.destroy();
      }
    };
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/command.js
var Command;
var init_command = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/command.js"() {
    "use strict";
    init_dist_es25();
    Command = class {
      constructor() {
        this.middlewareStack = constructStack();
      }
    };
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/constants.js
var SENSITIVE_STRING;
var init_constants5 = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/constants.js"() {
    "use strict";
    SENSITIVE_STRING = "***SensitiveInformation***";
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/parse-utils.js
var parseBoolean, expectNumber, MAX_FLOAT, expectFloat32, expectLong, expectInt32, expectShort, expectByte, expectSizedInt, castInt, expectNonNull, expectObject, expectString, strictParseDouble, strictParseFloat32, NUMBER_REGEX, parseNumber, strictParseInt32, strictParseShort, strictParseByte, stackTraceWarning, logger;
var init_parse_utils = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/parse-utils.js"() {
    "use strict";
    parseBoolean = (value) => {
      switch (value) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(`Unable to parse boolean value "${value}"`);
      }
    };
    expectNumber = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
          if (String(parsed) !== String(value)) {
            logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
          }
          return parsed;
        }
      }
      if (typeof value === "number") {
        return value;
      }
      throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
    };
    MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
    expectFloat32 = (value) => {
      const expected = expectNumber(value);
      if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
          throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
      }
      return expected;
    };
    expectLong = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
      }
      throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
    };
    expectInt32 = (value) => expectSizedInt(value, 32);
    expectShort = (value) => expectSizedInt(value, 16);
    expectByte = (value) => expectSizedInt(value, 8);
    expectSizedInt = (value, size) => {
      const expected = expectLong(value);
      if (expected !== void 0 && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
      }
      return expected;
    };
    castInt = (value, size) => {
      switch (size) {
        case 32:
          return Int32Array.of(value)[0];
        case 16:
          return Int16Array.of(value)[0];
        case 8:
          return Int8Array.of(value)[0];
      }
    };
    expectNonNull = (value, location) => {
      if (value === null || value === void 0) {
        if (location) {
          throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
      }
      return value;
    };
    expectObject = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "object" && !Array.isArray(value)) {
        return value;
      }
      const receivedType = Array.isArray(value) ? "array" : typeof value;
      throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
    };
    expectString = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "string") {
        return value;
      }
      if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
      }
      throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
    };
    strictParseDouble = (value) => {
      if (typeof value == "string") {
        return expectNumber(parseNumber(value));
      }
      return expectNumber(value);
    };
    strictParseFloat32 = (value) => {
      if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
      }
      return expectFloat32(value);
    };
    NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
    parseNumber = (value) => {
      const matches = value.match(NUMBER_REGEX);
      if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
      }
      return parseFloat(value);
    };
    strictParseInt32 = (value) => {
      if (typeof value === "string") {
        return expectInt32(parseNumber(value));
      }
      return expectInt32(value);
    };
    strictParseShort = (value) => {
      if (typeof value === "string") {
        return expectShort(parseNumber(value));
      }
      return expectShort(value);
    };
    strictParseByte = (value) => {
      if (typeof value === "string") {
        return expectByte(parseNumber(value));
      }
      return expectByte(value);
    };
    stackTraceWarning = (message) => {
      return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s10) => !s10.includes("stackTraceWarning")).join("\n");
    };
    logger = {
      warn: console.warn
    };
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/date-utils.js
var MONTHS, RFC3339, RFC3339_WITH_OFFSET, parseRfc3339DateTimeWithOffset, IMF_FIXDATE, RFC_850_DATE, ASC_TIME, parseEpochTimestamp, buildDate, FIFTY_YEARS_IN_MILLIS, DAYS_IN_MONTH, validateDayOfMonth, isLeapYear, parseDateValue, parseMilliseconds, parseOffsetToMilliseconds, stripLeadingZeroes;
var init_date_utils = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/date-utils.js"() {
    "use strict";
    init_parse_utils();
    MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
    RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
    parseRfc3339DateTimeWithOffset = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      }
      const match = RFC3339_WITH_OFFSET.exec(value);
      if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
      }
      const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
      const year = strictParseShort(stripLeadingZeroes(yearStr));
      const month = parseDateValue(monthStr, "month", 1, 12);
      const day = parseDateValue(dayStr, "day", 1, 31);
      const date2 = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
      if (offsetStr.toUpperCase() != "Z") {
        date2.setTime(date2.getTime() - parseOffsetToMilliseconds(offsetStr));
      }
      return date2;
    };
    IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
    RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
    ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
    parseEpochTimestamp = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      let valueAsDouble;
      if (typeof value === "number") {
        valueAsDouble = value;
      } else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
      } else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
      }
      if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
      }
      return new Date(Math.round(valueAsDouble * 1e3));
    };
    buildDate = (year, month, day, time) => {
      const adjustedMonth = month - 1;
      validateDayOfMonth(year, adjustedMonth, day);
      return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
    };
    FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
    DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    validateDayOfMonth = (year, month, day) => {
      let maxDays = DAYS_IN_MONTH[month];
      if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
      }
      if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
      }
    };
    isLeapYear = (year) => {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    };
    parseDateValue = (value, type, lower, upper) => {
      const dateVal = strictParseByte(stripLeadingZeroes(value));
      if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
      }
      return dateVal;
    };
    parseMilliseconds = (value) => {
      if (value === null || value === void 0) {
        return 0;
      }
      return strictParseFloat32("0." + value) * 1e3;
    };
    parseOffsetToMilliseconds = (value) => {
      const directionStr = value[0];
      let direction = 1;
      if (directionStr == "+") {
        direction = 1;
      } else if (directionStr == "-") {
        direction = -1;
      } else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
      }
      const hour = Number(value.substring(1, 3));
      const minute = Number(value.substring(4, 6));
      return direction * (hour * 60 + minute) * 60 * 1e3;
    };
    stripLeadingZeroes = (value) => {
      let idx = 0;
      while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
      }
      if (idx === 0) {
        return value;
      }
      return value.slice(idx);
    };
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/exceptions.js
var ServiceException, decorateServiceException;
var init_exceptions = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/exceptions.js"() {
    "use strict";
    ServiceException = class _ServiceException extends Error {
      constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, _ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
      }
    };
    decorateServiceException = (exception, additions = {}) => {
      Object.entries(additions).filter(([, v6]) => v6 !== void 0).forEach(([k10, v6]) => {
        if (exception[k10] == void 0 || exception[k10] === "") {
          exception[k10] = v6;
        }
      });
      const message = exception.message || exception.Message || "UnknownError";
      exception.message = message;
      delete exception.Message;
      return exception;
    };
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/default-error-handler.js
var throwDefaultError, deserializeMetadata;
var init_default_error_handler = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/default-error-handler.js"() {
    "use strict";
    init_exceptions();
    throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
      const $metadata = deserializeMetadata(output);
      const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
      const response = new exceptionCtor({
        name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata
      });
      throw decorateServiceException(response, parsedBody);
    };
    deserializeMetadata = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/defaults-mode.js
var loadConfigsForDefaultMode;
var init_defaults_mode = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/defaults-mode.js"() {
    "use strict";
    loadConfigsForDefaultMode = (mode) => {
      switch (mode) {
        case "standard":
          return {
            retryMode: "standard",
            connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard",
            connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard",
            connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard",
            connectionTimeout: 3e4
          };
        default:
          return {};
      }
    };
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
var warningEmitted, emitWarningIfUnsupportedVersion;
var init_emitWarningIfUnsupportedVersion = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js"() {
    "use strict";
    warningEmitted = false;
    emitWarningIfUnsupportedVersion = (version) => {
      if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 14) {
        warningEmitted = true;
      }
    };
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c10) {
    return "%" + c10.charCodeAt(0).toString(16).toUpperCase();
  });
}
var init_extended_encode_uri_component = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/extended-encode-uri-component.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/get-array-if-single-item.js
var getArrayIfSingleItem;
var init_get_array_if_single_item = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/get-array-if-single-item.js"() {
    "use strict";
    getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/get-value-from-text-node.js
var getValueFromTextNode;
var init_get_value_from_text_node = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/get-value-from-text-node.js"() {
    "use strict";
    getValueFromTextNode = (obj) => {
      const textNodeName = "#text";
      for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
          obj[key] = obj[key][textNodeName];
        } else if (typeof obj[key] === "object" && obj[key] !== null) {
          obj[key] = getValueFromTextNode(obj[key]);
        }
      }
      return obj;
    };
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/lazy-json.js
var StringWrapper;
var init_lazy_json = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/lazy-json.js"() {
    "use strict";
    StringWrapper = function() {
      const Class = Object.getPrototypeOf(this).constructor;
      const Constructor = Function.bind.apply(String, [null, ...arguments]);
      const instance = new Constructor();
      Object.setPrototypeOf(instance, Class.prototype);
      return instance;
    };
    StringWrapper.prototype = Object.create(String.prototype, {
      constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    Object.setPrototypeOf(StringWrapper, String);
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/object-mapping.js
function map2(arg0, arg1, arg2) {
  let target;
  let filter;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter = arg1;
      instructions = arg2;
      return mapWithFilter(target, filter, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    let [filter2, value] = instructions[key];
    if (typeof value === "function") {
      let _value;
      const defaultFilterPassed = filter2 === void 0 && (_value = value()) != null;
      const customFilterPassed = typeof filter2 === "function" && !!filter2(void 0) || typeof filter2 !== "function" && !!filter2;
      if (defaultFilterPassed) {
        target[key] = _value;
      } else if (customFilterPassed) {
        target[key] = value();
      }
    } else {
      const defaultFilterPassed = filter2 === void 0 && value != null;
      const customFilterPassed = typeof filter2 === "function" && !!filter2(value) || typeof filter2 !== "function" && !!filter2;
      if (defaultFilterPassed || customFilterPassed) {
        target[key] = value;
      }
    }
  }
  return target;
}
var mapWithFilter;
var init_object_mapping = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/object-mapping.js"() {
    "use strict";
    mapWithFilter = (target, filter, instructions) => {
      return map2(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
          _instructions[key] = value;
        } else {
          if (typeof value === "function") {
            _instructions[key] = [filter, value()];
          } else {
            _instructions[key] = [filter, value];
          }
        }
        return _instructions;
      }, {}));
    };
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/resolve-path.js
var init_resolve_path = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/resolve-path.js"() {
    "use strict";
    init_extended_encode_uri_component();
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/ser-utils.js
var init_ser_utils = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/ser-utils.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/split-every.js
var init_split_every = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/split-every.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/smithy-client/dist-es/index.js
var init_dist_es26 = __esm({
  "../../node_modules/@aws-sdk/smithy-client/dist-es/index.js"() {
    "use strict";
    init_NoOpLogger();
    init_client();
    init_command();
    init_constants5();
    init_date_utils();
    init_default_error_handler();
    init_defaults_mode();
    init_emitWarningIfUnsupportedVersion();
    init_exceptions();
    init_extended_encode_uri_component();
    init_get_array_if_single_item();
    init_get_value_from_text_node();
    init_lazy_json();
    init_object_mapping();
    init_parse_utils();
    init_resolve_path();
    init_ser_utils();
    init_split_every();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters;
var init_EndpointParameters = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/endpoint/EndpointParameters.js"() {
    "use strict";
    resolveClientEndpointParameters = (options) => {
      return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "cognito-identity"
      };
    };
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/package.json
var package_default;
var init_package = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/package.json"() {
    package_default = {
      name: "@aws-sdk/client-cognito-identity",
      description: "AWS SDK for JavaScript Cognito Identity Client for Node.js, Browser and React Native",
      version: "3.272.0",
      scripts: {
        build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "tsc -p tsconfig.cjs.json",
        "build:docs": "typedoc",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "generate:client": "node ../../scripts/generate-clients/single-service --solo cognito-identity",
        "test:e2e": "ts-mocha test/**/*.ispec.ts && karma start karma.conf.js"
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: false,
      dependencies: {
        "@aws-crypto/sha256-browser": "3.0.0",
        "@aws-crypto/sha256-js": "3.0.0",
        "@aws-sdk/client-sts": "3.272.0",
        "@aws-sdk/config-resolver": "3.272.0",
        "@aws-sdk/credential-provider-node": "3.272.0",
        "@aws-sdk/fetch-http-handler": "3.272.0",
        "@aws-sdk/hash-node": "3.272.0",
        "@aws-sdk/invalid-dependency": "3.272.0",
        "@aws-sdk/middleware-content-length": "3.272.0",
        "@aws-sdk/middleware-endpoint": "3.272.0",
        "@aws-sdk/middleware-host-header": "3.272.0",
        "@aws-sdk/middleware-logger": "3.272.0",
        "@aws-sdk/middleware-recursion-detection": "3.272.0",
        "@aws-sdk/middleware-retry": "3.272.0",
        "@aws-sdk/middleware-serde": "3.272.0",
        "@aws-sdk/middleware-signing": "3.272.0",
        "@aws-sdk/middleware-stack": "3.272.0",
        "@aws-sdk/middleware-user-agent": "3.272.0",
        "@aws-sdk/node-config-provider": "3.272.0",
        "@aws-sdk/node-http-handler": "3.272.0",
        "@aws-sdk/protocol-http": "3.272.0",
        "@aws-sdk/smithy-client": "3.272.0",
        "@aws-sdk/types": "3.272.0",
        "@aws-sdk/url-parser": "3.272.0",
        "@aws-sdk/util-base64": "3.208.0",
        "@aws-sdk/util-body-length-browser": "3.188.0",
        "@aws-sdk/util-body-length-node": "3.208.0",
        "@aws-sdk/util-defaults-mode-browser": "3.272.0",
        "@aws-sdk/util-defaults-mode-node": "3.272.0",
        "@aws-sdk/util-endpoints": "3.272.0",
        "@aws-sdk/util-retry": "3.272.0",
        "@aws-sdk/util-user-agent-browser": "3.272.0",
        "@aws-sdk/util-user-agent-node": "3.272.0",
        "@aws-sdk/util-utf8": "3.254.0",
        tslib: "^2.3.1"
      },
      devDependencies: {
        "@aws-sdk/client-iam": "3.272.0",
        "@aws-sdk/service-client-documentation-generator": "3.208.0",
        "@tsconfig/node14": "1.0.3",
        "@types/chai": "^4.2.11",
        "@types/mocha": "^8.0.4",
        "@types/node": "^14.14.31",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typedoc: "0.19.2",
        typescript: "~4.6.2"
      },
      overrides: {
        typedoc: {
          typescript: "~4.6.2"
        }
      },
      engines: {
        node: ">=14.0.0"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "dist-*"
      ],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      browser: {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
      },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
      },
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cognito-identity",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-cognito-identity"
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/models/STSServiceException.js
var STSServiceException;
var init_STSServiceException = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/models/STSServiceException.js"() {
    "use strict";
    init_dist_es26();
    STSServiceException = class _STSServiceException extends ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _STSServiceException.prototype);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/models/models_0.js
var ExpiredTokenException, MalformedPolicyDocumentException, PackedPolicyTooLargeException, RegionDisabledException, IDPRejectedClaimException, InvalidIdentityTokenException, IDPCommunicationErrorException, AssumeRoleRequestFilterSensitiveLog, AssumeRoleResponseFilterSensitiveLog, AssumeRoleWithWebIdentityRequestFilterSensitiveLog, AssumeRoleWithWebIdentityResponseFilterSensitiveLog;
var init_models_0 = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/models/models_0.js"() {
    "use strict";
    init_STSServiceException();
    ExpiredTokenException = class _ExpiredTokenException extends STSServiceException {
      constructor(opts) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...opts
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
      }
    };
    MalformedPolicyDocumentException = class _MalformedPolicyDocumentException extends STSServiceException {
      constructor(opts) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...opts
        });
        this.name = "MalformedPolicyDocumentException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _MalformedPolicyDocumentException.prototype);
      }
    };
    PackedPolicyTooLargeException = class _PackedPolicyTooLargeException extends STSServiceException {
      constructor(opts) {
        super({
          name: "PackedPolicyTooLargeException",
          $fault: "client",
          ...opts
        });
        this.name = "PackedPolicyTooLargeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _PackedPolicyTooLargeException.prototype);
      }
    };
    RegionDisabledException = class _RegionDisabledException extends STSServiceException {
      constructor(opts) {
        super({
          name: "RegionDisabledException",
          $fault: "client",
          ...opts
        });
        this.name = "RegionDisabledException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _RegionDisabledException.prototype);
      }
    };
    IDPRejectedClaimException = class _IDPRejectedClaimException extends STSServiceException {
      constructor(opts) {
        super({
          name: "IDPRejectedClaimException",
          $fault: "client",
          ...opts
        });
        this.name = "IDPRejectedClaimException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _IDPRejectedClaimException.prototype);
      }
    };
    InvalidIdentityTokenException = class _InvalidIdentityTokenException extends STSServiceException {
      constructor(opts) {
        super({
          name: "InvalidIdentityTokenException",
          $fault: "client",
          ...opts
        });
        this.name = "InvalidIdentityTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidIdentityTokenException.prototype);
      }
    };
    IDPCommunicationErrorException = class _IDPCommunicationErrorException extends STSServiceException {
      constructor(opts) {
        super({
          name: "IDPCommunicationErrorException",
          $fault: "client",
          ...opts
        });
        this.name = "IDPCommunicationErrorException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _IDPCommunicationErrorException.prototype);
      }
    };
    AssumeRoleRequestFilterSensitiveLog = (obj) => ({
      ...obj
    });
    AssumeRoleResponseFilterSensitiveLog = (obj) => ({
      ...obj
    });
    AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
      ...obj
    });
    AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
      ...obj
    });
  }
});

// ../../node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "../../node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string2, regex) {
      const matches = [];
      let match = regex.exec(string2);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string2);
      }
      return matches;
    };
    var isName = function(string2) {
      const match = regexName.exec(string2);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v6) {
      return typeof v6 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a10, arrayMode) {
      if (a10) {
        const keys = Object.keys(a10);
        const len = keys.length;
        for (let i10 = 0; i10 < len; i10++) {
          if (arrayMode === "strict") {
            target[keys[i10]] = [a10[keys[i10]]];
          } else {
            target[keys[i10]] = a10[keys[i10]];
          }
        }
      }
    };
    exports.getValue = function(v6) {
      if (exports.isExist(v6)) {
        return v6;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// ../../node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "../../node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i10 = 0; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === "<" && xmlData[i10 + 1] === "?") {
          i10 += 2;
          i10 = readPI(xmlData, i10);
          if (i10.err)
            return i10;
        } else if (xmlData[i10] === "<") {
          let tagStartPos = i10;
          i10++;
          if (xmlData[i10] === "!") {
            i10 = readCommentAndCDATA(xmlData, i10);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i10] === "/") {
              closingTag = true;
              i10++;
            }
            let tagName = "";
            for (; i10 < xmlData.length && xmlData[i10] !== ">" && xmlData[i10] !== " " && xmlData[i10] !== "	" && xmlData[i10] !== "\n" && xmlData[i10] !== "\r"; i10++) {
              tagName += xmlData[i10];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i10--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i10));
            }
            const result = readAttributeStr(xmlData, i10);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i10));
            }
            let attrStr = result.value;
            i10 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i10 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i10));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i10 - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i10));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i10++; i10 < xmlData.length; i10++) {
              if (xmlData[i10] === "<") {
                if (xmlData[i10 + 1] === "!") {
                  i10++;
                  i10 = readCommentAndCDATA(xmlData, i10);
                  continue;
                } else if (xmlData[i10 + 1] === "?") {
                  i10 = readPI(xmlData, ++i10);
                  if (i10.err)
                    return i10;
                } else {
                  break;
                }
              } else if (xmlData[i10] === "&") {
                const afterAmp = validateAmpersand(xmlData, i10);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i10));
                i10 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i10])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i10));
                }
              }
            }
            if (xmlData[i10] === "<") {
              i10--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i10])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i10] + "' is not expected.", getLineNumberForPosition(xmlData, i10));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t5) => t5.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i10) {
      const start = i10;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] == "?" || xmlData[i10] == " ") {
          const tagname = xmlData.substr(start, i10 - start);
          if (i10 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i10));
          } else if (xmlData[i10] == "?" && xmlData[i10 + 1] == ">") {
            i10++;
            break;
          } else {
            continue;
          }
        }
      }
      return i10;
    }
    function readCommentAndCDATA(xmlData, i10) {
      if (xmlData.length > i10 + 5 && xmlData[i10 + 1] === "-" && xmlData[i10 + 2] === "-") {
        for (i10 += 3; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "-" && xmlData[i10 + 1] === "-" && xmlData[i10 + 2] === ">") {
            i10 += 2;
            break;
          }
        }
      } else if (xmlData.length > i10 + 8 && xmlData[i10 + 1] === "D" && xmlData[i10 + 2] === "O" && xmlData[i10 + 3] === "C" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "Y" && xmlData[i10 + 6] === "P" && xmlData[i10 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i10 += 8; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i10] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i10 + 9 && xmlData[i10 + 1] === "[" && xmlData[i10 + 2] === "C" && xmlData[i10 + 3] === "D" && xmlData[i10 + 4] === "A" && xmlData[i10 + 5] === "T" && xmlData[i10 + 6] === "A" && xmlData[i10 + 7] === "[") {
        for (i10 += 8; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "]" && xmlData[i10 + 1] === "]" && xmlData[i10 + 2] === ">") {
            i10 += 2;
            break;
          }
        }
      }
      return i10;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i10) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === doubleQuote || xmlData[i10] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i10];
          } else if (startChar !== xmlData[i10]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i10] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i10];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i10,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i10 = 0; i10 < matches.length; i10++) {
        if (matches[i10][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i10][2] + "' has no space in starting.", getPositionFromMatch(matches[i10]));
        } else if (matches[i10][3] !== void 0 && matches[i10][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i10][2] + "' is without value.", getPositionFromMatch(matches[i10]));
        } else if (matches[i10][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i10][2] + "' is not allowed.", getPositionFromMatch(matches[i10]));
        }
        const attrName = matches[i10][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i10]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i10]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i10) {
      let re = /\d/;
      if (xmlData[i10] === "x") {
        i10++;
        re = /[\da-fA-F]/;
      }
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === ";")
          return i10;
        if (!xmlData[i10].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i10) {
      i10++;
      if (xmlData[i10] === ";")
        return -1;
      if (xmlData[i10] === "#") {
        i10++;
        return validateNumberAmpersand(xmlData, i10);
      }
      let count2 = 0;
      for (; i10 < xmlData.length; i10++, count2++) {
        if (xmlData[i10].match(/\w/) && count2 < 20)
          continue;
        if (xmlData[i10] === ";")
          break;
        return -1;
      }
      return i10;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    "use strict";
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true
      },
      tagValueProcessor: function(tagName, val2) {
        return val2;
      },
      attributeValueProcessor: function(attrName, val2) {
        return val2;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module2) {
    "use strict";
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val2) {
        this.child.push({ [key]: val2 });
      }
      addChild(node) {
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module2.exports = XmlNode;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module2) {
    "use strict";
    function readDocType(xmlData, i10) {
      const entities = {};
      if (xmlData[i10 + 3] === "O" && xmlData[i10 + 4] === "C" && xmlData[i10 + 5] === "T" && xmlData[i10 + 6] === "Y" && xmlData[i10 + 7] === "P" && xmlData[i10 + 8] === "E") {
        i10 = i10 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, entity = false, comment = false;
        let exp = "";
        for (; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "<") {
            if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "E" && xmlData[i10 + 3] === "N" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "I" && xmlData[i10 + 6] === "T" && xmlData[i10 + 7] === "Y") {
              i10 += 7;
              entity = true;
            } else if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "E" && xmlData[i10 + 3] === "L" && xmlData[i10 + 4] === "E" && xmlData[i10 + 5] === "M" && xmlData[i10 + 6] === "E" && xmlData[i10 + 7] === "N" && xmlData[i10 + 8] === "T") {
              i10 += 8;
            } else if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "A" && xmlData[i10 + 3] === "T" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "L" && xmlData[i10 + 6] === "I" && xmlData[i10 + 7] === "S" && xmlData[i10 + 8] === "T") {
              i10 += 8;
            } else if (hasBody && xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "N" && xmlData[i10 + 3] === "O" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "A" && xmlData[i10 + 6] === "T" && xmlData[i10 + 7] === "I" && xmlData[i10 + 8] === "O" && xmlData[i10 + 9] === "N") {
              i10 += 9;
            } else if (
              //comment
              xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "-" && xmlData[i10 + 3] === "-"
            ) {
              comment = true;
            } else {
              throw new Error("Invalid DOCTYPE");
            }
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i10] === ">") {
            if (comment) {
              if (xmlData[i10 - 1] === "-" && xmlData[i10 - 2] === "-") {
                comment = false;
              } else {
                throw new Error(`Invalid XML comment in DOCTYPE`);
              }
            } else if (entity) {
              parseEntityExp(exp, entities);
              entity = false;
            }
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i10] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i10];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i10 };
    }
    var entityRegex = RegExp(`^\\s([a-zA-z0-0]+)[ 	](['"])([^&]+)\\2`);
    function parseEntityExp(exp, entities) {
      const match = entityRegex.exec(exp);
      if (match) {
        entities[match[1]] = {
          regx: RegExp(`&${match[1]};`, "g"),
          val: match[3]
        };
      }
    }
    module2.exports = readDocType;
  }
});

// ../../node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "../../node_modules/strnum/strnum.js"(exports, module2) {
    "use strict";
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          const eNotation = match[4] || match[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module2.exports = toNumber;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module2) {
    "use strict";
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i10 = 0; i10 < entKeys.length; i10++) {
        const ent = entKeys[i10];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val2 !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val2 = val2.trim();
        }
        if (val2.length > 0) {
          if (!escapeEntities)
            val2 = this.replaceEntitiesValue(val2);
          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val2;
          } else if (typeof newval !== typeof val2 || newval !== val2) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val2.trim();
            if (trimmedVal === val2) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val2;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i10 = 0; i10 < len; i10++) {
          const attrName = this.resolveNameSpace(matches[i10][1]);
          let oldVal = matches[i10][4];
          const aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i10 = 0; i10 < xmlData.length; i10++) {
        const ch = xmlData[i10];
        if (ch === "<") {
          if (xmlData[i10 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i10, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i10 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i10 = closeIndex;
          } else if (xmlData[i10 + 1] === "?") {
            let tagData = readTagExp(xmlData, i10, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath);
              }
              currentNode.addChild(childNode);
            }
            i10 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i10 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i10 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i10 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i10 = endIndex;
          } else if (xmlData.substr(i10 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i10);
            this.docTypeEntities = result.entities;
            i10 = result.i;
          } else if (xmlData.substr(i10 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i10, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i10 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val2 == void 0)
                val2 = "";
              currentNode.add(this.options.textNodeName, val2);
            }
            i10 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i10, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i10 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i10 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i10 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              currentNode.addChild(childNode);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                currentNode.addChild(childNode);
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
                }
                currentNode.addChild(childNode);
                currentNode = childNode;
              }
              textData = "";
              i10 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i10];
        }
      }
      return xmlObj.child;
    };
    var replaceEntitiesValue = function(val2) {
      if (this.options.processEntities) {
        for (let entityName2 in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName2];
          val2 = val2.replace(entity.regx, entity.val);
        }
        for (let entityName2 in this.lastEntities) {
          const entity = this.lastEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName2 in this.htmlEntities) {
            const entity = this.htmlEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
        }
        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val2;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i10, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i10; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary)
            attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str, i10, errMsg) {
      const closingIndex = xmlData.indexOf(str, i10);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i10, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i10 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    function readStopNodeData(xmlData, tagName, i10) {
      const startIndex = i10;
      let openTagCount = 1;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === "<") {
          if (xmlData[i10 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i10, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i10 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i10),
                  i: closeIndex
                };
              }
            }
            i10 = closeIndex;
          } else if (xmlData[i10 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i10 + 1, "StopNode is not closed.");
            i10 = closeIndex;
          } else if (xmlData.substr(i10 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i10 + 3, "StopNode is not closed.");
            i10 = closeIndex;
          } else if (xmlData.substr(i10 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i10, "StopNode is not closed.") - 2;
            i10 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i10, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i10 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val2, shouldParse, options) {
      if (shouldParse && typeof val2 === "string") {
        const newval = val2.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val2, options);
      } else {
        if (util.isExist(val2)) {
          return val2;
        } else {
          return "";
        }
      }
    }
    module2.exports = OrderedObjParser;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i10 = 0; i10 < arr.length; i10++) {
        const tagObj = arr[i10];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val2 = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val2, options);
          if (tagObj[":@"]) {
            assignAttributes(val2, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val2 = val2[options.textNodeName];
          } else if (Object.keys(val2).length === 0) {
            if (options.alwaysCreateTextNode)
              val2[options.textNodeName] = "";
            else
              val2 = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val2);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val2];
            } else {
              compressedObj[property] = val2;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key = keys[i10];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i10 = 0; i10 < len; i10++) {
          const atrrName = keys[i10];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const propCount = Object.keys(obj).length;
      if (propCount === 0 || propCount === 1 && obj[options.textNodeName])
        return true;
      return false;
    }
    exports.prettify = prettify;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module2) {
    "use strict";
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser4 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module2.exports = XMLParser4;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module2) {
    "use strict";
    var EOL = "\n";
    function toXml(jArray, options) {
      return arrToStr(jArray, options, "", 0);
    }
    function arrToStr(arr, options, jPath, level) {
      let xmlStr = "";
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL + "" + options.indentBy.repeat(level);
      }
      for (let i10 = 0; i10 < arr.length; i10++) {
        const tagObj = arr[i10];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          xmlStr += indentation + tagText;
          continue;
        } else if (tagName === options.cdataPropName) {
          xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          continue;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        let tagStart = indentation + `<${tagName}${attStr}`;
        let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        }
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key = keys[i10];
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i10 = 0; i10 < options.entities.length; i10++) {
          const entity = options.entities[i10];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module2.exports = toXml;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module2) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a10) {
        return a10;
      },
      attributeValueProcessor: function(attrName, a10) {
        return a10;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      transformTagName: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
      if (this.options.suppressEmptyNode) {
        this.buildTextNode = buildEmptyTextNode;
        this.buildObjNode = buildEmptyObjNode;
      } else {
        this.buildTextNode = buildTextValNode;
        this.buildObjNode = buildObjectNode;
      }
      this.buildTextValNode = buildTextValNode;
      this.buildObjectNode = buildObjectNode;
      this.replaceEntitiesValue = replaceEntitiesValue;
      this.buildAttrPairStr = buildAttrPairStr;
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val2 = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          if (key[0] === "?")
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val2 += this.buildTextNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val2 += this.replaceEntitiesValue(newval);
            } else {
              val2 += this.buildTextNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          for (let j10 = 0; j10 < arrLen; j10++) {
            const item = jObj[key][j10];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              val2 += this.processTextOrObjNode(item, key, level);
            } else {
              val2 += this.buildTextNode(item, key, "", level);
            }
          }
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L2 = Ks.length;
            for (let j10 = 0; j10 < L2; j10++) {
              attrStr += this.buildAttrPairStr(Ks[j10], "" + jObj[key][Ks[j10]]);
            }
          } else {
            val2 += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val: val2 };
    };
    function buildAttrPairStr(attrName, val2) {
      val2 = this.options.attributeValueProcessor(attrName, "" + val2);
      val2 = this.replaceEntitiesValue(val2);
      if (this.options.suppressBooleanAttributes && val2 === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val2 + '"';
    }
    function processTextOrObjNode(object2, key, level) {
      const result = this.j2x(object2, level + 1);
      if (object2[this.options.textNodeName] !== void 0 && Object.keys(object2).length === 1) {
        return this.buildTextNode(object2[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjNode(result.val, key, result.attrStr, level);
      }
    }
    function buildObjectNode(val2, key, attrStr, level) {
      let tagEndExp = "</" + key + this.tagEndChar;
      let piClosingChar = "";
      if (key[0] === "?") {
        piClosingChar = "?";
        tagEndExp = "";
      }
      if (attrStr && val2.indexOf("<") === -1) {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
      }
    }
    function buildEmptyObjNode(val2, key, attrStr, level) {
      if (val2 !== "") {
        return this.buildObjectNode(val2, key, attrStr, level);
      } else {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else
          return this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar;
      }
    }
    function buildTextValNode(val2, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else {
        let textValue = this.options.tagValueProcessor(key, val2);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "" && this.options.unpairedTags.indexOf(key) !== -1) {
          if (this.options.suppressUnpairedNode) {
            return this.indentate(level) + "<" + key + this.tagEndChar;
          } else {
            return this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    }
    function replaceEntitiesValue(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i10 = 0; i10 < this.options.entities.length; i10++) {
          const entity = this.options.entities[i10];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    function buildEmptyTextNode(val2, key, attrStr, level) {
      if (val2 === "" && this.options.unpairedTags.indexOf(key) !== -1) {
        if (this.options.suppressUnpairedNode) {
          return this.indentate(level) + "<" + key + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        }
      } else if (val2 !== "") {
        return this.buildTextValNode(val2, key, attrStr, level);
      } else {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else
          return this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar;
      }
    }
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix)) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module2.exports = Builder;
  }
});

// ../../node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "../../node_modules/fast-xml-parser/src/fxp.js"(exports, module2) {
    "use strict";
    var validator = require_validator();
    var XMLParser4 = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module2.exports = {
      XMLParser: XMLParser4,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/protocols/Aws_query.js
var import_fast_xml_parser, serializeAws_queryAssumeRoleCommand, serializeAws_queryAssumeRoleWithWebIdentityCommand, deserializeAws_queryAssumeRoleCommand, deserializeAws_queryAssumeRoleCommandError, deserializeAws_queryAssumeRoleWithWebIdentityCommand, deserializeAws_queryAssumeRoleWithWebIdentityCommandError, deserializeAws_queryExpiredTokenExceptionResponse, deserializeAws_queryIDPCommunicationErrorExceptionResponse, deserializeAws_queryIDPRejectedClaimExceptionResponse, deserializeAws_queryInvalidIdentityTokenExceptionResponse, deserializeAws_queryMalformedPolicyDocumentExceptionResponse, deserializeAws_queryPackedPolicyTooLargeExceptionResponse, deserializeAws_queryRegionDisabledExceptionResponse, serializeAws_queryAssumeRoleRequest, serializeAws_queryAssumeRoleWithWebIdentityRequest, serializeAws_querypolicyDescriptorListType, serializeAws_queryPolicyDescriptorType, serializeAws_queryTag, serializeAws_querytagKeyListType, serializeAws_querytagListType, deserializeAws_queryAssumedRoleUser, deserializeAws_queryAssumeRoleResponse, deserializeAws_queryAssumeRoleWithWebIdentityResponse, deserializeAws_queryCredentials, deserializeAws_queryExpiredTokenException, deserializeAws_queryIDPCommunicationErrorException, deserializeAws_queryIDPRejectedClaimException, deserializeAws_queryInvalidIdentityTokenException, deserializeAws_queryMalformedPolicyDocumentException, deserializeAws_queryPackedPolicyTooLargeException, deserializeAws_queryRegionDisabledException, deserializeMetadata2, collectBody, collectBodyString, buildHttpRpcRequest, parseBody, parseErrorBody, buildFormUrlencodedString, loadQueryErrorCode;
var init_Aws_query = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/protocols/Aws_query.js"() {
    "use strict";
    init_dist_es4();
    init_dist_es26();
    import_fast_xml_parser = __toESM(require_fxp());
    init_models_0();
    init_STSServiceException();
    serializeAws_queryAssumeRoleCommand = async (input, context) => {
      const headers = {
        "content-type": "application/x-www-form-urlencoded"
      };
      let body;
      body = buildFormUrlencodedString({
        ...serializeAws_queryAssumeRoleRequest(input, context),
        Action: "AssumeRole",
        Version: "2011-06-15"
      });
      return buildHttpRpcRequest(context, headers, "/", void 0, body);
    };
    serializeAws_queryAssumeRoleWithWebIdentityCommand = async (input, context) => {
      const headers = {
        "content-type": "application/x-www-form-urlencoded"
      };
      let body;
      body = buildFormUrlencodedString({
        ...serializeAws_queryAssumeRoleWithWebIdentityRequest(input, context),
        Action: "AssumeRoleWithWebIdentity",
        Version: "2011-06-15"
      });
      return buildHttpRpcRequest(context, headers, "/", void 0, body);
    };
    deserializeAws_queryAssumeRoleCommand = async (output, context) => {
      if (output.statusCode >= 300) {
        return deserializeAws_queryAssumeRoleCommandError(output, context);
      }
      const data = await parseBody(output.body, context);
      let contents = {};
      contents = deserializeAws_queryAssumeRoleResponse(data.AssumeRoleResult, context);
      const response = {
        $metadata: deserializeMetadata2(output),
        ...contents
      };
      return Promise.resolve(response);
    };
    deserializeAws_queryAssumeRoleCommandError = async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
      };
      const errorCode = loadQueryErrorCode(output, parsedOutput.body);
      switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
          throw await deserializeAws_queryExpiredTokenExceptionResponse(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
          throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
          throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
          throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          throwDefaultError({
            output,
            parsedBody: parsedBody.Error,
            exceptionCtor: STSServiceException,
            errorCode
          });
      }
    };
    deserializeAws_queryAssumeRoleWithWebIdentityCommand = async (output, context) => {
      if (output.statusCode >= 300) {
        return deserializeAws_queryAssumeRoleWithWebIdentityCommandError(output, context);
      }
      const data = await parseBody(output.body, context);
      let contents = {};
      contents = deserializeAws_queryAssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
      const response = {
        $metadata: deserializeMetadata2(output),
        ...contents
      };
      return Promise.resolve(response);
    };
    deserializeAws_queryAssumeRoleWithWebIdentityCommandError = async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
      };
      const errorCode = loadQueryErrorCode(output, parsedOutput.body);
      switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
          throw await deserializeAws_queryExpiredTokenExceptionResponse(parsedOutput, context);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
          throw await deserializeAws_queryIDPCommunicationErrorExceptionResponse(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
          throw await deserializeAws_queryIDPRejectedClaimExceptionResponse(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
          throw await deserializeAws_queryInvalidIdentityTokenExceptionResponse(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
          throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
          throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
          throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          throwDefaultError({
            output,
            parsedBody: parsedBody.Error,
            exceptionCtor: STSServiceException,
            errorCode
          });
      }
    };
    deserializeAws_queryExpiredTokenExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_queryExpiredTokenException(body.Error, context);
      const exception = new ExpiredTokenException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_queryIDPCommunicationErrorExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_queryIDPCommunicationErrorException(body.Error, context);
      const exception = new IDPCommunicationErrorException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_queryIDPRejectedClaimExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_queryIDPRejectedClaimException(body.Error, context);
      const exception = new IDPRejectedClaimException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_queryInvalidIdentityTokenExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_queryInvalidIdentityTokenException(body.Error, context);
      const exception = new InvalidIdentityTokenException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_queryMalformedPolicyDocumentExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_queryMalformedPolicyDocumentException(body.Error, context);
      const exception = new MalformedPolicyDocumentException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_queryPackedPolicyTooLargeExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_queryPackedPolicyTooLargeException(body.Error, context);
      const exception = new PackedPolicyTooLargeException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_queryRegionDisabledExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_queryRegionDisabledException(body.Error, context);
      const exception = new RegionDisabledException({
        $metadata: deserializeMetadata2(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    serializeAws_queryAssumeRoleRequest = (input, context) => {
      const entries = {};
      if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
      }
      if (input.RoleSessionName != null) {
        entries["RoleSessionName"] = input.RoleSessionName;
      }
      if (input.PolicyArns != null) {
        const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
          entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
          const loc = `PolicyArns.${key}`;
          entries[loc] = value;
        });
      }
      if (input.Policy != null) {
        entries["Policy"] = input.Policy;
      }
      if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
      }
      if (input.Tags != null) {
        const memberEntries = serializeAws_querytagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
          entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
          const loc = `Tags.${key}`;
          entries[loc] = value;
        });
      }
      if (input.TransitiveTagKeys != null) {
        const memberEntries = serializeAws_querytagKeyListType(input.TransitiveTagKeys, context);
        if (input.TransitiveTagKeys?.length === 0) {
          entries.TransitiveTagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
          const loc = `TransitiveTagKeys.${key}`;
          entries[loc] = value;
        });
      }
      if (input.ExternalId != null) {
        entries["ExternalId"] = input.ExternalId;
      }
      if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
      }
      if (input.TokenCode != null) {
        entries["TokenCode"] = input.TokenCode;
      }
      if (input.SourceIdentity != null) {
        entries["SourceIdentity"] = input.SourceIdentity;
      }
      return entries;
    };
    serializeAws_queryAssumeRoleWithWebIdentityRequest = (input, context) => {
      const entries = {};
      if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
      }
      if (input.RoleSessionName != null) {
        entries["RoleSessionName"] = input.RoleSessionName;
      }
      if (input.WebIdentityToken != null) {
        entries["WebIdentityToken"] = input.WebIdentityToken;
      }
      if (input.ProviderId != null) {
        entries["ProviderId"] = input.ProviderId;
      }
      if (input.PolicyArns != null) {
        const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
          entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
          const loc = `PolicyArns.${key}`;
          entries[loc] = value;
        });
      }
      if (input.Policy != null) {
        entries["Policy"] = input.Policy;
      }
      if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
      }
      return entries;
    };
    serializeAws_querypolicyDescriptorListType = (input, context) => {
      const entries = {};
      let counter = 1;
      for (const entry of input) {
        if (entry === null) {
          continue;
        }
        const memberEntries = serializeAws_queryPolicyDescriptorType(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
          entries[`member.${counter}.${key}`] = value;
        });
        counter++;
      }
      return entries;
    };
    serializeAws_queryPolicyDescriptorType = (input, context) => {
      const entries = {};
      if (input.arn != null) {
        entries["arn"] = input.arn;
      }
      return entries;
    };
    serializeAws_queryTag = (input, context) => {
      const entries = {};
      if (input.Key != null) {
        entries["Key"] = input.Key;
      }
      if (input.Value != null) {
        entries["Value"] = input.Value;
      }
      return entries;
    };
    serializeAws_querytagKeyListType = (input, context) => {
      const entries = {};
      let counter = 1;
      for (const entry of input) {
        if (entry === null) {
          continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
      }
      return entries;
    };
    serializeAws_querytagListType = (input, context) => {
      const entries = {};
      let counter = 1;
      for (const entry of input) {
        if (entry === null) {
          continue;
        }
        const memberEntries = serializeAws_queryTag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
          entries[`member.${counter}.${key}`] = value;
        });
        counter++;
      }
      return entries;
    };
    deserializeAws_queryAssumedRoleUser = (output, context) => {
      const contents = {
        AssumedRoleId: void 0,
        Arn: void 0
      };
      if (output["AssumedRoleId"] !== void 0) {
        contents.AssumedRoleId = expectString(output["AssumedRoleId"]);
      }
      if (output["Arn"] !== void 0) {
        contents.Arn = expectString(output["Arn"]);
      }
      return contents;
    };
    deserializeAws_queryAssumeRoleResponse = (output, context) => {
      const contents = {
        Credentials: void 0,
        AssumedRoleUser: void 0,
        PackedPolicySize: void 0,
        SourceIdentity: void 0
      };
      if (output["Credentials"] !== void 0) {
        contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
      }
      if (output["AssumedRoleUser"] !== void 0) {
        contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser(output["AssumedRoleUser"], context);
      }
      if (output["PackedPolicySize"] !== void 0) {
        contents.PackedPolicySize = strictParseInt32(output["PackedPolicySize"]);
      }
      if (output["SourceIdentity"] !== void 0) {
        contents.SourceIdentity = expectString(output["SourceIdentity"]);
      }
      return contents;
    };
    deserializeAws_queryAssumeRoleWithWebIdentityResponse = (output, context) => {
      const contents = {
        Credentials: void 0,
        SubjectFromWebIdentityToken: void 0,
        AssumedRoleUser: void 0,
        PackedPolicySize: void 0,
        Provider: void 0,
        Audience: void 0,
        SourceIdentity: void 0
      };
      if (output["Credentials"] !== void 0) {
        contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
      }
      if (output["SubjectFromWebIdentityToken"] !== void 0) {
        contents.SubjectFromWebIdentityToken = expectString(output["SubjectFromWebIdentityToken"]);
      }
      if (output["AssumedRoleUser"] !== void 0) {
        contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser(output["AssumedRoleUser"], context);
      }
      if (output["PackedPolicySize"] !== void 0) {
        contents.PackedPolicySize = strictParseInt32(output["PackedPolicySize"]);
      }
      if (output["Provider"] !== void 0) {
        contents.Provider = expectString(output["Provider"]);
      }
      if (output["Audience"] !== void 0) {
        contents.Audience = expectString(output["Audience"]);
      }
      if (output["SourceIdentity"] !== void 0) {
        contents.SourceIdentity = expectString(output["SourceIdentity"]);
      }
      return contents;
    };
    deserializeAws_queryCredentials = (output, context) => {
      const contents = {
        AccessKeyId: void 0,
        SecretAccessKey: void 0,
        SessionToken: void 0,
        Expiration: void 0
      };
      if (output["AccessKeyId"] !== void 0) {
        contents.AccessKeyId = expectString(output["AccessKeyId"]);
      }
      if (output["SecretAccessKey"] !== void 0) {
        contents.SecretAccessKey = expectString(output["SecretAccessKey"]);
      }
      if (output["SessionToken"] !== void 0) {
        contents.SessionToken = expectString(output["SessionToken"]);
      }
      if (output["Expiration"] !== void 0) {
        contents.Expiration = expectNonNull(parseRfc3339DateTimeWithOffset(output["Expiration"]));
      }
      return contents;
    };
    deserializeAws_queryExpiredTokenException = (output, context) => {
      const contents = {
        message: void 0
      };
      if (output["message"] !== void 0) {
        contents.message = expectString(output["message"]);
      }
      return contents;
    };
    deserializeAws_queryIDPCommunicationErrorException = (output, context) => {
      const contents = {
        message: void 0
      };
      if (output["message"] !== void 0) {
        contents.message = expectString(output["message"]);
      }
      return contents;
    };
    deserializeAws_queryIDPRejectedClaimException = (output, context) => {
      const contents = {
        message: void 0
      };
      if (output["message"] !== void 0) {
        contents.message = expectString(output["message"]);
      }
      return contents;
    };
    deserializeAws_queryInvalidIdentityTokenException = (output, context) => {
      const contents = {
        message: void 0
      };
      if (output["message"] !== void 0) {
        contents.message = expectString(output["message"]);
      }
      return contents;
    };
    deserializeAws_queryMalformedPolicyDocumentException = (output, context) => {
      const contents = {
        message: void 0
      };
      if (output["message"] !== void 0) {
        contents.message = expectString(output["message"]);
      }
      return contents;
    };
    deserializeAws_queryPackedPolicyTooLargeException = (output, context) => {
      const contents = {
        message: void 0
      };
      if (output["message"] !== void 0) {
        contents.message = expectString(output["message"]);
      }
      return contents;
    };
    deserializeAws_queryRegionDisabledException = (output, context) => {
      const contents = {
        message: void 0
      };
      if (output["message"] !== void 0) {
        contents.message = expectString(output["message"]);
      }
      return contents;
    };
    deserializeMetadata2 = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
    collectBody = (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
      }
      return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
    };
    collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
    buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
      const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
      const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers
      };
      if (resolvedHostname !== void 0) {
        contents.hostname = resolvedHostname;
      }
      if (body !== void 0) {
        contents.body = body;
      }
      return new HttpRequest(contents);
    };
    parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
      if (encoded.length) {
        const parser = new import_fast_xml_parser.XMLParser({
          attributeNamePrefix: "",
          htmlEntities: true,
          ignoreAttributes: false,
          ignoreDeclaration: true,
          parseTagValue: false,
          trimValues: false,
          tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
          parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
          delete parsedObjToReturn[textNodeName];
        }
        return getValueFromTextNode(parsedObjToReturn);
      }
      return {};
    });
    parseErrorBody = async (errorBody, context) => {
      const value = await parseBody(errorBody, context);
      if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
      }
      return value;
    };
    buildFormUrlencodedString = (formEntries) => Object.entries(formEntries).map(([key, value]) => extendedEncodeURIComponent(key) + "=" + extendedEncodeURIComponent(value)).join("&");
    loadQueryErrorCode = (output, data) => {
      if (data.Error?.Code !== void 0) {
        return data.Error.Code;
      }
      if (output.statusCode == 404) {
        return "NotFound";
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleCommand.js
var AssumeRoleCommand;
var init_AssumeRoleCommand = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
    init_models_0();
    init_Aws_query();
    AssumeRoleCommand = class _AssumeRoleCommand extends Command {
      constructor(input) {
        super();
        this.input = input;
      }
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
          UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
          Endpoint: { type: "builtInParams", name: "endpoint" },
          Region: { type: "builtInParams", name: "region" },
          UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
        };
      }
      resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use(getEndpointPlugin(configuration, _AssumeRoleCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use(getAwsAuthPlugin(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger: logger3 } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleCommand";
        const handlerExecutionContext = {
          logger: logger3,
          clientName,
          commandName,
          inputFilterSensitiveLog: AssumeRoleRequestFilterSensitiveLog,
          outputFilterSensitiveLog: AssumeRoleResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
      }
      serialize(input, context) {
        return serializeAws_queryAssumeRoleCommand(input, context);
      }
      deserialize(output, context) {
        return deserializeAws_queryAssumeRoleCommand(output, context);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithSAMLCommand.js
var init_AssumeRoleWithSAMLCommand = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithSAMLCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithWebIdentityCommand.js
var AssumeRoleWithWebIdentityCommand;
var init_AssumeRoleWithWebIdentityCommand = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithWebIdentityCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
    init_models_0();
    init_Aws_query();
    AssumeRoleWithWebIdentityCommand = class _AssumeRoleWithWebIdentityCommand extends Command {
      constructor(input) {
        super();
        this.input = input;
      }
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
          UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
          Endpoint: { type: "builtInParams", name: "endpoint" },
          Region: { type: "builtInParams", name: "region" },
          UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
        };
      }
      resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use(getEndpointPlugin(configuration, _AssumeRoleWithWebIdentityCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger: logger3 } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleWithWebIdentityCommand";
        const handlerExecutionContext = {
          logger: logger3,
          clientName,
          commandName,
          inputFilterSensitiveLog: AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
          outputFilterSensitiveLog: AssumeRoleWithWebIdentityResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
      }
      serialize(input, context) {
        return serializeAws_queryAssumeRoleWithWebIdentityCommand(input, context);
      }
      deserialize(output, context) {
        return deserializeAws_queryAssumeRoleWithWebIdentityCommand(output, context);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/DecodeAuthorizationMessageCommand.js
var init_DecodeAuthorizationMessageCommand = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/commands/DecodeAuthorizationMessageCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/GetAccessKeyInfoCommand.js
var init_GetAccessKeyInfoCommand = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/commands/GetAccessKeyInfoCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/GetCallerIdentityCommand.js
var init_GetCallerIdentityCommand = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/commands/GetCallerIdentityCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/GetFederationTokenCommand.js
var init_GetFederationTokenCommand = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/commands/GetFederationTokenCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/GetSessionTokenCommand.js
var init_GetSessionTokenCommand = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/commands/GetSessionTokenCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/middleware-sdk-sts/dist-es/index.js
var resolveStsAuthConfig;
var init_dist_es27 = __esm({
  "../../node_modules/@aws-sdk/middleware-sdk-sts/dist-es/index.js"() {
    "use strict";
    init_dist_es23();
    resolveStsAuthConfig = (input, { stsClientCtor }) => resolveAwsAuthConfig({
      ...input,
      stsClientCtor
    });
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters2;
var init_EndpointParameters2 = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js"() {
    "use strict";
    resolveClientEndpointParameters2 = (options) => {
      return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        defaultSigningName: "sts"
      };
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/package.json
var package_default2;
var init_package2 = __esm({
  "../../node_modules/@aws-sdk/client-sts/package.json"() {
    package_default2 = {
      name: "@aws-sdk/client-sts",
      description: "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
      version: "3.272.0",
      scripts: {
        build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "tsc -p tsconfig.cjs.json",
        "build:docs": "typedoc",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "generate:client": "node ../../scripts/generate-clients/single-service --solo sts",
        test: "yarn test:unit",
        "test:unit": "jest"
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: false,
      dependencies: {
        "@aws-crypto/sha256-browser": "3.0.0",
        "@aws-crypto/sha256-js": "3.0.0",
        "@aws-sdk/config-resolver": "3.272.0",
        "@aws-sdk/credential-provider-node": "3.272.0",
        "@aws-sdk/fetch-http-handler": "3.272.0",
        "@aws-sdk/hash-node": "3.272.0",
        "@aws-sdk/invalid-dependency": "3.272.0",
        "@aws-sdk/middleware-content-length": "3.272.0",
        "@aws-sdk/middleware-endpoint": "3.272.0",
        "@aws-sdk/middleware-host-header": "3.272.0",
        "@aws-sdk/middleware-logger": "3.272.0",
        "@aws-sdk/middleware-recursion-detection": "3.272.0",
        "@aws-sdk/middleware-retry": "3.272.0",
        "@aws-sdk/middleware-sdk-sts": "3.272.0",
        "@aws-sdk/middleware-serde": "3.272.0",
        "@aws-sdk/middleware-signing": "3.272.0",
        "@aws-sdk/middleware-stack": "3.272.0",
        "@aws-sdk/middleware-user-agent": "3.272.0",
        "@aws-sdk/node-config-provider": "3.272.0",
        "@aws-sdk/node-http-handler": "3.272.0",
        "@aws-sdk/protocol-http": "3.272.0",
        "@aws-sdk/smithy-client": "3.272.0",
        "@aws-sdk/types": "3.272.0",
        "@aws-sdk/url-parser": "3.272.0",
        "@aws-sdk/util-base64": "3.208.0",
        "@aws-sdk/util-body-length-browser": "3.188.0",
        "@aws-sdk/util-body-length-node": "3.208.0",
        "@aws-sdk/util-defaults-mode-browser": "3.272.0",
        "@aws-sdk/util-defaults-mode-node": "3.272.0",
        "@aws-sdk/util-endpoints": "3.272.0",
        "@aws-sdk/util-retry": "3.272.0",
        "@aws-sdk/util-user-agent-browser": "3.272.0",
        "@aws-sdk/util-user-agent-node": "3.272.0",
        "@aws-sdk/util-utf8": "3.254.0",
        "fast-xml-parser": "4.0.11",
        tslib: "^2.3.1"
      },
      devDependencies: {
        "@aws-sdk/service-client-documentation-generator": "3.208.0",
        "@tsconfig/node14": "1.0.3",
        "@types/node": "^14.14.31",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typedoc: "0.19.2",
        typescript: "~4.6.2"
      },
      overrides: {
        typedoc: {
          typescript: "~4.6.2"
        }
      },
      engines: {
        node: ">=14.0.0"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "dist-*"
      ],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      browser: {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
      },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
      },
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-sts"
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/defaultStsRoleAssumers.js
var ASSUME_ROLE_DEFAULT_REGION, decorateDefaultRegion, getDefaultRoleAssumer, getDefaultRoleAssumerWithWebIdentity, decorateDefaultCredentialProvider;
var init_defaultStsRoleAssumers = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/defaultStsRoleAssumers.js"() {
    "use strict";
    init_AssumeRoleCommand();
    init_AssumeRoleWithWebIdentityCommand();
    ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
    decorateDefaultRegion = (region) => {
      if (typeof region !== "function") {
        return region === void 0 ? ASSUME_ROLE_DEFAULT_REGION : region;
      }
      return async () => {
        try {
          return await region();
        } catch (e10) {
          return ASSUME_ROLE_DEFAULT_REGION;
        }
      };
    };
    getDefaultRoleAssumer = (stsOptions, stsClientCtor) => {
      let stsClient;
      let closureSourceCreds;
      return async (sourceCreds, params) => {
        closureSourceCreds = sourceCreds;
        if (!stsClient) {
          const { logger: logger3, region, requestHandler } = stsOptions;
          stsClient = new stsClientCtor({
            logger: logger3,
            credentialDefaultProvider: () => async () => closureSourceCreds,
            region: decorateDefaultRegion(region || stsOptions.region),
            ...requestHandler ? { requestHandler } : {}
          });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
          throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
        }
        return {
          accessKeyId: Credentials.AccessKeyId,
          secretAccessKey: Credentials.SecretAccessKey,
          sessionToken: Credentials.SessionToken,
          expiration: Credentials.Expiration
        };
      };
    };
    getDefaultRoleAssumerWithWebIdentity = (stsOptions, stsClientCtor) => {
      let stsClient;
      return async (params) => {
        if (!stsClient) {
          const { logger: logger3, region, requestHandler } = stsOptions;
          stsClient = new stsClientCtor({
            logger: logger3,
            region: decorateDefaultRegion(region || stsOptions.region),
            ...requestHandler ? { requestHandler } : {}
          });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
          throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
        }
        return {
          accessKeyId: Credentials.AccessKeyId,
          secretAccessKey: Credentials.SecretAccessKey,
          sessionToken: Credentials.SessionToken,
          expiration: Credentials.Expiration
        };
      };
    };
    decorateDefaultCredentialProvider = (provider) => (input) => provider({
      roleAssumer: getDefaultRoleAssumer(input, input.stsClientCtor),
      roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity(input, input.stsClientCtor),
      ...input
    });
  }
});

// ../../node_modules/@aws-sdk/credential-provider-env/dist-es/fromEnv.js
var ENV_KEY, ENV_SECRET, ENV_SESSION, ENV_EXPIRATION, fromEnv;
var init_fromEnv = __esm({
  "../../node_modules/@aws-sdk/credential-provider-env/dist-es/fromEnv.js"() {
    "use strict";
    init_dist_es16();
    ENV_KEY = "AWS_ACCESS_KEY_ID";
    ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
    ENV_SESSION = "AWS_SESSION_TOKEN";
    ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
    fromEnv = () => async () => {
      const accessKeyId = process.env[ENV_KEY];
      const secretAccessKey = process.env[ENV_SECRET];
      const sessionToken = process.env[ENV_SESSION];
      const expiry = process.env[ENV_EXPIRATION];
      if (accessKeyId && secretAccessKey) {
        return {
          accessKeyId,
          secretAccessKey,
          ...sessionToken && { sessionToken },
          ...expiry && { expiration: new Date(expiry) }
        };
      }
      throw new CredentialsProviderError("Unable to find environment variable credentials.");
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-env/dist-es/index.js
var init_dist_es28 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-env/dist-es/index.js"() {
    "use strict";
    init_fromEnv();
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getHomeDir.js
var import_os, import_path, getHomeDir;
var init_getHomeDir = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getHomeDir.js"() {
    "use strict";
    import_os = require("os");
    import_path = require("path");
    getHomeDir = () => {
      const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${import_path.sep}` } = process.env;
      if (HOME)
        return HOME;
      if (USERPROFILE)
        return USERPROFILE;
      if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
      return (0, import_os.homedir)();
    };
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getProfileName.js
var ENV_PROFILE, DEFAULT_PROFILE, getProfileName;
var init_getProfileName = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getProfileName.js"() {
    "use strict";
    ENV_PROFILE = "AWS_PROFILE";
    DEFAULT_PROFILE = "default";
    getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js
var import_crypto2, import_path2, getSSOTokenFilepath;
var init_getSSOTokenFilepath = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js"() {
    "use strict";
    import_crypto2 = require("crypto");
    import_path2 = require("path");
    init_getHomeDir();
    getSSOTokenFilepath = (id) => {
      const hasher = (0, import_crypto2.createHash)("sha1");
      const cacheName = hasher.update(id).digest("hex");
      return (0, import_path2.join)(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
    };
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js
var import_fs, readFile, getSSOTokenFromFile;
var init_getSSOTokenFromFile = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js"() {
    "use strict";
    import_fs = require("fs");
    init_getSSOTokenFilepath();
    ({ readFile } = import_fs.promises);
    getSSOTokenFromFile = async (id) => {
      const ssoTokenFilepath = getSSOTokenFilepath(id);
      const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
      return JSON.parse(ssoTokenText);
    };
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getConfigFilepath.js
var import_path3, ENV_CONFIG_PATH, getConfigFilepath;
var init_getConfigFilepath = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getConfigFilepath.js"() {
    "use strict";
    import_path3 = require("path");
    init_getHomeDir();
    ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
    getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || (0, import_path3.join)(getHomeDir(), ".aws", "config");
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getCredentialsFilepath.js
var import_path4, ENV_CREDENTIALS_PATH, getCredentialsFilepath;
var init_getCredentialsFilepath = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getCredentialsFilepath.js"() {
    "use strict";
    import_path4 = require("path");
    init_getHomeDir();
    ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
    getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || (0, import_path4.join)(getHomeDir(), ".aws", "credentials");
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getProfileData.js
var profileKeyRegex, getProfileData;
var init_getProfileData = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getProfileData.js"() {
    "use strict";
    profileKeyRegex = /^profile\s(["'])?([^\1]+)\1$/;
    getProfileData = (data) => Object.entries(data).filter(([key]) => profileKeyRegex.test(key)).reduce((acc, [key, value]) => ({ ...acc, [profileKeyRegex.exec(key)[2]]: value }), {
      ...data.default && { default: data.default }
    });
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/parseIni.js
var profileNameBlockList, parseIni;
var init_parseIni = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/parseIni.js"() {
    "use strict";
    profileNameBlockList = ["__proto__", "profile __proto__"];
    parseIni = (iniData) => {
      const map6 = {};
      let currentSection;
      for (let line of iniData.split(/\r?\n/)) {
        line = line.split(/(^|\s)[;#]/)[0].trim();
        const isSection = line[0] === "[" && line[line.length - 1] === "]";
        if (isSection) {
          currentSection = line.substring(1, line.length - 1);
          if (profileNameBlockList.includes(currentSection)) {
            throw new Error(`Found invalid profile name "${currentSection}"`);
          }
        } else if (currentSection) {
          const indexOfEqualsSign = line.indexOf("=");
          const start = 0;
          const end = line.length - 1;
          const isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
          if (isAssignment) {
            const [name, value] = [
              line.substring(0, indexOfEqualsSign).trim(),
              line.substring(indexOfEqualsSign + 1).trim()
            ];
            map6[currentSection] = map6[currentSection] || {};
            map6[currentSection][name] = value;
          }
        }
      }
      return map6;
    };
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/slurpFile.js
var import_fs2, readFile2, filePromisesHash, slurpFile;
var init_slurpFile = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/slurpFile.js"() {
    "use strict";
    import_fs2 = require("fs");
    ({ readFile: readFile2 } = import_fs2.promises);
    filePromisesHash = {};
    slurpFile = (path) => {
      if (!filePromisesHash[path]) {
        filePromisesHash[path] = readFile2(path, "utf8");
      }
      return filePromisesHash[path];
    };
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js
var swallowError, loadSharedConfigFiles;
var init_loadSharedConfigFiles = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js"() {
    "use strict";
    init_getConfigFilepath();
    init_getCredentialsFilepath();
    init_getProfileData();
    init_parseIni();
    init_slurpFile();
    swallowError = () => ({});
    loadSharedConfigFiles = async (init = {}) => {
      const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
      const parsedFiles = await Promise.all([
        slurpFile(configFilepath).then(parseIni).then(getProfileData).catch(swallowError),
        slurpFile(filepath).then(parseIni).catch(swallowError)
      ]);
      return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1]
      };
    };
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getSsoSessionData.js
var ssoSessionKeyRegex, getSsoSessionData;
var init_getSsoSessionData = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/getSsoSessionData.js"() {
    "use strict";
    ssoSessionKeyRegex = /^sso-session\s(["'])?([^\1]+)\1$/;
    getSsoSessionData = (data) => Object.entries(data).filter(([key]) => ssoSessionKeyRegex.test(key)).reduce((acc, [key, value]) => ({ ...acc, [ssoSessionKeyRegex.exec(key)[2]]: value }), {});
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/loadSsoSessionData.js
var swallowError2, loadSsoSessionData;
var init_loadSsoSessionData = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/loadSsoSessionData.js"() {
    "use strict";
    init_getConfigFilepath();
    init_getSsoSessionData();
    init_parseIni();
    init_slurpFile();
    swallowError2 = () => ({});
    loadSsoSessionData = async (init = {}) => slurpFile(init.configFilepath ?? getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(swallowError2);
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/parseKnownFiles.js
var parseKnownFiles;
var init_parseKnownFiles = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/parseKnownFiles.js"() {
    "use strict";
    init_loadSharedConfigFiles();
    parseKnownFiles = async (init) => {
      const parsedFiles = await loadSharedConfigFiles(init);
      return {
        ...parsedFiles.configFile,
        ...parsedFiles.credentialsFile
      };
    };
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/types.js
var init_types3 = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/types.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/index.js
var init_dist_es29 = __esm({
  "../../node_modules/@aws-sdk/shared-ini-file-loader/dist-es/index.js"() {
    "use strict";
    init_getHomeDir();
    init_getProfileName();
    init_getSSOTokenFilepath();
    init_getSSOTokenFromFile();
    init_loadSharedConfigFiles();
    init_loadSsoSessionData();
    init_parseKnownFiles();
    init_types3();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/httpRequest.js
function httpRequest(options) {
  return new Promise((resolve, reject) => {
    const req = (0, import_http.request)({
      method: "GET",
      ...options,
      hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
    });
    req.on("error", (err) => {
      reject(Object.assign(new ProviderError("Unable to connect to instance metadata service"), err));
      req.destroy();
    });
    req.on("timeout", () => {
      reject(new ProviderError("TimeoutError from instance metadata service"));
      req.destroy();
    });
    req.on("response", (res) => {
      const { statusCode = 400 } = res;
      if (statusCode < 200 || 300 <= statusCode) {
        reject(Object.assign(new ProviderError("Error response received from instance metadata service"), { statusCode }));
        req.destroy();
      }
      const chunks = [];
      res.on("data", (chunk2) => {
        chunks.push(chunk2);
      });
      res.on("end", () => {
        resolve(import_buffer2.Buffer.concat(chunks));
        req.destroy();
      });
    });
    req.end();
  });
}
var import_buffer2, import_http;
var init_httpRequest2 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/httpRequest.js"() {
    "use strict";
    init_dist_es16();
    import_buffer2 = require("buffer");
    import_http = require("http");
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/ImdsCredentials.js
var isImdsCredentials, fromImdsCredentials;
var init_ImdsCredentials = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/ImdsCredentials.js"() {
    "use strict";
    isImdsCredentials = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string";
    fromImdsCredentials = (creds) => ({
      accessKeyId: creds.AccessKeyId,
      secretAccessKey: creds.SecretAccessKey,
      sessionToken: creds.Token,
      expiration: new Date(creds.Expiration)
    });
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/RemoteProviderInit.js
var DEFAULT_TIMEOUT, DEFAULT_MAX_RETRIES, providerConfigFromInit;
var init_RemoteProviderInit = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/RemoteProviderInit.js"() {
    "use strict";
    DEFAULT_TIMEOUT = 1e3;
    DEFAULT_MAX_RETRIES = 0;
    providerConfigFromInit = ({ maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT }) => ({ maxRetries, timeout });
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/retry.js
var retry;
var init_retry = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/remoteProvider/retry.js"() {
    "use strict";
    retry = (toRetry, maxRetries) => {
      let promise = toRetry();
      for (let i10 = 0; i10 < maxRetries; i10++) {
        promise = promise.catch(toRetry);
      }
      return promise;
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/fromContainerMetadata.js
var import_url, ENV_CMDS_FULL_URI, ENV_CMDS_RELATIVE_URI, ENV_CMDS_AUTH_TOKEN, fromContainerMetadata, requestFromEcsImds, CMDS_IP, GREENGRASS_HOSTS, GREENGRASS_PROTOCOLS, getCmdsUri;
var init_fromContainerMetadata = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/fromContainerMetadata.js"() {
    "use strict";
    init_dist_es16();
    import_url = require("url");
    init_httpRequest2();
    init_ImdsCredentials();
    init_RemoteProviderInit();
    init_retry();
    ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
    ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
    ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
    fromContainerMetadata = (init = {}) => {
      const { timeout, maxRetries } = providerConfigFromInit(init);
      return () => retry(async () => {
        const requestOptions = await getCmdsUri();
        const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
        if (!isImdsCredentials(credsResponse)) {
          throw new CredentialsProviderError("Invalid response received from instance metadata service.");
        }
        return fromImdsCredentials(credsResponse);
      }, maxRetries);
    };
    requestFromEcsImds = async (timeout, options) => {
      if (process.env[ENV_CMDS_AUTH_TOKEN]) {
        options.headers = {
          ...options.headers,
          Authorization: process.env[ENV_CMDS_AUTH_TOKEN]
        };
      }
      const buffer = await httpRequest({
        ...options,
        timeout
      });
      return buffer.toString();
    };
    CMDS_IP = "169.254.170.2";
    GREENGRASS_HOSTS = {
      localhost: true,
      "127.0.0.1": true
    };
    GREENGRASS_PROTOCOLS = {
      "http:": true,
      "https:": true
    };
    getCmdsUri = async () => {
      if (process.env[ENV_CMDS_RELATIVE_URI]) {
        return {
          hostname: CMDS_IP,
          path: process.env[ENV_CMDS_RELATIVE_URI]
        };
      }
      if (process.env[ENV_CMDS_FULL_URI]) {
        const parsed = (0, import_url.parse)(process.env[ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
          throw new CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
          throw new CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);
        }
        return {
          ...parsed,
          port: parsed.port ? parseInt(parsed.port, 10) : void 0
        };
      }
      throw new CredentialsProviderError(`The container metadata credential provider cannot be used unless the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment variable is set`, false);
    };
  }
});

// ../../node_modules/@aws-sdk/node-config-provider/dist-es/fromEnv.js
var fromEnv2;
var init_fromEnv2 = __esm({
  "../../node_modules/@aws-sdk/node-config-provider/dist-es/fromEnv.js"() {
    "use strict";
    init_dist_es16();
    fromEnv2 = (envVarSelector) => async () => {
      try {
        const config = envVarSelector(process.env);
        if (config === void 0) {
          throw new Error();
        }
        return config;
      } catch (e10) {
        throw new CredentialsProviderError(e10.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/node-config-provider/dist-es/fromSharedConfigFiles.js
var fromSharedConfigFiles;
var init_fromSharedConfigFiles = __esm({
  "../../node_modules/@aws-sdk/node-config-provider/dist-es/fromSharedConfigFiles.js"() {
    "use strict";
    init_dist_es16();
    init_dist_es29();
    fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
      const profile = getProfileName(init);
      const { configFile, credentialsFile } = await loadSharedConfigFiles(init);
      const profileFromCredentials = credentialsFile[profile] || {};
      const profileFromConfig = configFile[profile] || {};
      const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
      try {
        const configValue = configSelector(mergedProfile);
        if (configValue === void 0) {
          throw new Error();
        }
        return configValue;
      } catch (e10) {
        throw new CredentialsProviderError(e10.message || `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/node-config-provider/dist-es/fromStatic.js
var isFunction, fromStatic2;
var init_fromStatic2 = __esm({
  "../../node_modules/@aws-sdk/node-config-provider/dist-es/fromStatic.js"() {
    "use strict";
    init_dist_es16();
    isFunction = (func) => typeof func === "function";
    fromStatic2 = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue);
  }
});

// ../../node_modules/@aws-sdk/node-config-provider/dist-es/configLoader.js
var loadConfig;
var init_configLoader = __esm({
  "../../node_modules/@aws-sdk/node-config-provider/dist-es/configLoader.js"() {
    "use strict";
    init_dist_es16();
    init_fromEnv2();
    init_fromSharedConfigFiles();
    init_fromStatic2();
    loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv2(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic2(defaultValue)));
  }
});

// ../../node_modules/@aws-sdk/node-config-provider/dist-es/index.js
var init_dist_es30 = __esm({
  "../../node_modules/@aws-sdk/node-config-provider/dist-es/index.js"() {
    "use strict";
    init_configLoader();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/Endpoint.js
var Endpoint;
var init_Endpoint = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/Endpoint.js"() {
    "use strict";
    (function(Endpoint3) {
      Endpoint3["IPv4"] = "http://169.254.169.254";
      Endpoint3["IPv6"] = "http://[fd00:ec2::254]";
    })(Endpoint || (Endpoint = {}));
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/EndpointConfigOptions.js
var ENV_ENDPOINT_NAME, CONFIG_ENDPOINT_NAME, ENDPOINT_CONFIG_OPTIONS;
var init_EndpointConfigOptions = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/EndpointConfigOptions.js"() {
    "use strict";
    ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
    CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
    ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: (env3) => env3[ENV_ENDPOINT_NAME],
      configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],
      default: void 0
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/EndpointMode.js
var EndpointMode;
var init_EndpointMode = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/EndpointMode.js"() {
    "use strict";
    (function(EndpointMode3) {
      EndpointMode3["IPv4"] = "IPv4";
      EndpointMode3["IPv6"] = "IPv6";
    })(EndpointMode || (EndpointMode = {}));
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/EndpointModeConfigOptions.js
var ENV_ENDPOINT_MODE_NAME, CONFIG_ENDPOINT_MODE_NAME, ENDPOINT_MODE_CONFIG_OPTIONS;
var init_EndpointModeConfigOptions = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/config/EndpointModeConfigOptions.js"() {
    "use strict";
    init_EndpointMode();
    ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
    CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
    ENDPOINT_MODE_CONFIG_OPTIONS = {
      environmentVariableSelector: (env3) => env3[ENV_ENDPOINT_MODE_NAME],
      configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],
      default: EndpointMode.IPv4
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/utils/getInstanceMetadataEndpoint.js
var getInstanceMetadataEndpoint, getFromEndpointConfig, getFromEndpointModeConfig;
var init_getInstanceMetadataEndpoint = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/utils/getInstanceMetadataEndpoint.js"() {
    "use strict";
    init_dist_es30();
    init_dist_es7();
    init_Endpoint();
    init_EndpointConfigOptions();
    init_EndpointMode();
    init_EndpointModeConfigOptions();
    getInstanceMetadataEndpoint = async () => parseUrl(await getFromEndpointConfig() || await getFromEndpointModeConfig());
    getFromEndpointConfig = async () => loadConfig(ENDPOINT_CONFIG_OPTIONS)();
    getFromEndpointModeConfig = async () => {
      const endpointMode = await loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();
      switch (endpointMode) {
        case EndpointMode.IPv4:
          return Endpoint.IPv4;
        case EndpointMode.IPv6:
          return Endpoint.IPv6;
        default:
          throw new Error(`Unsupported endpoint mode: ${endpointMode}. Select from ${Object.values(EndpointMode)}`);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/utils/getExtendedInstanceMetadataCredentials.js
var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS, STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS, STATIC_STABILITY_DOC_URL, getExtendedInstanceMetadataCredentials;
var init_getExtendedInstanceMetadataCredentials = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/utils/getExtendedInstanceMetadataCredentials.js"() {
    "use strict";
    STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
    STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
    STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
    getExtendedInstanceMetadataCredentials = (credentials, logger3) => {
      const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
      const newExpiration = new Date(Date.now() + refreshInterval * 1e3);
      logger3.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: " + STATIC_STABILITY_DOC_URL);
      const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
      return {
        ...credentials,
        ...originalExpiration ? { originalExpiration } : {},
        expiration: newExpiration
      };
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/utils/staticStabilityProvider.js
var staticStabilityProvider;
var init_staticStabilityProvider = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/utils/staticStabilityProvider.js"() {
    "use strict";
    init_getExtendedInstanceMetadataCredentials();
    staticStabilityProvider = (provider, options = {}) => {
      const logger3 = options?.logger || console;
      let pastCredentials;
      return async () => {
        let credentials;
        try {
          credentials = await provider();
          if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
            credentials = getExtendedInstanceMetadataCredentials(credentials, logger3);
          }
        } catch (e10) {
          if (pastCredentials) {
            logger3.warn("Credential renew failed: ", e10);
            credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger3);
          } else {
            throw e10;
          }
        }
        pastCredentials = credentials;
        return credentials;
      };
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/fromInstanceMetadata.js
var IMDS_PATH, IMDS_TOKEN_PATH, fromInstanceMetadata, getInstanceImdsProvider, getMetadataToken, getProfile, getCredentialsFromProfile;
var init_fromInstanceMetadata = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/fromInstanceMetadata.js"() {
    "use strict";
    init_dist_es16();
    init_httpRequest2();
    init_ImdsCredentials();
    init_RemoteProviderInit();
    init_retry();
    init_getInstanceMetadataEndpoint();
    init_staticStabilityProvider();
    IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
    IMDS_TOKEN_PATH = "/latest/api/token";
    fromInstanceMetadata = (init = {}) => staticStabilityProvider(getInstanceImdsProvider(init), { logger: init.logger });
    getInstanceImdsProvider = (init) => {
      let disableFetchToken = false;
      const { timeout, maxRetries } = providerConfigFromInit(init);
      const getCredentials = async (maxRetries2, options) => {
        const profile = (await retry(async () => {
          let profile2;
          try {
            profile2 = await getProfile(options);
          } catch (err) {
            if (err.statusCode === 401) {
              disableFetchToken = false;
            }
            throw err;
          }
          return profile2;
        }, maxRetries2)).trim();
        return retry(async () => {
          let creds;
          try {
            creds = await getCredentialsFromProfile(profile, options);
          } catch (err) {
            if (err.statusCode === 401) {
              disableFetchToken = false;
            }
            throw err;
          }
          return creds;
        }, maxRetries2);
      };
      return async () => {
        const endpoint = await getInstanceMetadataEndpoint();
        if (disableFetchToken) {
          return getCredentials(maxRetries, { ...endpoint, timeout });
        } else {
          let token;
          try {
            token = (await getMetadataToken({ ...endpoint, timeout })).toString();
          } catch (error) {
            if (error?.statusCode === 400) {
              throw Object.assign(error, {
                message: "EC2 Metadata token request returned error"
              });
            } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
              disableFetchToken = true;
            }
            return getCredentials(maxRetries, { ...endpoint, timeout });
          }
          return getCredentials(maxRetries, {
            ...endpoint,
            headers: {
              "x-aws-ec2-metadata-token": token
            },
            timeout
          });
        }
      };
    };
    getMetadataToken = async (options) => httpRequest({
      ...options,
      path: IMDS_TOKEN_PATH,
      method: "PUT",
      headers: {
        "x-aws-ec2-metadata-token-ttl-seconds": "21600"
      }
    });
    getProfile = async (options) => (await httpRequest({ ...options, path: IMDS_PATH })).toString();
    getCredentialsFromProfile = async (profile, options) => {
      const credsResponse = JSON.parse((await httpRequest({
        ...options,
        path: IMDS_PATH + profile
      })).toString());
      if (!isImdsCredentials(credsResponse)) {
        throw new CredentialsProviderError("Invalid response received from instance metadata service.");
      }
      return fromImdsCredentials(credsResponse);
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/types.js
var init_types4 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/types.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/credential-provider-imds/dist-es/index.js
var init_dist_es31 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-imds/dist-es/index.js"() {
    "use strict";
    init_fromContainerMetadata();
    init_fromInstanceMetadata();
    init_RemoteProviderInit();
    init_types4();
    init_httpRequest2();
    init_getInstanceMetadataEndpoint();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js
var resolveCredentialSource;
var init_resolveCredentialSource = __esm({
  "../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js"() {
    "use strict";
    init_dist_es28();
    init_dist_es31();
    init_dist_es16();
    resolveCredentialSource = (credentialSource, profileName) => {
      const sourceProvidersMap = {
        EcsContainer: fromContainerMetadata,
        Ec2InstanceMetadata: fromInstanceMetadata,
        Environment: fromEnv
      };
      if (credentialSource in sourceProvidersMap) {
        return sourceProvidersMap[credentialSource]();
      } else {
        throw new CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js
var isAssumeRoleProfile, isAssumeRoleWithSourceProfile, isAssumeRoleWithProviderProfile, resolveAssumeRoleCredentials;
var init_resolveAssumeRoleCredentials = __esm({
  "../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js"() {
    "use strict";
    init_dist_es16();
    init_dist_es29();
    init_resolveCredentialSource();
    init_resolveProfileData();
    isAssumeRoleProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg) || isAssumeRoleWithProviderProfile(arg));
    isAssumeRoleWithSourceProfile = (arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
    isAssumeRoleWithProviderProfile = (arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
    resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}) => {
      const data = profiles[profileName];
      if (!options.roleAssumer) {
        throw new CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
      }
      const { source_profile } = data;
      if (source_profile && source_profile in visitedProfiles) {
        throw new CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), false);
      }
      const sourceCredsProvider = source_profile ? resolveProfileData(source_profile, profiles, options, {
        ...visitedProfiles,
        [source_profile]: true
      }) : resolveCredentialSource(data.credential_source, profileName)();
      const params = {
        RoleArn: data.role_arn,
        RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
        ExternalId: data.external_id
      };
      const { mfa_serial } = data;
      if (mfa_serial) {
        if (!options.mfaCodeProvider) {
          throw new CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
        }
        params.SerialNumber = mfa_serial;
        params.TokenCode = await options.mfaCodeProvider(mfa_serial);
      }
      const sourceCreds = await sourceCredsProvider;
      return options.roleAssumer(sourceCreds, params);
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/getValidatedProcessCredentials.js
var getValidatedProcessCredentials;
var init_getValidatedProcessCredentials = __esm({
  "../../node_modules/@aws-sdk/credential-provider-process/dist-es/getValidatedProcessCredentials.js"() {
    "use strict";
    getValidatedProcessCredentials = (profileName, data) => {
      if (data.Version !== 1) {
        throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
      }
      if (data.AccessKeyId === void 0 || data.SecretAccessKey === void 0) {
        throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
      }
      if (data.Expiration) {
        const currentTime = /* @__PURE__ */ new Date();
        const expireTime = new Date(data.Expiration);
        if (expireTime < currentTime) {
          throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
        }
      }
      return {
        accessKeyId: data.AccessKeyId,
        secretAccessKey: data.SecretAccessKey,
        ...data.SessionToken && { sessionToken: data.SessionToken },
        ...data.Expiration && { expiration: new Date(data.Expiration) }
      };
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
var import_child_process, import_util3, resolveProcessCredentials;
var init_resolveProcessCredentials = __esm({
  "../../node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js"() {
    "use strict";
    init_dist_es16();
    import_child_process = require("child_process");
    import_util3 = require("util");
    init_getValidatedProcessCredentials();
    resolveProcessCredentials = async (profileName, profiles) => {
      const profile = profiles[profileName];
      if (profiles[profileName]) {
        const credentialProcess = profile["credential_process"];
        if (credentialProcess !== void 0) {
          const execPromise = (0, import_util3.promisify)(import_child_process.exec);
          try {
            const { stdout } = await execPromise(credentialProcess);
            let data;
            try {
              data = JSON.parse(stdout.trim());
            } catch {
              throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
            }
            return getValidatedProcessCredentials(profileName, data);
          } catch (error) {
            throw new CredentialsProviderError(error.message);
          }
        } else {
          throw new CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
        }
      } else {
        throw new CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/fromProcess.js
var fromProcess;
var init_fromProcess = __esm({
  "../../node_modules/@aws-sdk/credential-provider-process/dist-es/fromProcess.js"() {
    "use strict";
    init_dist_es29();
    init_resolveProcessCredentials();
    fromProcess = (init = {}) => async () => {
      const profiles = await parseKnownFiles(init);
      return resolveProcessCredentials(getProfileName(init), profiles);
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/index.js
var init_dist_es32 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-process/dist-es/index.js"() {
    "use strict";
    init_fromProcess();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js
var isProcessProfile, resolveProcessCredentials2;
var init_resolveProcessCredentials2 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js"() {
    "use strict";
    init_dist_es32();
    isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
    resolveProcessCredentials2 = async (options, profile) => fromProcess({
      ...options,
      profile
    })();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js
var isSsoProfile;
var init_isSsoProfile = __esm({
  "../../node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js"() {
    "use strict";
    isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js
var SSOServiceException;
var init_SSOServiceException = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js"() {
    "use strict";
    init_dist_es26();
    SSOServiceException = class _SSOServiceException extends ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _SSOServiceException.prototype);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js
var InvalidRequestException, ResourceNotFoundException, TooManyRequestsException, UnauthorizedException, GetRoleCredentialsRequestFilterSensitiveLog, RoleCredentialsFilterSensitiveLog, GetRoleCredentialsResponseFilterSensitiveLog;
var init_models_02 = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js"() {
    "use strict";
    init_dist_es26();
    init_SSOServiceException();
    InvalidRequestException = class _InvalidRequestException extends SSOServiceException {
      constructor(opts) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...opts
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidRequestException.prototype);
      }
    };
    ResourceNotFoundException = class _ResourceNotFoundException extends SSOServiceException {
      constructor(opts) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...opts
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
      }
    };
    TooManyRequestsException = class _TooManyRequestsException extends SSOServiceException {
      constructor(opts) {
        super({
          name: "TooManyRequestsException",
          $fault: "client",
          ...opts
        });
        this.name = "TooManyRequestsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _TooManyRequestsException.prototype);
      }
    };
    UnauthorizedException = class _UnauthorizedException extends SSOServiceException {
      constructor(opts) {
        super({
          name: "UnauthorizedException",
          $fault: "client",
          ...opts
        });
        this.name = "UnauthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _UnauthorizedException.prototype);
      }
    };
    GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.accessToken && { accessToken: SENSITIVE_STRING }
    });
    RoleCredentialsFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.secretAccessKey && { secretAccessKey: SENSITIVE_STRING },
      ...obj.sessionToken && { sessionToken: SENSITIVE_STRING }
    });
    GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog(obj.roleCredentials) }
    });
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js
var serializeAws_restJson1GetRoleCredentialsCommand, deserializeAws_restJson1GetRoleCredentialsCommand, deserializeAws_restJson1GetRoleCredentialsCommandError, map3, deserializeAws_restJson1InvalidRequestExceptionResponse, deserializeAws_restJson1ResourceNotFoundExceptionResponse, deserializeAws_restJson1TooManyRequestsExceptionResponse, deserializeAws_restJson1UnauthorizedExceptionResponse, deserializeAws_restJson1RoleCredentials, deserializeMetadata3, collectBody2, collectBodyString2, isSerializableHeaderValue, parseBody2, parseErrorBody2, loadRestJsonErrorCode;
var init_Aws_restJson1 = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js"() {
    "use strict";
    init_dist_es4();
    init_dist_es26();
    init_models_02();
    init_SSOServiceException();
    serializeAws_restJson1GetRoleCredentialsCommand = async (input, context) => {
      const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
      const headers = map3({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken
      });
      const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/federation/credentials`;
      const query = map3({
        role_name: [, expectNonNull(input.roleName, `roleName`)],
        account_id: [, expectNonNull(input.accountId, `accountId`)]
      });
      let body;
      return new HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body
      });
    };
    deserializeAws_restJson1GetRoleCredentialsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetRoleCredentialsCommandError(output, context);
      }
      const contents = map3({
        $metadata: deserializeMetadata3(output)
      });
      const data = expectNonNull(expectObject(await parseBody2(output.body, context)), "body");
      if (data.roleCredentials != null) {
        contents.roleCredentials = deserializeAws_restJson1RoleCredentials(data.roleCredentials, context);
      }
      return contents;
    };
    deserializeAws_restJson1GetRoleCredentialsCommandError = async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await parseErrorBody2(output.body, context)
      };
      const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
      switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
          throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
          throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
          throw await deserializeAws_restJson1TooManyRequestsExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
          throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          throwDefaultError({
            output,
            parsedBody,
            exceptionCtor: SSOServiceException,
            errorCode
          });
      }
    };
    map3 = map2;
    deserializeAws_restJson1InvalidRequestExceptionResponse = async (parsedOutput, context) => {
      const contents = map3({});
      const data = parsedOutput.body;
      if (data.message != null) {
        contents.message = expectString(data.message);
      }
      const exception = new InvalidRequestException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
      const contents = map3({});
      const data = parsedOutput.body;
      if (data.message != null) {
        contents.message = expectString(data.message);
      }
      const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1TooManyRequestsExceptionResponse = async (parsedOutput, context) => {
      const contents = map3({});
      const data = parsedOutput.body;
      if (data.message != null) {
        contents.message = expectString(data.message);
      }
      const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1UnauthorizedExceptionResponse = async (parsedOutput, context) => {
      const contents = map3({});
      const data = parsedOutput.body;
      if (data.message != null) {
        contents.message = expectString(data.message);
      }
      const exception = new UnauthorizedException({
        $metadata: deserializeMetadata3(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1RoleCredentials = (output, context) => {
      return {
        accessKeyId: expectString(output.accessKeyId),
        expiration: expectLong(output.expiration),
        secretAccessKey: expectString(output.secretAccessKey),
        sessionToken: expectString(output.sessionToken)
      };
    };
    deserializeMetadata3 = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
    collectBody2 = (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
      }
      return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
    };
    collectBodyString2 = (streamBody, context) => collectBody2(streamBody, context).then((body) => context.utf8Encoder(body));
    isSerializableHeaderValue = (value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
    parseBody2 = (streamBody, context) => collectBodyString2(streamBody, context).then((encoded) => {
      if (encoded.length) {
        return JSON.parse(encoded);
      }
      return {};
    });
    parseErrorBody2 = async (errorBody, context) => {
      const value = await parseBody2(errorBody, context);
      value.message = value.message ?? value.Message;
      return value;
    };
    loadRestJsonErrorCode = (output, data) => {
      const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
      const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
          cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
          cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
          cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
          cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
      };
      const headerKey = findKey(output.headers, "x-amzn-errortype");
      if (headerKey !== void 0) {
        return sanitizeErrorCode(output.headers[headerKey]);
      }
      if (data.code !== void 0) {
        return sanitizeErrorCode(data.code);
      }
      if (data["__type"] !== void 0) {
        return sanitizeErrorCode(data["__type"]);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js
var GetRoleCredentialsCommand;
var init_GetRoleCredentialsCommand = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
    init_models_02();
    init_Aws_restJson1();
    GetRoleCredentialsCommand = class _GetRoleCredentialsCommand extends Command {
      constructor(input) {
        super();
        this.input = input;
      }
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
          Endpoint: { type: "builtInParams", name: "endpoint" },
          Region: { type: "builtInParams", name: "region" },
          UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
        };
      }
      resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use(getEndpointPlugin(configuration, _GetRoleCredentialsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger: logger3 } = configuration;
        const clientName = "SSOClient";
        const commandName = "GetRoleCredentialsCommand";
        const handlerExecutionContext = {
          logger: logger3,
          clientName,
          commandName,
          inputFilterSensitiveLog: GetRoleCredentialsRequestFilterSensitiveLog,
          outputFilterSensitiveLog: GetRoleCredentialsResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
      }
      serialize(input, context) {
        return serializeAws_restJson1GetRoleCredentialsCommand(input, context);
      }
      deserialize(output, context) {
        return deserializeAws_restJson1GetRoleCredentialsCommand(output, context);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/ListAccountRolesCommand.js
var init_ListAccountRolesCommand = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/commands/ListAccountRolesCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/ListAccountsCommand.js
var init_ListAccountsCommand = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/commands/ListAccountsCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/LogoutCommand.js
var init_LogoutCommand = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/commands/LogoutCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters3;
var init_EndpointParameters3 = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js"() {
    "use strict";
    resolveClientEndpointParameters3 = (options) => {
      return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssoportal"
      };
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso/package.json
var package_default3;
var init_package3 = __esm({
  "../../node_modules/@aws-sdk/client-sso/package.json"() {
    package_default3 = {
      name: "@aws-sdk/client-sso",
      description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
      version: "3.272.0",
      scripts: {
        build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "tsc -p tsconfig.cjs.json",
        "build:docs": "typedoc",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: false,
      dependencies: {
        "@aws-crypto/sha256-browser": "3.0.0",
        "@aws-crypto/sha256-js": "3.0.0",
        "@aws-sdk/config-resolver": "3.272.0",
        "@aws-sdk/fetch-http-handler": "3.272.0",
        "@aws-sdk/hash-node": "3.272.0",
        "@aws-sdk/invalid-dependency": "3.272.0",
        "@aws-sdk/middleware-content-length": "3.272.0",
        "@aws-sdk/middleware-endpoint": "3.272.0",
        "@aws-sdk/middleware-host-header": "3.272.0",
        "@aws-sdk/middleware-logger": "3.272.0",
        "@aws-sdk/middleware-recursion-detection": "3.272.0",
        "@aws-sdk/middleware-retry": "3.272.0",
        "@aws-sdk/middleware-serde": "3.272.0",
        "@aws-sdk/middleware-stack": "3.272.0",
        "@aws-sdk/middleware-user-agent": "3.272.0",
        "@aws-sdk/node-config-provider": "3.272.0",
        "@aws-sdk/node-http-handler": "3.272.0",
        "@aws-sdk/protocol-http": "3.272.0",
        "@aws-sdk/smithy-client": "3.272.0",
        "@aws-sdk/types": "3.272.0",
        "@aws-sdk/url-parser": "3.272.0",
        "@aws-sdk/util-base64": "3.208.0",
        "@aws-sdk/util-body-length-browser": "3.188.0",
        "@aws-sdk/util-body-length-node": "3.208.0",
        "@aws-sdk/util-defaults-mode-browser": "3.272.0",
        "@aws-sdk/util-defaults-mode-node": "3.272.0",
        "@aws-sdk/util-endpoints": "3.272.0",
        "@aws-sdk/util-retry": "3.272.0",
        "@aws-sdk/util-user-agent-browser": "3.272.0",
        "@aws-sdk/util-user-agent-node": "3.272.0",
        "@aws-sdk/util-utf8": "3.254.0",
        tslib: "^2.3.1"
      },
      devDependencies: {
        "@aws-sdk/service-client-documentation-generator": "3.208.0",
        "@tsconfig/node14": "1.0.3",
        "@types/node": "^14.14.31",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typedoc: "0.19.2",
        typescript: "~4.6.2"
      },
      overrides: {
        typedoc: {
          typescript: "~4.6.2"
        }
      },
      engines: {
        node: ">=14.0.0"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "dist-*"
      ],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      browser: {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
      },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
      },
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-sso"
      }
    };
  }
});

// ../../node_modules/@aws-sdk/hash-node/dist-es/index.js
function castSourceData(toCast, encoding) {
  if (import_buffer3.Buffer.isBuffer(toCast)) {
    return toCast;
  }
  if (typeof toCast === "string") {
    return fromString(toCast, encoding);
  }
  if (ArrayBuffer.isView(toCast)) {
    return fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
  }
  return fromArrayBuffer(toCast);
}
var import_buffer3, import_crypto3, Hash;
var init_dist_es33 = __esm({
  "../../node_modules/@aws-sdk/hash-node/dist-es/index.js"() {
    "use strict";
    init_dist_es19();
    init_dist_es20();
    import_buffer3 = require("buffer");
    import_crypto3 = require("crypto");
    Hash = class {
      constructor(algorithmIdentifier, secret) {
        this.algorithmIdentifier = algorithmIdentifier;
        this.secret = secret;
        this.reset();
      }
      update(toHash, encoding) {
        this.hash.update(toUint8Array(castSourceData(toHash, encoding)));
      }
      digest() {
        return Promise.resolve(this.hash.digest());
      }
      reset() {
        this.hash = this.secret ? (0, import_crypto3.createHmac)(this.algorithmIdentifier, castSourceData(this.secret)) : (0, import_crypto3.createHash)(this.algorithmIdentifier);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/querystring-builder/dist-es/index.js
function buildQueryString(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = escapeUri(key);
    if (Array.isArray(value)) {
      for (let i10 = 0, iLen = value.length; i10 < iLen; i10++) {
        parts.push(`${key}=${escapeUri(value[i10])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}
var init_dist_es34 = __esm({
  "../../node_modules/@aws-sdk/querystring-builder/dist-es/index.js"() {
    "use strict";
    init_dist_es21();
  }
});

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/constants.js
var NODEJS_TIMEOUT_ERROR_CODES2;
var init_constants6 = __esm({
  "../../node_modules/@aws-sdk/node-http-handler/dist-es/constants.js"() {
    "use strict";
    NODEJS_TIMEOUT_ERROR_CODES2 = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  }
});

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/get-transformed-headers.js
var getTransformedHeaders;
var init_get_transformed_headers = __esm({
  "../../node_modules/@aws-sdk/node-http-handler/dist-es/get-transformed-headers.js"() {
    "use strict";
    getTransformedHeaders = (headers) => {
      const transformedHeaders = {};
      for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
      }
      return transformedHeaders;
    };
  }
});

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/set-connection-timeout.js
var setConnectionTimeout;
var init_set_connection_timeout = __esm({
  "../../node_modules/@aws-sdk/node-http-handler/dist-es/set-connection-timeout.js"() {
    "use strict";
    setConnectionTimeout = (request3, reject, timeoutInMs = 0) => {
      if (!timeoutInMs) {
        return;
      }
      request3.on("socket", (socket) => {
        if (socket.connecting) {
          const timeoutId = setTimeout(() => {
            request3.destroy();
            reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
              name: "TimeoutError"
            }));
          }, timeoutInMs);
          socket.on("connect", () => {
            clearTimeout(timeoutId);
          });
        }
      });
    };
  }
});

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/set-socket-timeout.js
var setSocketTimeout;
var init_set_socket_timeout = __esm({
  "../../node_modules/@aws-sdk/node-http-handler/dist-es/set-socket-timeout.js"() {
    "use strict";
    setSocketTimeout = (request3, reject, timeoutInMs = 0) => {
      request3.setTimeout(timeoutInMs, () => {
        request3.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
      });
    };
  }
});

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/write-request-body.js
function writeRequestBody(httpRequest3, request3) {
  const expect = request3.headers["Expect"] || request3.headers["expect"];
  if (expect === "100-continue") {
    httpRequest3.on("continue", () => {
      writeBody(httpRequest3, request3.body);
    });
  } else {
    writeBody(httpRequest3, request3.body);
  }
}
function writeBody(httpRequest3, body) {
  if (body instanceof import_stream.Readable) {
    body.pipe(httpRequest3);
  } else if (body) {
    httpRequest3.end(Buffer.from(body));
  } else {
    httpRequest3.end();
  }
}
var import_stream;
var init_write_request_body = __esm({
  "../../node_modules/@aws-sdk/node-http-handler/dist-es/write-request-body.js"() {
    "use strict";
    import_stream = require("stream");
  }
});

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/node-http-handler.js
var import_http2, import_https, NodeHttpHandler;
var init_node_http_handler = __esm({
  "../../node_modules/@aws-sdk/node-http-handler/dist-es/node-http-handler.js"() {
    "use strict";
    init_dist_es4();
    init_dist_es34();
    import_http2 = require("http");
    import_https = require("https");
    init_constants6();
    init_get_transformed_headers();
    init_set_connection_timeout();
    init_set_socket_timeout();
    init_write_request_body();
    NodeHttpHandler = class {
      constructor(options) {
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
          if (typeof options === "function") {
            options().then((_options) => {
              resolve(this.resolveDefaultConfig(_options));
            }).catch(reject);
          } else {
            resolve(this.resolveDefaultConfig(options));
          }
        });
      }
      resolveDefaultConfig(options) {
        const { connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
          connectionTimeout,
          socketTimeout,
          httpAgent: httpAgent || new import_http2.Agent({ keepAlive, maxSockets }),
          httpsAgent: httpsAgent || new import_https.Agent({ keepAlive, maxSockets })
        };
      }
      destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
      }
      async handle(request3, { abortSignal } = {}) {
        if (!this.config) {
          this.config = await this.configProvider;
        }
        return new Promise((resolve, reject) => {
          if (!this.config) {
            throw new Error("Node HTTP request handler config is not resolved");
          }
          if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
            return;
          }
          const isSSL = request3.protocol === "https:";
          const queryString = buildQueryString(request3.query || {});
          const nodeHttpsOptions = {
            headers: request3.headers,
            host: request3.hostname,
            method: request3.method,
            path: queryString ? `${request3.path}?${queryString}` : request3.path,
            port: request3.port,
            agent: isSSL ? this.config.httpsAgent : this.config.httpAgent
          };
          const requestFunc = isSSL ? import_https.request : import_http2.request;
          const req = requestFunc(nodeHttpsOptions, (res) => {
            const httpResponse = new HttpResponse({
              statusCode: res.statusCode || -1,
              headers: getTransformedHeaders(res.headers),
              body: res
            });
            resolve({ response: httpResponse });
          });
          req.on("error", (err) => {
            if (NODEJS_TIMEOUT_ERROR_CODES2.includes(err.code)) {
              reject(Object.assign(err, { name: "TimeoutError" }));
            } else {
              reject(err);
            }
          });
          setConnectionTimeout(req, reject, this.config.connectionTimeout);
          setSocketTimeout(req, reject, this.config.socketTimeout);
          if (abortSignal) {
            abortSignal.onabort = () => {
              req.abort();
              const abortError = new Error("Request aborted");
              abortError.name = "AbortError";
              reject(abortError);
            };
          }
          writeRequestBody(req, request3);
        });
      }
    };
  }
});

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/node-http2-handler.js
var init_node_http2_handler = __esm({
  "../../node_modules/@aws-sdk/node-http-handler/dist-es/node-http2-handler.js"() {
    "use strict";
    init_dist_es4();
    init_dist_es34();
    init_get_transformed_headers();
    init_write_request_body();
  }
});

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/stream-collector/collector.js
var import_stream2, Collector;
var init_collector = __esm({
  "../../node_modules/@aws-sdk/node-http-handler/dist-es/stream-collector/collector.js"() {
    "use strict";
    import_stream2 = require("stream");
    Collector = class extends import_stream2.Writable {
      constructor() {
        super(...arguments);
        this.bufferedBytes = [];
      }
      _write(chunk2, encoding, callback) {
        this.bufferedBytes.push(chunk2);
        callback();
      }
    };
  }
});

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/stream-collector/index.js
var streamCollector;
var init_stream_collector = __esm({
  "../../node_modules/@aws-sdk/node-http-handler/dist-es/stream-collector/index.js"() {
    "use strict";
    init_collector();
    streamCollector = (stream) => new Promise((resolve, reject) => {
      const collector = new Collector();
      stream.pipe(collector);
      stream.on("error", (err) => {
        collector.end();
        reject(err);
      });
      collector.on("error", reject);
      collector.on("finish", function() {
        const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
        resolve(bytes);
      });
    });
  }
});

// ../../node_modules/@aws-sdk/node-http-handler/dist-es/index.js
var init_dist_es35 = __esm({
  "../../node_modules/@aws-sdk/node-http-handler/dist-es/index.js"() {
    "use strict";
    init_node_http_handler();
    init_node_http2_handler();
    init_stream_collector();
  }
});

// ../../node_modules/@aws-sdk/util-body-length-node/dist-es/calculateBodyLength.js
var import_fs3, calculateBodyLength;
var init_calculateBodyLength = __esm({
  "../../node_modules/@aws-sdk/util-body-length-node/dist-es/calculateBodyLength.js"() {
    "use strict";
    import_fs3 = require("fs");
    calculateBodyLength = (body) => {
      if (!body) {
        return 0;
      }
      if (typeof body === "string") {
        return Buffer.from(body).length;
      } else if (typeof body.byteLength === "number") {
        return body.byteLength;
      } else if (typeof body.size === "number") {
        return body.size;
      } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
        return (0, import_fs3.lstatSync)(body.path).size;
      } else if (typeof body.fd === "number") {
        return (0, import_fs3.fstatSync)(body.fd).size;
      }
      throw new Error(`Body Length computation failed for ${body}`);
    };
  }
});

// ../../node_modules/@aws-sdk/util-body-length-node/dist-es/index.js
var init_dist_es36 = __esm({
  "../../node_modules/@aws-sdk/util-body-length-node/dist-es/index.js"() {
    "use strict";
    init_calculateBodyLength();
  }
});

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js
var isCrtAvailable;
var init_is_crt_available = __esm({
  "../../node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js"() {
    "use strict";
    isCrtAvailable = () => {
      try {
        if (typeof require === "function" && typeof module !== "undefined" && module.require && require("aws-crt")) {
          return ["md/crt-avail"];
        }
        return null;
      } catch (e10) {
        return null;
      }
    };
  }
});

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var import_os2, import_process, UA_APP_ID_ENV_NAME, UA_APP_ID_INI_NAME, defaultUserAgent;
var init_dist_es37 = __esm({
  "../../node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js"() {
    "use strict";
    init_dist_es30();
    import_os2 = require("os");
    import_process = require("process");
    init_is_crt_available();
    UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
    UA_APP_ID_INI_NAME = "sdk-ua-app-id";
    defaultUserAgent = ({ serviceId, clientVersion }) => {
      const sections = [
        ["aws-sdk-js", clientVersion],
        [`os/${(0, import_os2.platform)()}`, (0, import_os2.release)()],
        ["lang/js"],
        ["md/nodejs", `${import_process.versions.node}`]
      ];
      const crtAvailable = isCrtAvailable();
      if (crtAvailable) {
        sections.push(crtAvailable);
      }
      if (serviceId) {
        sections.push([`api/${serviceId}`, clientVersion]);
      }
      if (import_process.env.AWS_EXECUTION_ENV) {
        sections.push([`exec-env/${import_process.env.AWS_EXECUTION_ENV}`]);
      }
      const appIdPromise = loadConfig({
        environmentVariableSelector: (env3) => env3[UA_APP_ID_ENV_NAME],
        configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME],
        default: void 0
      })();
      let resolvedUserAgent = void 0;
      return async () => {
        if (!resolvedUserAgent) {
          const appId = await appIdPromise;
          resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
        }
        return resolvedUserAgent;
      };
    };
  }
});

// ../../node_modules/@aws-sdk/util-base64/dist-es/fromBase64.js
var BASE64_REGEX, fromBase64;
var init_fromBase64 = __esm({
  "../../node_modules/@aws-sdk/util-base64/dist-es/fromBase64.js"() {
    "use strict";
    init_dist_es19();
    BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
    fromBase64 = (input) => {
      if (input.length * 3 % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
      }
      if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
      }
      const buffer = fromString(input, "base64");
      return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    };
  }
});

// ../../node_modules/@aws-sdk/util-base64/dist-es/toBase64.js
var toBase64;
var init_toBase64 = __esm({
  "../../node_modules/@aws-sdk/util-base64/dist-es/toBase64.js"() {
    "use strict";
    init_dist_es19();
    toBase64 = (input) => fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
  }
});

// ../../node_modules/@aws-sdk/util-base64/dist-es/index.js
var init_dist_es38 = __esm({
  "../../node_modules/@aws-sdk/util-base64/dist-es/index.js"() {
    "use strict";
    init_fromBase64();
    init_toBase64();
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default;
var init_partitions = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json"() {
    partitions_default = {
      partitions: [{
        id: "aws",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          name: "aws",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af)\\-\\w+\\-\\d+$",
        regions: {
          "af-south-1": {
            description: "Africa (Cape Town)"
          },
          "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
          },
          "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
          },
          "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
          },
          "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
          },
          "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
          },
          "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
          },
          "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
          },
          "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
          },
          "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
          },
          "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
          },
          "aws-global": {
            description: "AWS Standard global region"
          },
          "ca-central-1": {
            description: "Canada (Central)"
          },
          "eu-central-1": {
            description: "Europe (Frankfurt)"
          },
          "eu-central-2": {
            description: "Europe (Zurich)"
          },
          "eu-north-1": {
            description: "Europe (Stockholm)"
          },
          "eu-south-1": {
            description: "Europe (Milan)"
          },
          "eu-south-2": {
            description: "Europe (Spain)"
          },
          "eu-west-1": {
            description: "Europe (Ireland)"
          },
          "eu-west-2": {
            description: "Europe (London)"
          },
          "eu-west-3": {
            description: "Europe (Paris)"
          },
          "me-central-1": {
            description: "Middle East (UAE)"
          },
          "me-south-1": {
            description: "Middle East (Bahrain)"
          },
          "sa-east-1": {
            description: "South America (Sao Paulo)"
          },
          "us-east-1": {
            description: "US East (N. Virginia)"
          },
          "us-east-2": {
            description: "US East (Ohio)"
          },
          "us-west-1": {
            description: "US West (N. California)"
          },
          "us-west-2": {
            description: "US West (Oregon)"
          }
        }
      }, {
        id: "aws-cn",
        outputs: {
          dnsSuffix: "amazonaws.com.cn",
          dualStackDnsSuffix: "api.amazonwebservices.com.cn",
          name: "aws-cn",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: {
          "aws-cn-global": {
            description: "AWS China global region"
          },
          "cn-north-1": {
            description: "China (Beijing)"
          },
          "cn-northwest-1": {
            description: "China (Ningxia)"
          }
        }
      }, {
        id: "aws-us-gov",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          name: "aws-us-gov",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
        regions: {
          "aws-us-gov-global": {
            description: "AWS GovCloud (US) global region"
          },
          "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
          },
          "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
          }
        }
      }, {
        id: "aws-iso",
        outputs: {
          dnsSuffix: "c2s.ic.gov",
          dualStackDnsSuffix: "c2s.ic.gov",
          name: "aws-iso",
          supportsDualStack: false,
          supportsFIPS: true
        },
        regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-global": {
            description: "AWS ISO (US) global region"
          },
          "us-iso-east-1": {
            description: "US ISO East"
          },
          "us-iso-west-1": {
            description: "US ISO WEST"
          }
        }
      }, {
        id: "aws-iso-b",
        outputs: {
          dnsSuffix: "sc2s.sgov.gov",
          dualStackDnsSuffix: "sc2s.sgov.gov",
          name: "aws-iso-b",
          supportsDualStack: false,
          supportsFIPS: true
        },
        regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-b-global": {
            description: "AWS ISOB (US) global region"
          },
          "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
          }
        }
      }],
      version: "1.1"
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var partitions, DEFAULT_PARTITION, partition;
var init_partition = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js"() {
    "use strict";
    init_partitions();
    ({ partitions } = partitions_default);
    DEFAULT_PARTITION = partitions.find((partition3) => partition3.id === "aws");
    partition = (value) => {
      for (const partition3 of partitions) {
        const { regions, outputs } = partition3;
        for (const [region, regionData] of Object.entries(regions)) {
          if (region === value) {
            return {
              ...outputs,
              ...regionData
            };
          }
        }
      }
      for (const partition3 of partitions) {
        const { regionRegex, outputs } = partition3;
        if (new RegExp(regionRegex).test(value)) {
          return {
            ...outputs
          };
        }
      }
      if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
      }
      return {
        ...DEFAULT_PARTITION.outputs
      };
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/debug/debugId.js
var debugId;
var init_debugId = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/debug/debugId.js"() {
    "use strict";
    debugId = "endpoints";
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}
var init_toDebugString = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/debug/toDebugString.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/debug/index.js
var init_debug = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/debug/index.js"() {
    "use strict";
    init_debugId();
    init_toDebugString();
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
var EndpointError;
var init_EndpointError = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js"() {
    "use strict";
    EndpointError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "EndpointError";
      }
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js
var init_EndpointRuleObject = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js
var init_ErrorRuleObject = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js
var init_RuleSetObject = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js
var init_TreeRuleObject = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js
var init_shared = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js
var init_types5 = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js"() {
    "use strict";
    init_EndpointError();
    init_EndpointRuleObject();
    init_ErrorRuleObject();
    init_RuleSetObject();
    init_TreeRuleObject();
    init_shared();
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
var IP_V4_REGEX, isIpAddress;
var init_isIpAddress = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js"() {
    "use strict";
    IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
    isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isValidHostLabel.js
var VALID_HOST_LABEL_REGEX, isValidHostLabel;
var init_isValidHostLabel = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isValidHostLabel.js"() {
    "use strict";
    VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
    isValidHostLabel = (value, allowSubDomains = false) => {
      if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
      }
      const labels = value.split(".");
      for (const label of labels) {
        if (!isValidHostLabel(label)) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket;
var init_isVirtualHostableS3Bucket = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js"() {
    "use strict";
    init_isIpAddress();
    init_isValidHostLabel();
    isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
      if (allowSubDomains) {
        for (const label of value.split(".")) {
          if (!isVirtualHostableS3Bucket(label)) {
            return false;
          }
        }
        return true;
      }
      if (!isValidHostLabel(value)) {
        return false;
      }
      if (value.length < 3 || value.length > 63) {
        return false;
      }
      if (value !== value.toLowerCase()) {
        return false;
      }
      if (isIpAddress(value)) {
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
var parseArn;
var init_parseArn = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js"() {
    "use strict";
    parseArn = (value) => {
      const segments = value.split(":");
      if (segments.length < 6)
        return null;
      const [arn, partition3, service, region, accountId, ...resourceId] = segments;
      if (arn !== "arn" || partition3 === "" || service === "" || resourceId[0] === "")
        return null;
      return {
        partition: partition3,
        service,
        region,
        accountId,
        resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
      };
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/index.js
var aws_exports = {};
__export(aws_exports, {
  isVirtualHostableS3Bucket: () => isVirtualHostableS3Bucket,
  parseArn: () => parseArn,
  partition: () => partition
});
var init_aws = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/index.js"() {
    "use strict";
    init_isVirtualHostableS3Bucket();
    init_parseArn();
    init_partition();
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/booleanEquals.js
var booleanEquals;
var init_booleanEquals = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/booleanEquals.js"() {
    "use strict";
    booleanEquals = (value1, value2) => value1 === value2;
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttrPathList.js
var getAttrPathList;
var init_getAttrPathList = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttrPathList.js"() {
    "use strict";
    init_types5();
    getAttrPathList = (path) => {
      const parts = path.split(".");
      const pathList = [];
      for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
          if (part.indexOf("]") !== part.length - 1) {
            throw new EndpointError(`Path: '${path}' does not end with ']'`);
          }
          const arrayIndex = part.slice(squareBracketIndex + 1, -1);
          if (Number.isNaN(parseInt(arrayIndex))) {
            throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
          }
          if (squareBracketIndex !== 0) {
            pathList.push(part.slice(0, squareBracketIndex));
          }
          pathList.push(arrayIndex);
        } else {
          pathList.push(part);
        }
      }
      return pathList;
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttr.js
var getAttr;
var init_getAttr = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttr.js"() {
    "use strict";
    init_types5();
    init_getAttrPathList();
    getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
      if (typeof acc !== "object") {
        throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
      } else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
      }
      return acc[index];
    }, value);
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isSet.js
var isSet;
var init_isSet = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isSet.js"() {
    "use strict";
    isSet = (value) => value != null;
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/not.js
var not;
var init_not = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/not.js"() {
    "use strict";
    not = (value) => !value;
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/abort.js
var init_abort = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/abort.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/auth.js
var HttpAuthLocation;
var init_auth = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/auth.js"() {
    "use strict";
    (function(HttpAuthLocation4) {
      HttpAuthLocation4["HEADER"] = "header";
      HttpAuthLocation4["QUERY"] = "query";
    })(HttpAuthLocation || (HttpAuthLocation = {}));
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/checksum.js
var init_checksum = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/checksum.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/client.js
var init_client2 = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/client.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/command.js
var init_command2 = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/command.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/credentials.js
var init_credentials = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/credentials.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/crypto.js
var init_crypto = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/crypto.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/dns.js
var HostAddressType;
var init_dns = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/dns.js"() {
    "use strict";
    (function(HostAddressType3) {
      HostAddressType3["AAAA"] = "AAAA";
      HostAddressType3["A"] = "A";
    })(HostAddressType || (HostAddressType = {}));
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/endpoint.js
var EndpointURLScheme;
var init_endpoint = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/endpoint.js"() {
    "use strict";
    (function(EndpointURLScheme4) {
      EndpointURLScheme4["HTTP"] = "http";
      EndpointURLScheme4["HTTPS"] = "https";
    })(EndpointURLScheme || (EndpointURLScheme = {}));
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/eventStream.js
var init_eventStream = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/eventStream.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/http.js
var init_http = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/http.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/identity/AnonymousIdentity.js
var init_AnonymousIdentity = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/identity/AnonymousIdentity.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/identity/AwsCredentialIdentity.js
var init_AwsCredentialIdentity = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/identity/AwsCredentialIdentity.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/identity/Identity.js
var init_Identity = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/identity/Identity.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/identity/LoginIdentity.js
var init_LoginIdentity = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/identity/LoginIdentity.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/identity/TokenIdentity.js
var init_TokenIdentity = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/identity/TokenIdentity.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/identity/index.js
var init_identity = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/identity/index.js"() {
    "use strict";
    init_AnonymousIdentity();
    init_AwsCredentialIdentity();
    init_Identity();
    init_LoginIdentity();
    init_TokenIdentity();
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/logger.js
var init_logger = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/logger.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/middleware.js
var init_middleware2 = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/middleware.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/pagination.js
var init_pagination = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/pagination.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/profile.js
var init_profile = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/profile.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/request.js
var init_request = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/request.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/response.js
var init_response = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/response.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/retry.js
var init_retry2 = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/retry.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/serde.js
var init_serde = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/serde.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/shapes.js
var init_shapes = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/shapes.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/signature.js
var init_signature = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/signature.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/stream.js
var init_stream = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/stream.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/token.js
var init_token = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/token.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/transfer.js
var init_transfer = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/transfer.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/util.js
var init_util2 = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/util.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/waiter.js
var init_waiter = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/waiter.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/types/dist-es/index.js
var init_dist_es39 = __esm({
  "../../node_modules/@aws-sdk/types/dist-es/index.js"() {
    "use strict";
    init_abort();
    init_auth();
    init_checksum();
    init_client2();
    init_command2();
    init_credentials();
    init_crypto();
    init_dns();
    init_endpoint();
    init_eventStream();
    init_http();
    init_identity();
    init_logger();
    init_middleware2();
    init_pagination();
    init_profile();
    init_request();
    init_response();
    init_retry2();
    init_serde();
    init_shapes();
    init_signature();
    init_stream();
    init_token();
    init_transfer();
    init_util2();
    init_waiter();
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/parseURL.js
var DEFAULT_PORTS, parseURL;
var init_parseURL = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/parseURL.js"() {
    "use strict";
    init_dist_es39();
    init_isIpAddress();
    DEFAULT_PORTS = {
      [EndpointURLScheme.HTTP]: 80,
      [EndpointURLScheme.HTTPS]: 443
    };
    parseURL = (value) => {
      const whatwgURL = (() => {
        try {
          if (value instanceof URL) {
            return value;
          }
          if (typeof value === "object" && "hostname" in value) {
            const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
            const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
            url.search = Object.entries(query).map(([k10, v6]) => `${k10}=${v6}`).join("&");
            return url;
          }
          return new URL(value);
        } catch (error) {
          return null;
        }
      })();
      if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
      }
      const urlString = whatwgURL.href;
      const { host, hostname, pathname, protocol, search } = whatwgURL;
      if (search) {
        return null;
      }
      const scheme = protocol.slice(0, -1);
      if (!Object.values(EndpointURLScheme).includes(scheme)) {
        return null;
      }
      const isIp = isIpAddress(hostname);
      const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
      const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
      return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp
      };
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/stringEquals.js
var stringEquals;
var init_stringEquals = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/stringEquals.js"() {
    "use strict";
    stringEquals = (value1, value2) => value1 === value2;
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/substring.js
var substring;
var init_substring = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/substring.js"() {
    "use strict";
    substring = (input, start, stop, reverse) => {
      if (start >= stop || input.length < stop) {
        return null;
      }
      if (!reverse) {
        return input.substring(start, stop);
      }
      return input.substring(input.length - stop, input.length - start);
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/uriEncode.js
var uriEncode;
var init_uriEncode = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/uriEncode.js"() {
    "use strict";
    uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c10) => `%${c10.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  aws: () => aws_exports,
  booleanEquals: () => booleanEquals,
  getAttr: () => getAttr,
  isSet: () => isSet,
  isValidHostLabel: () => isValidHostLabel,
  not: () => not,
  parseURL: () => parseURL,
  stringEquals: () => stringEquals,
  substring: () => substring,
  uriEncode: () => uriEncode
});
var init_lib = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/index.js"() {
    "use strict";
    init_aws();
    init_booleanEquals();
    init_getAttr();
    init_isSet();
    init_isValidHostLabel();
    init_not();
    init_parseURL();
    init_stringEquals();
    init_substring();
    init_uriEncode();
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTemplate.js
var evaluateTemplate;
var init_evaluateTemplate = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTemplate.js"() {
    "use strict";
    init_lib();
    evaluateTemplate = (template, options) => {
      const evaluatedTemplateArr = [];
      const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord
      };
      let currentIndex = 0;
      while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
          evaluatedTemplateArr.push(template.slice(currentIndex));
          break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
          evaluatedTemplateArr.push(template.slice(openingBraceIndex));
          break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
          evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
          currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
          const [refName, attrName] = parameterName.split("#");
          evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
        } else {
          evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
      }
      return evaluatedTemplateArr.join("");
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getReferenceValue.js
var getReferenceValue;
var init_getReferenceValue = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getReferenceValue.js"() {
    "use strict";
    getReferenceValue = ({ ref }, options) => {
      const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord
      };
      return referenceRecord[ref];
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression;
var init_evaluateExpression = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateExpression.js"() {
    "use strict";
    init_types5();
    init_callFunction();
    init_evaluateTemplate();
    init_getReferenceValue();
    evaluateExpression = (obj, keyName, options) => {
      if (typeof obj === "string") {
        return evaluateTemplate(obj, options);
      } else if (obj["fn"]) {
        return callFunction(obj, options);
      } else if (obj["ref"]) {
        return getReferenceValue(obj, options);
      }
      throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/callFunction.js
var callFunction;
var init_callFunction = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/callFunction.js"() {
    "use strict";
    init_lib();
    init_evaluateExpression();
    callFunction = ({ fn, argv }, options) => {
      const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
      return fn.split(".").reduce((acc, key) => acc[key], lib_exports)(...evaluatedArgs);
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition;
var init_evaluateCondition = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateCondition.js"() {
    "use strict";
    init_debug();
    init_types5();
    init_callFunction();
    evaluateCondition = ({ assign, ...fnArgs }, options) => {
      if (assign && assign in options.referenceRecord) {
        throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
      }
      const value = callFunction(fnArgs, options);
      options.logger?.debug?.(debugId, `evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
      return {
        result: value === "" ? true : !!value,
        ...assign != null && { toAssign: { name: assign, value } }
      };
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions;
var init_evaluateConditions = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateConditions.js"() {
    "use strict";
    init_debug();
    init_evaluateCondition();
    evaluateConditions = (conditions = [], options) => {
      const conditionsReferenceRecord = {};
      for (const condition of conditions) {
        const { result, toAssign } = evaluateCondition(condition, {
          ...options,
          referenceRecord: {
            ...options.referenceRecord,
            ...conditionsReferenceRecord
          }
        });
        if (!result) {
          return { result };
        }
        if (toAssign) {
          conditionsReferenceRecord[toAssign.name] = toAssign.value;
          options.logger?.debug?.(debugId, `assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
        }
      }
      return { result: true, referenceRecord: conditionsReferenceRecord };
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointHeaders.js
var getEndpointHeaders;
var init_getEndpointHeaders = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointHeaders.js"() {
    "use strict";
    init_types5();
    init_evaluateExpression();
    getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
      ...acc,
      [headerKey]: headerVal.map((headerValEntry) => {
        const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
        if (typeof processedExpr !== "string") {
          throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
        }
        return processedExpr;
      })
    }), {});
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperty.js
var getEndpointProperty;
var init_getEndpointProperty = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperty.js"() {
    "use strict";
    init_types5();
    init_evaluateTemplate();
    init_getEndpointProperties();
    getEndpointProperty = (property, options) => {
      if (Array.isArray(property)) {
        return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
      }
      switch (typeof property) {
        case "string":
          return evaluateTemplate(property, options);
        case "object":
          if (property === null) {
            throw new EndpointError(`Unexpected endpoint property: ${property}`);
          }
          return getEndpointProperties(property, options);
        case "boolean":
          return property;
        default:
          throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties;
var init_getEndpointProperties = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperties.js"() {
    "use strict";
    init_getEndpointProperty();
    getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
      ...acc,
      [propertyKey]: getEndpointProperty(propertyVal, options)
    }), {});
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointUrl.js
var getEndpointUrl;
var init_getEndpointUrl = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointUrl.js"() {
    "use strict";
    init_types5();
    init_evaluateExpression();
    getEndpointUrl = (endpointUrl, options) => {
      const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
      if (typeof expression === "string") {
        try {
          return new URL(expression);
        } catch (error) {
          console.error(`Failed to construct URL with ${expression}`, error);
          throw error;
        }
      }
      throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule;
var init_evaluateEndpointRule = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateEndpointRule.js"() {
    "use strict";
    init_debug();
    init_evaluateConditions();
    init_getEndpointHeaders();
    init_getEndpointProperties();
    init_getEndpointUrl();
    evaluateEndpointRule = (endpointRule, options) => {
      const { conditions, endpoint } = endpointRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      };
      const { url, properties, headers } = endpoint;
      options.logger?.debug?.(debugId, `Resolving endpoint from template: ${toDebugString(endpoint)}`);
      return {
        ...headers != void 0 && {
          headers: getEndpointHeaders(headers, endpointRuleOptions)
        },
        ...properties != void 0 && {
          properties: getEndpointProperties(properties, endpointRuleOptions)
        },
        url: getEndpointUrl(url, endpointRuleOptions)
      };
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateErrorRule.js
var evaluateErrorRule;
var init_evaluateErrorRule = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateErrorRule.js"() {
    "use strict";
    init_types5();
    init_evaluateConditions();
    init_evaluateExpression();
    evaluateErrorRule = (errorRule, options) => {
      const { conditions, error } = errorRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      throw new EndpointError(evaluateExpression(error, "Error", {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      }));
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTreeRule.js
var evaluateTreeRule;
var init_evaluateTreeRule = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTreeRule.js"() {
    "use strict";
    init_evaluateConditions();
    init_evaluateRules();
    evaluateTreeRule = (treeRule, options) => {
      const { conditions, rules } = treeRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      return evaluateRules(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      });
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules;
var init_evaluateRules = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateRules.js"() {
    "use strict";
    init_types5();
    init_evaluateEndpointRule();
    init_evaluateErrorRule();
    init_evaluateTreeRule();
    evaluateRules = (rules, options) => {
      for (const rule of rules) {
        if (rule.type === "endpoint") {
          const endpointOrUndefined = evaluateEndpointRule(rule, options);
          if (endpointOrUndefined) {
            return endpointOrUndefined;
          }
        } else if (rule.type === "error") {
          evaluateErrorRule(rule, options);
        } else if (rule.type === "tree") {
          const endpointOrUndefined = evaluateTreeRule(rule, options);
          if (endpointOrUndefined) {
            return endpointOrUndefined;
          }
        } else {
          throw new EndpointError(`Unknown endpoint rule: ${rule}`);
        }
      }
      throw new EndpointError(`Rules evaluation failed`);
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/index.js
var init_utils = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/index.js"() {
    "use strict";
    init_evaluateRules();
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint;
var init_resolveEndpoint = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js"() {
    "use strict";
    init_debug();
    init_types5();
    init_utils();
    resolveEndpoint = (ruleSetObject, options) => {
      const { endpointParams, logger: logger3 } = options;
      const { parameters, rules } = ruleSetObject;
      options.logger?.debug?.(debugId, `Initial EndpointParams: ${toDebugString(endpointParams)}`);
      const paramsWithDefault = Object.entries(parameters).filter(([, v6]) => v6.default != null).map(([k10, v6]) => [k10, v6.default]);
      if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
          endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
        }
      }
      const requiredParams = Object.entries(parameters).filter(([, v6]) => v6.required).map(([k10]) => k10);
      for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
          throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
      }
      const endpoint = evaluateRules(rules, { endpointParams, logger: logger3, referenceRecord: {} });
      if (options.endpointParams?.Endpoint) {
        try {
          const givenEndpoint = new URL(options.endpointParams.Endpoint);
          const { protocol, port } = givenEndpoint;
          endpoint.url.protocol = protocol;
          endpoint.url.port = port;
        } catch (e10) {
        }
      }
      options.logger?.debug?.(debugId, `Resolved endpoint: ${toDebugString(endpoint)}`);
      return endpoint;
    };
  }
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/index.js
var init_dist_es40 = __esm({
  "../../node_modules/@aws-sdk/util-endpoints/dist-es/index.js"() {
    "use strict";
    init_partition();
    init_resolveEndpoint();
    init_types5();
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
var p, q, r, s, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, _data, ruleSet;
var init_ruleset = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js"() {
    "use strict";
    p = "required";
    q = "fn";
    r = "argv";
    s = "ref";
    a = "PartitionResult";
    b = "tree";
    c = "error";
    d = "endpoint";
    e = { [p]: false, "type": "String" };
    f = { [p]: true, "default": false, "type": "Boolean" };
    g = { [s]: "Endpoint" };
    h = { [q]: "booleanEquals", [r]: [{ [s]: "UseFIPS" }, true] };
    i = { [q]: "booleanEquals", [r]: [{ [s]: "UseDualStack" }, true] };
    j = {};
    k = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsFIPS"] }] };
    l = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsDualStack"] }] };
    m = [g];
    n = [h];
    o = [i];
    _data = { version: "1.0", parameters: { Region: e, UseDualStack: f, UseFIPS: f, Endpoint: e }, rules: [{ conditions: [{ [q]: "aws.partition", [r]: [{ [s]: "Region" }], assign: a }], type: b, rules: [{ conditions: [{ [q]: "isSet", [r]: m }, { [q]: "parseURL", [r]: m, assign: "url" }], type: b, rules: [{ conditions: n, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: o, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: g, properties: j, headers: j }, type: d }] }] }, { conditions: [h, i], type: b, rules: [{ conditions: [k, l], type: b, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: n, type: b, rules: [{ conditions: [k], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: o, type: b, rules: [{ conditions: [l], type: b, rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] };
    ruleSet = _data;
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver;
var init_endpointResolver = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js"() {
    "use strict";
    init_dist_es40();
    init_ruleset();
    defaultEndpointResolver = (endpointParams, context = {}) => {
      return resolveEndpoint(ruleSet, {
        endpointParams,
        logger: context.logger
      });
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
var getRuntimeConfig;
var init_runtimeConfig_shared = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js"() {
    "use strict";
    init_dist_es26();
    init_dist_es7();
    init_dist_es38();
    init_dist_es20();
    init_endpointResolver();
    getRuntimeConfig = (config) => ({
      apiVersion: "2019-06-10",
      base64Decoder: config?.base64Decoder ?? fromBase64,
      base64Encoder: config?.base64Encoder ?? toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
      logger: config?.logger ?? new NoOpLogger(),
      serviceId: config?.serviceId ?? "SSO",
      urlParser: config?.urlParser ?? parseUrl,
      utf8Decoder: config?.utf8Decoder ?? fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? toUtf8
    });
  }
});

// ../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/constants.js
var AWS_EXECUTION_ENV, AWS_REGION_ENV, AWS_DEFAULT_REGION_ENV, ENV_IMDS_DISABLED, DEFAULTS_MODE_OPTIONS, IMDS_REGION_PATH;
var init_constants7 = __esm({
  "../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/constants.js"() {
    "use strict";
    AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
    AWS_REGION_ENV = "AWS_REGION";
    AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
    ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
    DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
    IMDS_REGION_PATH = "/latest/meta-data/placement/region";
  }
});

// ../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/defaultsModeConfig.js
var AWS_DEFAULTS_MODE_ENV, AWS_DEFAULTS_MODE_CONFIG, NODE_DEFAULTS_MODE_CONFIG_OPTIONS;
var init_defaultsModeConfig = __esm({
  "../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/defaultsModeConfig.js"() {
    "use strict";
    AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
    AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
    NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
      environmentVariableSelector: (env3) => {
        return env3[AWS_DEFAULTS_MODE_ENV];
      },
      configFileSelector: (profile) => {
        return profile[AWS_DEFAULTS_MODE_CONFIG];
      },
      default: "legacy"
    };
  }
});

// ../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/resolveDefaultsModeConfig.js
var resolveDefaultsModeConfig, resolveNodeDefaultsModeAuto, inferPhysicalRegion;
var init_resolveDefaultsModeConfig = __esm({
  "../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/resolveDefaultsModeConfig.js"() {
    "use strict";
    init_dist_es3();
    init_dist_es31();
    init_dist_es30();
    init_dist_es16();
    init_constants7();
    init_defaultsModeConfig();
    resolveDefaultsModeConfig = ({ region = loadConfig(NODE_REGION_CONFIG_OPTIONS), defaultsMode = loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {}) => memoize(async () => {
      const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
      switch (mode?.toLowerCase()) {
        case "auto":
          return resolveNodeDefaultsModeAuto(region);
        case "in-region":
        case "cross-region":
        case "mobile":
        case "standard":
        case "legacy":
          return Promise.resolve(mode?.toLocaleLowerCase());
        case void 0:
          return Promise.resolve("legacy");
        default:
          throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
      }
    });
    resolveNodeDefaultsModeAuto = async (clientRegion) => {
      if (clientRegion) {
        const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
        const inferredRegion = await inferPhysicalRegion();
        if (!inferredRegion) {
          return "standard";
        }
        if (resolvedRegion === inferredRegion) {
          return "in-region";
        } else {
          return "cross-region";
        }
      }
      return "standard";
    };
    inferPhysicalRegion = async () => {
      if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
        return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
      }
      if (!process.env[ENV_IMDS_DISABLED]) {
        try {
          const endpoint = await getInstanceMetadataEndpoint();
          return (await httpRequest({ ...endpoint, path: IMDS_REGION_PATH })).toString();
        } catch (e10) {
        }
      }
    };
  }
});

// ../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/index.js
var init_dist_es41 = __esm({
  "../../node_modules/@aws-sdk/util-defaults-mode-node/dist-es/index.js"() {
    "use strict";
    init_resolveDefaultsModeConfig();
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js
var getRuntimeConfig2;
var init_runtimeConfig = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js"() {
    "use strict";
    init_package3();
    init_dist_es3();
    init_dist_es33();
    init_dist_es15();
    init_dist_es30();
    init_dist_es35();
    init_dist_es36();
    init_dist_es14();
    init_dist_es37();
    init_runtimeConfig_shared();
    init_dist_es26();
    init_dist_es41();
    init_dist_es26();
    getRuntimeConfig2 = (config) => {
      emitWarningIfUnsupportedVersion(process.version);
      const defaultsMode = resolveDefaultsModeConfig(config);
      const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig(config);
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default3.version }),
        maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ?? loadConfig({
          ...NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
        }),
        sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
      };
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js
var SSOClient;
var init_SSOClient = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js"() {
    "use strict";
    init_dist_es3();
    init_dist_es5();
    init_dist_es9();
    init_dist_es10();
    init_dist_es11();
    init_dist_es12();
    init_dist_es15();
    init_dist_es24();
    init_dist_es26();
    init_EndpointParameters3();
    init_runtimeConfig();
    SSOClient = class extends Client {
      constructor(configuration) {
        const _config_0 = getRuntimeConfig2(configuration);
        const _config_1 = resolveClientEndpointParameters3(_config_0);
        const _config_2 = resolveRegionConfig(_config_1);
        const _config_3 = resolveEndpointConfig(_config_2);
        const _config_4 = resolveRetryConfig(_config_3);
        const _config_5 = resolveHostHeaderConfig(_config_4);
        const _config_6 = resolveUserAgentConfig(_config_5);
        super(_config_6);
        this.config = _config_6;
        this.middlewareStack.use(getRetryPlugin(this.config));
        this.middlewareStack.use(getContentLengthPlugin(this.config));
        this.middlewareStack.use(getHostHeaderPlugin(this.config));
        this.middlewareStack.use(getLoggerPlugin(this.config));
        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(getUserAgentPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/SSO.js
var init_SSO = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/SSO.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/index.js
var init_commands = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/commands/index.js"() {
    "use strict";
    init_GetRoleCredentialsCommand();
    init_ListAccountRolesCommand();
    init_ListAccountsCommand();
    init_LogoutCommand();
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/models/index.js
var init_models = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/models/index.js"() {
    "use strict";
    init_models_02();
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/pagination/Interfaces.js
var init_Interfaces = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/pagination/Interfaces.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/pagination/ListAccountRolesPaginator.js
var init_ListAccountRolesPaginator = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/pagination/ListAccountRolesPaginator.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/pagination/ListAccountsPaginator.js
var init_ListAccountsPaginator = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/pagination/ListAccountsPaginator.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/pagination/index.js
var init_pagination2 = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/pagination/index.js"() {
    "use strict";
    init_Interfaces();
    init_ListAccountRolesPaginator();
    init_ListAccountsPaginator();
  }
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/index.js
var init_dist_es42 = __esm({
  "../../node_modules/@aws-sdk/client-sso/dist-es/index.js"() {
    "use strict";
    init_SSO();
    init_SSOClient();
    init_commands();
    init_models();
    init_pagination2();
  }
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/constants.js
var EXPIRE_WINDOW_MS, REFRESH_MESSAGE;
var init_constants8 = __esm({
  "../../node_modules/@aws-sdk/token-providers/dist-es/constants.js"() {
    "use strict";
    EXPIRE_WINDOW_MS = 5 * 60 * 1e3;
    REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/SSOOIDCServiceException.js
var SSOOIDCServiceException;
var init_SSOOIDCServiceException = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/SSOOIDCServiceException.js"() {
    "use strict";
    init_dist_es26();
    SSOOIDCServiceException = class _SSOOIDCServiceException extends ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _SSOOIDCServiceException.prototype);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/models_0.js
var AccessDeniedException, AuthorizationPendingException, ExpiredTokenException2, InternalServerException, InvalidClientException, InvalidGrantException, InvalidRequestException2, InvalidScopeException, SlowDownException, UnauthorizedClientException, UnsupportedGrantTypeException, CreateTokenRequestFilterSensitiveLog, CreateTokenResponseFilterSensitiveLog;
var init_models_03 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/models_0.js"() {
    "use strict";
    init_SSOOIDCServiceException();
    AccessDeniedException = class _AccessDeniedException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "AccessDeniedException",
          $fault: "client",
          ...opts
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _AccessDeniedException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    AuthorizationPendingException = class _AuthorizationPendingException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "AuthorizationPendingException",
          $fault: "client",
          ...opts
        });
        this.name = "AuthorizationPendingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _AuthorizationPendingException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    ExpiredTokenException2 = class _ExpiredTokenException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...opts
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InternalServerException = class _InternalServerException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "InternalServerException",
          $fault: "server",
          ...opts
        });
        this.name = "InternalServerException";
        this.$fault = "server";
        Object.setPrototypeOf(this, _InternalServerException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidClientException = class _InvalidClientException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "InvalidClientException",
          $fault: "client",
          ...opts
        });
        this.name = "InvalidClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidGrantException = class _InvalidGrantException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "InvalidGrantException",
          $fault: "client",
          ...opts
        });
        this.name = "InvalidGrantException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidGrantException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidRequestException2 = class _InvalidRequestException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...opts
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidRequestException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidScopeException = class _InvalidScopeException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "InvalidScopeException",
          $fault: "client",
          ...opts
        });
        this.name = "InvalidScopeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidScopeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    SlowDownException = class _SlowDownException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "SlowDownException",
          $fault: "client",
          ...opts
        });
        this.name = "SlowDownException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _SlowDownException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    UnauthorizedClientException = class _UnauthorizedClientException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "UnauthorizedClientException",
          $fault: "client",
          ...opts
        });
        this.name = "UnauthorizedClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _UnauthorizedClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    UnsupportedGrantTypeException = class _UnsupportedGrantTypeException extends SSOOIDCServiceException {
      constructor(opts) {
        super({
          name: "UnsupportedGrantTypeException",
          $fault: "client",
          ...opts
        });
        this.name = "UnsupportedGrantTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _UnsupportedGrantTypeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    CreateTokenRequestFilterSensitiveLog = (obj) => ({
      ...obj
    });
    CreateTokenResponseFilterSensitiveLog = (obj) => ({
      ...obj
    });
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/protocols/Aws_restJson1.js
var serializeAws_restJson1CreateTokenCommand, deserializeAws_restJson1CreateTokenCommand, deserializeAws_restJson1CreateTokenCommandError, map4, deserializeAws_restJson1AccessDeniedExceptionResponse, deserializeAws_restJson1AuthorizationPendingExceptionResponse, deserializeAws_restJson1ExpiredTokenExceptionResponse, deserializeAws_restJson1InternalServerExceptionResponse, deserializeAws_restJson1InvalidClientExceptionResponse, deserializeAws_restJson1InvalidGrantExceptionResponse, deserializeAws_restJson1InvalidRequestExceptionResponse2, deserializeAws_restJson1InvalidScopeExceptionResponse, deserializeAws_restJson1SlowDownExceptionResponse, deserializeAws_restJson1UnauthorizedClientExceptionResponse, deserializeAws_restJson1UnsupportedGrantTypeExceptionResponse, serializeAws_restJson1Scopes, deserializeMetadata4, collectBody3, collectBodyString3, parseBody3, parseErrorBody3, loadRestJsonErrorCode2;
var init_Aws_restJson12 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/protocols/Aws_restJson1.js"() {
    "use strict";
    init_dist_es4();
    init_dist_es26();
    init_models_03();
    init_SSOOIDCServiceException();
    serializeAws_restJson1CreateTokenCommand = async (input, context) => {
      const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
      const headers = {
        "content-type": "application/json"
      };
      const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/token`;
      let body;
      body = JSON.stringify({
        ...input.clientId != null && { clientId: input.clientId },
        ...input.clientSecret != null && { clientSecret: input.clientSecret },
        ...input.code != null && { code: input.code },
        ...input.deviceCode != null && { deviceCode: input.deviceCode },
        ...input.grantType != null && { grantType: input.grantType },
        ...input.redirectUri != null && { redirectUri: input.redirectUri },
        ...input.refreshToken != null && { refreshToken: input.refreshToken },
        ...input.scope != null && { scope: serializeAws_restJson1Scopes(input.scope, context) }
      });
      return new HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body
      });
    };
    deserializeAws_restJson1CreateTokenCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateTokenCommandError(output, context);
      }
      const contents = map4({
        $metadata: deserializeMetadata4(output)
      });
      const data = expectNonNull(expectObject(await parseBody3(output.body, context)), "body");
      if (data.accessToken != null) {
        contents.accessToken = expectString(data.accessToken);
      }
      if (data.expiresIn != null) {
        contents.expiresIn = expectInt32(data.expiresIn);
      }
      if (data.idToken != null) {
        contents.idToken = expectString(data.idToken);
      }
      if (data.refreshToken != null) {
        contents.refreshToken = expectString(data.refreshToken);
      }
      if (data.tokenType != null) {
        contents.tokenType = expectString(data.tokenType);
      }
      return contents;
    };
    deserializeAws_restJson1CreateTokenCommandError = async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await parseErrorBody3(output.body, context)
      };
      const errorCode = loadRestJsonErrorCode2(output, parsedOutput.body);
      switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
          throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
          throw await deserializeAws_restJson1AuthorizationPendingExceptionResponse(parsedOutput, context);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
          throw await deserializeAws_restJson1ExpiredTokenExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
          throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
          throw await deserializeAws_restJson1InvalidClientExceptionResponse(parsedOutput, context);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
          throw await deserializeAws_restJson1InvalidGrantExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
          throw await deserializeAws_restJson1InvalidRequestExceptionResponse2(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
          throw await deserializeAws_restJson1InvalidScopeExceptionResponse(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
          throw await deserializeAws_restJson1SlowDownExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
          throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
          throw await deserializeAws_restJson1UnsupportedGrantTypeExceptionResponse(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          throwDefaultError({
            output,
            parsedBody,
            exceptionCtor: SSOOIDCServiceException,
            errorCode
          });
      }
    };
    map4 = map2;
    deserializeAws_restJson1AccessDeniedExceptionResponse = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new AccessDeniedException({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1AuthorizationPendingExceptionResponse = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new AuthorizationPendingException({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1ExpiredTokenExceptionResponse = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new ExpiredTokenException2({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1InternalServerExceptionResponse = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new InternalServerException({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1InvalidClientExceptionResponse = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new InvalidClientException({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1InvalidGrantExceptionResponse = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new InvalidGrantException({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1InvalidRequestExceptionResponse2 = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new InvalidRequestException2({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1InvalidScopeExceptionResponse = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new InvalidScopeException({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1SlowDownExceptionResponse = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new SlowDownException({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1UnauthorizedClientExceptionResponse = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new UnauthorizedClientException({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    deserializeAws_restJson1UnsupportedGrantTypeExceptionResponse = async (parsedOutput, context) => {
      const contents = map4({});
      const data = parsedOutput.body;
      if (data.error != null) {
        contents.error = expectString(data.error);
      }
      if (data.error_description != null) {
        contents.error_description = expectString(data.error_description);
      }
      const exception = new UnsupportedGrantTypeException({
        $metadata: deserializeMetadata4(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    serializeAws_restJson1Scopes = (input, context) => {
      return input.filter((e10) => e10 != null).map((entry) => {
        return entry;
      });
    };
    deserializeMetadata4 = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
    collectBody3 = (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
      }
      return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
    };
    collectBodyString3 = (streamBody, context) => collectBody3(streamBody, context).then((body) => context.utf8Encoder(body));
    parseBody3 = (streamBody, context) => collectBodyString3(streamBody, context).then((encoded) => {
      if (encoded.length) {
        return JSON.parse(encoded);
      }
      return {};
    });
    parseErrorBody3 = async (errorBody, context) => {
      const value = await parseBody3(errorBody, context);
      value.message = value.message ?? value.Message;
      return value;
    };
    loadRestJsonErrorCode2 = (output, data) => {
      const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
      const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
          cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
          cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
          cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
          cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
      };
      const headerKey = findKey(output.headers, "x-amzn-errortype");
      if (headerKey !== void 0) {
        return sanitizeErrorCode(output.headers[headerKey]);
      }
      if (data.code !== void 0) {
        return sanitizeErrorCode(data.code);
      }
      if (data["__type"] !== void 0) {
        return sanitizeErrorCode(data["__type"]);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/CreateTokenCommand.js
var CreateTokenCommand;
var init_CreateTokenCommand = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/CreateTokenCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
    init_models_03();
    init_Aws_restJson12();
    CreateTokenCommand = class _CreateTokenCommand extends Command {
      constructor(input) {
        super();
        this.input = input;
      }
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
          Endpoint: { type: "builtInParams", name: "endpoint" },
          Region: { type: "builtInParams", name: "region" },
          UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
        };
      }
      resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use(getEndpointPlugin(configuration, _CreateTokenCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger: logger3 } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "CreateTokenCommand";
        const handlerExecutionContext = {
          logger: logger3,
          clientName,
          commandName,
          inputFilterSensitiveLog: CreateTokenRequestFilterSensitiveLog,
          outputFilterSensitiveLog: CreateTokenResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
      }
      serialize(input, context) {
        return serializeAws_restJson1CreateTokenCommand(input, context);
      }
      deserialize(output, context) {
        return deserializeAws_restJson1CreateTokenCommand(output, context);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/RegisterClientCommand.js
var init_RegisterClientCommand = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/RegisterClientCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/StartDeviceAuthorizationCommand.js
var init_StartDeviceAuthorizationCommand = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/StartDeviceAuthorizationCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters4;
var init_EndpointParameters4 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/EndpointParameters.js"() {
    "use strict";
    resolveClientEndpointParameters4 = (options) => {
      return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssooidc"
      };
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/package.json
var package_default4;
var init_package4 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/package.json"() {
    package_default4 = {
      name: "@aws-sdk/client-sso-oidc",
      description: "AWS SDK for JavaScript Sso Oidc Client for Node.js, Browser and React Native",
      version: "3.272.0",
      scripts: {
        build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "tsc -p tsconfig.cjs.json",
        "build:docs": "typedoc",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "generate:client": "node ../../scripts/generate-clients/single-service --solo sso-oidc"
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: false,
      dependencies: {
        "@aws-crypto/sha256-browser": "3.0.0",
        "@aws-crypto/sha256-js": "3.0.0",
        "@aws-sdk/config-resolver": "3.272.0",
        "@aws-sdk/fetch-http-handler": "3.272.0",
        "@aws-sdk/hash-node": "3.272.0",
        "@aws-sdk/invalid-dependency": "3.272.0",
        "@aws-sdk/middleware-content-length": "3.272.0",
        "@aws-sdk/middleware-endpoint": "3.272.0",
        "@aws-sdk/middleware-host-header": "3.272.0",
        "@aws-sdk/middleware-logger": "3.272.0",
        "@aws-sdk/middleware-recursion-detection": "3.272.0",
        "@aws-sdk/middleware-retry": "3.272.0",
        "@aws-sdk/middleware-serde": "3.272.0",
        "@aws-sdk/middleware-stack": "3.272.0",
        "@aws-sdk/middleware-user-agent": "3.272.0",
        "@aws-sdk/node-config-provider": "3.272.0",
        "@aws-sdk/node-http-handler": "3.272.0",
        "@aws-sdk/protocol-http": "3.272.0",
        "@aws-sdk/smithy-client": "3.272.0",
        "@aws-sdk/types": "3.272.0",
        "@aws-sdk/url-parser": "3.272.0",
        "@aws-sdk/util-base64": "3.208.0",
        "@aws-sdk/util-body-length-browser": "3.188.0",
        "@aws-sdk/util-body-length-node": "3.208.0",
        "@aws-sdk/util-defaults-mode-browser": "3.272.0",
        "@aws-sdk/util-defaults-mode-node": "3.272.0",
        "@aws-sdk/util-endpoints": "3.272.0",
        "@aws-sdk/util-retry": "3.272.0",
        "@aws-sdk/util-user-agent-browser": "3.272.0",
        "@aws-sdk/util-user-agent-node": "3.272.0",
        "@aws-sdk/util-utf8": "3.254.0",
        tslib: "^2.3.1"
      },
      devDependencies: {
        "@aws-sdk/service-client-documentation-generator": "3.208.0",
        "@tsconfig/node14": "1.0.3",
        "@types/node": "^14.14.31",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typedoc: "0.19.2",
        typescript: "~4.6.2"
      },
      overrides: {
        typedoc: {
          typescript: "~4.6.2"
        }
      },
      engines: {
        node: ">=14.0.0"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "dist-*"
      ],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      browser: {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
      },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
      },
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso-oidc",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-sso-oidc"
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/ruleset.js
var p2, q2, r2, s2, a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, _data2, ruleSet2;
var init_ruleset2 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/ruleset.js"() {
    "use strict";
    p2 = "required";
    q2 = "fn";
    r2 = "argv";
    s2 = "ref";
    a2 = "PartitionResult";
    b2 = "tree";
    c2 = "error";
    d2 = "endpoint";
    e2 = { [p2]: false, "type": "String" };
    f2 = { [p2]: true, "default": false, "type": "Boolean" };
    g2 = { [s2]: "Endpoint" };
    h2 = { [q2]: "booleanEquals", [r2]: [{ [s2]: "UseFIPS" }, true] };
    i2 = { [q2]: "booleanEquals", [r2]: [{ [s2]: "UseDualStack" }, true] };
    j2 = {};
    k2 = { [q2]: "booleanEquals", [r2]: [true, { [q2]: "getAttr", [r2]: [{ [s2]: a2 }, "supportsFIPS"] }] };
    l2 = { [q2]: "booleanEquals", [r2]: [true, { [q2]: "getAttr", [r2]: [{ [s2]: a2 }, "supportsDualStack"] }] };
    m2 = [g2];
    n2 = [h2];
    o2 = [i2];
    _data2 = { version: "1.0", parameters: { Region: e2, UseDualStack: f2, UseFIPS: f2, Endpoint: e2 }, rules: [{ conditions: [{ [q2]: "aws.partition", [r2]: [{ [s2]: "Region" }], assign: a2 }], type: b2, rules: [{ conditions: [{ [q2]: "isSet", [r2]: m2 }, { [q2]: "parseURL", [r2]: m2, assign: "url" }], type: b2, rules: [{ conditions: n2, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c2 }, { type: b2, rules: [{ conditions: o2, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c2 }, { endpoint: { url: g2, properties: j2, headers: j2 }, type: d2 }] }] }, { conditions: [h2, i2], type: b2, rules: [{ conditions: [k2, l2], type: b2, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c2 }] }, { conditions: n2, type: b2, rules: [{ conditions: [k2], type: b2, rules: [{ type: b2, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c2 }] }, { conditions: o2, type: b2, rules: [{ conditions: [l2], type: b2, rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c2 }] }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }] };
    ruleSet2 = _data2;
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver2;
var init_endpointResolver2 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/endpointResolver.js"() {
    "use strict";
    init_dist_es40();
    init_ruleset2();
    defaultEndpointResolver2 = (endpointParams, context = {}) => {
      return resolveEndpoint(ruleSet2, {
        endpointParams,
        logger: context.logger
      });
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.shared.js
var getRuntimeConfig3;
var init_runtimeConfig_shared2 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.shared.js"() {
    "use strict";
    init_dist_es26();
    init_dist_es7();
    init_dist_es38();
    init_dist_es20();
    init_endpointResolver2();
    getRuntimeConfig3 = (config) => ({
      apiVersion: "2019-06-10",
      base64Decoder: config?.base64Decoder ?? fromBase64,
      base64Encoder: config?.base64Encoder ?? toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? defaultEndpointResolver2,
      logger: config?.logger ?? new NoOpLogger(),
      serviceId: config?.serviceId ?? "SSO OIDC",
      urlParser: config?.urlParser ?? parseUrl,
      utf8Decoder: config?.utf8Decoder ?? fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? toUtf8
    });
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.js
var getRuntimeConfig4;
var init_runtimeConfig2 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.js"() {
    "use strict";
    init_package4();
    init_dist_es3();
    init_dist_es33();
    init_dist_es15();
    init_dist_es30();
    init_dist_es35();
    init_dist_es36();
    init_dist_es14();
    init_dist_es37();
    init_runtimeConfig_shared2();
    init_dist_es26();
    init_dist_es41();
    init_dist_es26();
    getRuntimeConfig4 = (config) => {
      emitWarningIfUnsupportedVersion(process.version);
      const defaultsMode = resolveDefaultsModeConfig(config);
      const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig3(config);
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default4.version }),
        maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ?? loadConfig({
          ...NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
        }),
        sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
      };
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDCClient.js
var SSOOIDCClient;
var init_SSOOIDCClient = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDCClient.js"() {
    "use strict";
    init_dist_es3();
    init_dist_es5();
    init_dist_es9();
    init_dist_es10();
    init_dist_es11();
    init_dist_es12();
    init_dist_es15();
    init_dist_es24();
    init_dist_es26();
    init_EndpointParameters4();
    init_runtimeConfig2();
    SSOOIDCClient = class extends Client {
      constructor(configuration) {
        const _config_0 = getRuntimeConfig4(configuration);
        const _config_1 = resolveClientEndpointParameters4(_config_0);
        const _config_2 = resolveRegionConfig(_config_1);
        const _config_3 = resolveEndpointConfig(_config_2);
        const _config_4 = resolveRetryConfig(_config_3);
        const _config_5 = resolveHostHeaderConfig(_config_4);
        const _config_6 = resolveUserAgentConfig(_config_5);
        super(_config_6);
        this.config = _config_6;
        this.middlewareStack.use(getRetryPlugin(this.config));
        this.middlewareStack.use(getContentLengthPlugin(this.config));
        this.middlewareStack.use(getHostHeaderPlugin(this.config));
        this.middlewareStack.use(getLoggerPlugin(this.config));
        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(getUserAgentPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDC.js
var init_SSOOIDC = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDC.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/index.js
var init_commands2 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/index.js"() {
    "use strict";
    init_CreateTokenCommand();
    init_RegisterClientCommand();
    init_StartDeviceAuthorizationCommand();
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/index.js
var init_models2 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/index.js"() {
    "use strict";
    init_models_03();
  }
});

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/index.js
var init_dist_es43 = __esm({
  "../../node_modules/@aws-sdk/client-sso-oidc/dist-es/index.js"() {
    "use strict";
    init_SSOOIDC();
    init_SSOOIDCClient();
    init_commands2();
    init_models2();
  }
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js
var ssoOidcClientsHash, getSsoOidcClient;
var init_getSsoOidcClient = __esm({
  "../../node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js"() {
    "use strict";
    init_dist_es43();
    ssoOidcClientsHash = {};
    getSsoOidcClient = (ssoRegion) => {
      if (ssoOidcClientsHash[ssoRegion]) {
        return ssoOidcClientsHash[ssoRegion];
      }
      const ssoOidcClient = new SSOOIDCClient({ region: ssoRegion });
      ssoOidcClientsHash[ssoRegion] = ssoOidcClient;
      return ssoOidcClient;
    };
  }
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js
var getNewSsoOidcToken;
var init_getNewSsoOidcToken = __esm({
  "../../node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js"() {
    "use strict";
    init_dist_es43();
    init_getSsoOidcClient();
    getNewSsoOidcToken = (ssoToken, ssoRegion) => {
      const ssoOidcClient = getSsoOidcClient(ssoRegion);
      return ssoOidcClient.send(new CreateTokenCommand({
        clientId: ssoToken.clientId,
        clientSecret: ssoToken.clientSecret,
        refreshToken: ssoToken.refreshToken,
        grantType: "refresh_token"
      }));
    };
  }
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js
var validateTokenExpiry;
var init_validateTokenExpiry = __esm({
  "../../node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js"() {
    "use strict";
    init_dist_es16();
    init_constants8();
    validateTokenExpiry = (token) => {
      if (token.expiration && token.expiration.getTime() < Date.now()) {
        throw new TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js
var validateTokenKey;
var init_validateTokenKey = __esm({
  "../../node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js"() {
    "use strict";
    init_dist_es16();
    init_constants8();
    validateTokenKey = (key, value, forRefresh = false) => {
      if (typeof value === "undefined") {
        throw new TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js
var import_fs4, writeFile, writeSSOTokenToFile;
var init_writeSSOTokenToFile = __esm({
  "../../node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js"() {
    "use strict";
    init_dist_es29();
    import_fs4 = require("fs");
    ({ writeFile } = import_fs4.promises);
    writeSSOTokenToFile = (id, ssoToken) => {
      const tokenFilepath = getSSOTokenFilepath(id);
      const tokenString = JSON.stringify(ssoToken, null, 2);
      return writeFile(tokenFilepath, tokenString);
    };
  }
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/fromSso.js
var lastRefreshAttemptTime, fromSso;
var init_fromSso = __esm({
  "../../node_modules/@aws-sdk/token-providers/dist-es/fromSso.js"() {
    "use strict";
    init_dist_es16();
    init_dist_es29();
    init_constants8();
    init_getNewSsoOidcToken();
    init_validateTokenExpiry();
    init_validateTokenKey();
    init_writeSSOTokenToFile();
    lastRefreshAttemptTime = /* @__PURE__ */ new Date(0);
    fromSso = (init = {}) => async () => {
      const profiles = await parseKnownFiles(init);
      const profileName = getProfileName(init);
      const profile = profiles[profileName];
      if (!profile) {
        throw new TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
      } else if (!profile["sso_session"]) {
        throw new TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
      }
      const ssoSessionName = profile["sso_session"];
      const ssoSessions = await loadSsoSessionData(init);
      const ssoSession = ssoSessions[ssoSessionName];
      if (!ssoSession) {
        throw new TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
      }
      for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
        if (!ssoSession[ssoSessionRequiredKey]) {
          throw new TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
        }
      }
      const ssoStartUrl = ssoSession["sso_start_url"];
      const ssoRegion = ssoSession["sso_region"];
      let ssoToken;
      try {
        ssoToken = await getSSOTokenFromFile(ssoSessionName);
      } catch (e10) {
        throw new TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);
      }
      validateTokenKey("accessToken", ssoToken.accessToken);
      validateTokenKey("expiresAt", ssoToken.expiresAt);
      const { accessToken, expiresAt } = ssoToken;
      const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
      if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {
        return existingToken;
      }
      if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1e3) {
        validateTokenExpiry(existingToken);
        return existingToken;
      }
      validateTokenKey("clientId", ssoToken.clientId, true);
      validateTokenKey("clientSecret", ssoToken.clientSecret, true);
      validateTokenKey("refreshToken", ssoToken.refreshToken, true);
      try {
        lastRefreshAttemptTime.setTime(Date.now());
        const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion);
        validateTokenKey("accessToken", newSsoOidcToken.accessToken);
        validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
        const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1e3);
        try {
          await writeSSOTokenToFile(ssoSessionName, {
            ...ssoToken,
            accessToken: newSsoOidcToken.accessToken,
            expiresAt: newTokenExpiration.toISOString(),
            refreshToken: newSsoOidcToken.refreshToken
          });
        } catch (error) {
        }
        return {
          token: newSsoOidcToken.accessToken,
          expiration: newTokenExpiration
        };
      } catch (error) {
        validateTokenExpiry(existingToken);
        return existingToken;
      }
    };
  }
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/fromStatic.js
var init_fromStatic3 = __esm({
  "../../node_modules/@aws-sdk/token-providers/dist-es/fromStatic.js"() {
    "use strict";
    init_dist_es16();
  }
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/nodeProvider.js
var init_nodeProvider = __esm({
  "../../node_modules/@aws-sdk/token-providers/dist-es/nodeProvider.js"() {
    "use strict";
    init_dist_es16();
  }
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/index.js
var init_dist_es44 = __esm({
  "../../node_modules/@aws-sdk/token-providers/dist-es/index.js"() {
    "use strict";
    init_fromSso();
    init_fromStatic3();
    init_nodeProvider();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js
var EXPIRE_WINDOW_MS2, SHOULD_FAIL_CREDENTIAL_CHAIN, resolveSSOCredentials;
var init_resolveSSOCredentials = __esm({
  "../../node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js"() {
    "use strict";
    init_dist_es42();
    init_dist_es16();
    init_dist_es29();
    init_dist_es44();
    EXPIRE_WINDOW_MS2 = 15 * 60 * 1e3;
    SHOULD_FAIL_CREDENTIAL_CHAIN = false;
    resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile }) => {
      let token;
      const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
      if (ssoSession) {
        try {
          const _token = await fromSso({ profile })();
          token = {
            accessToken: _token.token,
            expiresAt: new Date(_token.expiration).toISOString()
          };
        } catch (e10) {
          throw new CredentialsProviderError(e10.message, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
      } else {
        try {
          token = await getSSOTokenFromFile(ssoStartUrl);
        } catch (e10) {
          throw new CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
      }
      if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS2) {
        throw new CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
      }
      const { accessToken } = token;
      const sso = ssoClient || new SSOClient({ region: ssoRegion });
      let ssoResp;
      try {
        ssoResp = await sso.send(new GetRoleCredentialsCommand({
          accountId: ssoAccountId,
          roleName: ssoRoleName,
          accessToken
        }));
      } catch (e10) {
        throw CredentialsProviderError.from(e10, SHOULD_FAIL_CREDENTIAL_CHAIN);
      }
      const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
      if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
        throw new CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
      }
      return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration) };
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js
var validateSsoProfile;
var init_validateSsoProfile = __esm({
  "../../node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js"() {
    "use strict";
    init_dist_es16();
    validateSsoProfile = (profile) => {
      const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
      if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
        throw new CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
      }
      return profile;
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js
var fromSSO;
var init_fromSSO = __esm({
  "../../node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js"() {
    "use strict";
    init_dist_es16();
    init_dist_es29();
    init_isSsoProfile();
    init_resolveSSOCredentials();
    init_validateSsoProfile();
    fromSSO = (init = {}) => async () => {
      const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init;
      const profileName = getProfileName(init);
      if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
        const profiles = await parseKnownFiles(init);
        const profile = profiles[profileName];
        if (!profile) {
          throw new CredentialsProviderError(`Profile ${profileName} was not found.`);
        }
        if (!isSsoProfile(profile)) {
          throw new CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
        }
        if (profile?.sso_session) {
          const ssoSessions = await loadSsoSessionData(init);
          const session = ssoSessions[profile.sso_session];
          const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
          if (ssoRegion && ssoRegion !== session.sso_region) {
            throw new CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
          }
          if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
            throw new CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
          }
          profile.sso_region = session.sso_region;
          profile.sso_start_url = session.sso_start_url;
        }
        const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile);
        return resolveSSOCredentials({
          ssoStartUrl: sso_start_url,
          ssoSession: sso_session,
          ssoAccountId: sso_account_id,
          ssoRegion: sso_region,
          ssoRoleName: sso_role_name,
          ssoClient,
          profile: profileName
        });
      } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
        throw new CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
      } else {
        return resolveSSOCredentials({
          ssoStartUrl,
          ssoSession,
          ssoAccountId,
          ssoRegion,
          ssoRoleName,
          ssoClient,
          profile: profileName
        });
      }
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/types.js
var init_types6 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-sso/dist-es/types.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/index.js
var init_dist_es45 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-sso/dist-es/index.js"() {
    "use strict";
    init_fromSSO();
    init_isSsoProfile();
    init_types6();
    init_validateSsoProfile();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js
var resolveSsoCredentials;
var init_resolveSsoCredentials = __esm({
  "../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js"() {
    "use strict";
    init_dist_es45();
    init_dist_es45();
    resolveSsoCredentials = (data) => {
      const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = validateSsoProfile(data);
      return fromSSO({
        ssoStartUrl: sso_start_url,
        ssoAccountId: sso_account_id,
        ssoSession: sso_session,
        ssoRegion: sso_region,
        ssoRoleName: sso_role_name
      })();
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js
var isStaticCredsProfile, resolveStaticCredentials;
var init_resolveStaticCredentials = __esm({
  "../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js"() {
    "use strict";
    isStaticCredsProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1;
    resolveStaticCredentials = (profile) => Promise.resolve({
      accessKeyId: profile.aws_access_key_id,
      secretAccessKey: profile.aws_secret_access_key,
      sessionToken: profile.aws_session_token
    });
  }
});

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js
var fromWebToken;
var init_fromWebToken = __esm({
  "../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js"() {
    "use strict";
    init_dist_es16();
    fromWebToken = (init) => () => {
      const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds, roleAssumerWithWebIdentity } = init;
      if (!roleAssumerWithWebIdentity) {
        throw new CredentialsProviderError(`Role Arn '${roleArn}' needs to be assumed with web identity, but no role assumption callback was provided.`, false);
      }
      return roleAssumerWithWebIdentity({
        RoleArn: roleArn,
        RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: webIdentityToken,
        ProviderId: providerId,
        PolicyArns: policyArns,
        Policy: policy,
        DurationSeconds: durationSeconds
      });
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
var import_fs5, ENV_TOKEN_FILE, ENV_ROLE_ARN, ENV_ROLE_SESSION_NAME, fromTokenFile, resolveTokenFile;
var init_fromTokenFile = __esm({
  "../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js"() {
    "use strict";
    init_dist_es16();
    import_fs5 = require("fs");
    init_fromWebToken();
    ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
    ENV_ROLE_ARN = "AWS_ROLE_ARN";
    ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
    fromTokenFile = (init = {}) => async () => {
      return resolveTokenFile(init);
    };
    resolveTokenFile = (init) => {
      const webIdentityTokenFile = init?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
      const roleArn = init?.roleArn ?? process.env[ENV_ROLE_ARN];
      const roleSessionName = init?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
      if (!webIdentityTokenFile || !roleArn) {
        throw new CredentialsProviderError("Web identity configuration not specified");
      }
      return fromWebToken({
        ...init,
        webIdentityToken: (0, import_fs5.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
        roleArn,
        roleSessionName
      })();
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/index.js
var init_dist_es46 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/index.js"() {
    "use strict";
    init_fromTokenFile();
    init_fromWebToken();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js
var isWebIdentityProfile, resolveWebIdentityCredentials;
var init_resolveWebIdentityCredentials = __esm({
  "../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js"() {
    "use strict";
    init_dist_es46();
    isWebIdentityProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
    resolveWebIdentityCredentials = async (profile, options) => fromTokenFile({
      webIdentityTokenFile: profile.web_identity_token_file,
      roleArn: profile.role_arn,
      roleSessionName: profile.role_session_name,
      roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity
    })();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js
var resolveProfileData;
var init_resolveProfileData = __esm({
  "../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js"() {
    "use strict";
    init_dist_es16();
    init_resolveAssumeRoleCredentials();
    init_resolveProcessCredentials2();
    init_resolveSsoCredentials();
    init_resolveStaticCredentials();
    init_resolveWebIdentityCredentials();
    resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}) => {
      const data = profiles[profileName];
      if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data)) {
        return resolveStaticCredentials(data);
      }
      if (isAssumeRoleProfile(data)) {
        return resolveAssumeRoleCredentials(profileName, profiles, options, visitedProfiles);
      }
      if (isStaticCredsProfile(data)) {
        return resolveStaticCredentials(data);
      }
      if (isWebIdentityProfile(data)) {
        return resolveWebIdentityCredentials(data, options);
      }
      if (isProcessProfile(data)) {
        return resolveProcessCredentials2(options, profileName);
      }
      if (isSsoProfile(data)) {
        return resolveSsoCredentials(data);
      }
      throw new CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js
var fromIni;
var init_fromIni = __esm({
  "../../node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js"() {
    "use strict";
    init_dist_es29();
    init_resolveProfileData();
    fromIni = (init = {}) => async () => {
      const profiles = await parseKnownFiles(init);
      return resolveProfileData(getProfileName(init), profiles, init);
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/index.js
var init_dist_es47 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-ini/dist-es/index.js"() {
    "use strict";
    init_fromIni();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js
var ENV_IMDS_DISABLED2, remoteProvider;
var init_remoteProvider = __esm({
  "../../node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js"() {
    "use strict";
    init_dist_es31();
    init_dist_es16();
    ENV_IMDS_DISABLED2 = "AWS_EC2_METADATA_DISABLED";
    remoteProvider = (init) => {
      if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
        return fromContainerMetadata(init);
      }
      if (process.env[ENV_IMDS_DISABLED2]) {
        return async () => {
          throw new CredentialsProviderError("EC2 Instance Metadata Service access disabled");
        };
      }
      return fromInstanceMetadata(init);
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var defaultProvider;
var init_defaultProvider = __esm({
  "../../node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js"() {
    "use strict";
    init_dist_es28();
    init_dist_es47();
    init_dist_es32();
    init_dist_es45();
    init_dist_es46();
    init_dist_es16();
    init_dist_es29();
    init_remoteProvider();
    defaultProvider = (init = {}) => memoize(chain(...init.profile || process.env[ENV_PROFILE] ? [] : [fromEnv()], fromSSO(init), fromIni(init), fromProcess(init), fromTokenFile(init), remoteProvider(init), async () => {
      throw new CredentialsProviderError("Could not load credentials from any providers", false);
    }), (credentials) => credentials.expiration !== void 0 && credentials.expiration.getTime() - Date.now() < 3e5, (credentials) => credentials.expiration !== void 0);
  }
});

// ../../node_modules/@aws-sdk/credential-provider-node/dist-es/index.js
var init_dist_es48 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-node/dist-es/index.js"() {
    "use strict";
    init_defaultProvider();
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/ruleset.js
var G, H, I, J, K, L, M, a3, b3, c3, d3, e3, f3, g3, h3, i3, j3, k3, l3, m3, n3, o3, p3, q3, r3, s3, t, u, v, w, x, y, z, A, B, C, D, E, F, _data3, ruleSet3;
var init_ruleset3 = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/ruleset.js"() {
    "use strict";
    G = "required";
    H = "type";
    I = "fn";
    J = "argv";
    K = "ref";
    L = "properties";
    M = "headers";
    a3 = false;
    b3 = true;
    c3 = "PartitionResult";
    d3 = "tree";
    e3 = "booleanEquals";
    f3 = "stringEquals";
    g3 = "sigv4";
    h3 = "us-east-1";
    i3 = "sts";
    j3 = "endpoint";
    k3 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
    l3 = "error";
    m3 = "getAttr";
    n3 = { [G]: false, [H]: "String" };
    o3 = { [G]: true, "default": false, [H]: "Boolean" };
    p3 = { [K]: "Region" };
    q3 = { [K]: "UseFIPS" };
    r3 = { [K]: "UseDualStack" };
    s3 = { [I]: "isSet", [J]: [{ [K]: "Endpoint" }] };
    t = { [K]: "Endpoint" };
    u = { "url": "https://sts.amazonaws.com", [L]: { "authSchemes": [{ "name": g3, "signingRegion": h3, "signingName": i3 }] }, [M]: {} };
    v = {};
    w = { "conditions": [{ [I]: f3, [J]: [p3, "aws-global"] }], [j3]: u, [H]: j3 };
    x = { [I]: e3, [J]: [q3, true] };
    y = { [I]: e3, [J]: [r3, true] };
    z = { [I]: e3, [J]: [true, { [I]: m3, [J]: [{ [K]: c3 }, "supportsFIPS"] }] };
    A = { [K]: c3 };
    B = { [I]: e3, [J]: [true, { [I]: m3, [J]: [A, "supportsDualStack"] }] };
    C = { "url": k3, [L]: {}, [M]: {} };
    D = [t];
    E = [x];
    F = [y];
    _data3 = { version: "1.0", parameters: { Region: n3, UseDualStack: o3, UseFIPS: o3, Endpoint: n3, UseGlobalEndpoint: o3 }, rules: [{ conditions: [{ [I]: "aws.partition", [J]: [p3], assign: c3 }], [H]: d3, rules: [{ conditions: [{ [I]: e3, [J]: [{ [K]: "UseGlobalEndpoint" }, b3] }, { [I]: e3, [J]: [q3, a3] }, { [I]: e3, [J]: [r3, a3] }, { [I]: "not", [J]: [s3] }], [H]: d3, rules: [{ conditions: [{ [I]: f3, [J]: [p3, "ap-northeast-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "ap-south-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "ap-southeast-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "ap-southeast-2"] }], endpoint: u, [H]: j3 }, w, { conditions: [{ [I]: f3, [J]: [p3, "ca-central-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "eu-central-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "eu-north-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "eu-west-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "eu-west-2"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "eu-west-3"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "sa-east-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, h3] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "us-east-2"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "us-west-1"] }], endpoint: u, [H]: j3 }, { conditions: [{ [I]: f3, [J]: [p3, "us-west-2"] }], endpoint: u, [H]: j3 }, { endpoint: { url: k3, [L]: { authSchemes: [{ name: g3, signingRegion: "{Region}", signingName: i3 }] }, [M]: v }, [H]: j3 }] }, { conditions: [s3, { [I]: "parseURL", [J]: D, assign: "url" }], [H]: d3, rules: [{ conditions: E, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [H]: l3 }, { [H]: d3, rules: [{ conditions: F, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [H]: l3 }, { endpoint: { url: t, [L]: v, [M]: v }, [H]: j3 }] }] }, { conditions: [x, y], [H]: d3, rules: [{ conditions: [z, B], [H]: d3, rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", [L]: v, [M]: v }, [H]: j3 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [H]: l3 }] }, { conditions: E, [H]: d3, rules: [{ conditions: [z], [H]: d3, rules: [{ [H]: d3, rules: [{ conditions: [{ [I]: f3, [J]: ["aws-us-gov", { [I]: m3, [J]: [A, "name"] }] }], endpoint: C, [H]: j3 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", [L]: v, [M]: v }, [H]: j3 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", [H]: l3 }] }, { conditions: F, [H]: d3, rules: [{ conditions: [B], [H]: d3, rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", [L]: v, [M]: v }, [H]: j3 }] }, { error: "DualStack is enabled but this partition does not support DualStack", [H]: l3 }] }, { [H]: d3, rules: [w, { endpoint: C, [H]: j3 }] }] }] };
    ruleSet3 = _data3;
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver3;
var init_endpointResolver3 = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/endpointResolver.js"() {
    "use strict";
    init_dist_es40();
    init_ruleset3();
    defaultEndpointResolver3 = (endpointParams, context = {}) => {
      return resolveEndpoint(ruleSet3, {
        endpointParams,
        logger: context.logger
      });
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js
var getRuntimeConfig5;
var init_runtimeConfig_shared3 = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js"() {
    "use strict";
    init_dist_es26();
    init_dist_es7();
    init_dist_es38();
    init_dist_es20();
    init_endpointResolver3();
    getRuntimeConfig5 = (config) => ({
      apiVersion: "2011-06-15",
      base64Decoder: config?.base64Decoder ?? fromBase64,
      base64Encoder: config?.base64Encoder ?? toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? defaultEndpointResolver3,
      logger: config?.logger ?? new NoOpLogger(),
      serviceId: config?.serviceId ?? "STS",
      urlParser: config?.urlParser ?? parseUrl,
      utf8Decoder: config?.utf8Decoder ?? fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? toUtf8
    });
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.js
var getRuntimeConfig6;
var init_runtimeConfig3 = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.js"() {
    "use strict";
    init_package2();
    init_defaultStsRoleAssumers();
    init_dist_es3();
    init_dist_es48();
    init_dist_es33();
    init_dist_es15();
    init_dist_es30();
    init_dist_es35();
    init_dist_es36();
    init_dist_es14();
    init_dist_es37();
    init_runtimeConfig_shared3();
    init_dist_es26();
    init_dist_es41();
    init_dist_es26();
    getRuntimeConfig6 = (config) => {
      emitWarningIfUnsupportedVersion(process.version);
      const defaultsMode = resolveDefaultsModeConfig(config);
      const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig5(config);
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider(defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default2.version }),
        maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ?? loadConfig({
          ...NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
        }),
        sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
      };
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/STSClient.js
var STSClient;
var init_STSClient = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/STSClient.js"() {
    "use strict";
    init_dist_es3();
    init_dist_es5();
    init_dist_es9();
    init_dist_es10();
    init_dist_es11();
    init_dist_es12();
    init_dist_es15();
    init_dist_es27();
    init_dist_es24();
    init_dist_es26();
    init_EndpointParameters2();
    init_runtimeConfig3();
    STSClient = class _STSClient extends Client {
      constructor(configuration) {
        const _config_0 = getRuntimeConfig6(configuration);
        const _config_1 = resolveClientEndpointParameters2(_config_0);
        const _config_2 = resolveRegionConfig(_config_1);
        const _config_3 = resolveEndpointConfig(_config_2);
        const _config_4 = resolveRetryConfig(_config_3);
        const _config_5 = resolveHostHeaderConfig(_config_4);
        const _config_6 = resolveStsAuthConfig(_config_5, { stsClientCtor: _STSClient });
        const _config_7 = resolveUserAgentConfig(_config_6);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use(getRetryPlugin(this.config));
        this.middlewareStack.use(getContentLengthPlugin(this.config));
        this.middlewareStack.use(getHostHeaderPlugin(this.config));
        this.middlewareStack.use(getLoggerPlugin(this.config));
        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(getUserAgentPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/STS.js
var init_STS = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/STS.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/index.js
var init_commands3 = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/commands/index.js"() {
    "use strict";
    init_AssumeRoleCommand();
    init_AssumeRoleWithSAMLCommand();
    init_AssumeRoleWithWebIdentityCommand();
    init_DecodeAuthorizationMessageCommand();
    init_GetAccessKeyInfoCommand();
    init_GetCallerIdentityCommand();
    init_GetFederationTokenCommand();
    init_GetSessionTokenCommand();
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js
var getCustomizableStsClientCtor, getDefaultRoleAssumer2, getDefaultRoleAssumerWithWebIdentity2, decorateDefaultCredentialProvider2;
var init_defaultRoleAssumers = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js"() {
    "use strict";
    init_defaultStsRoleAssumers();
    init_STSClient();
    getCustomizableStsClientCtor = (baseCtor, customizations) => {
      if (!customizations)
        return baseCtor;
      else
        return class CustomizableSTSClient extends baseCtor {
          constructor(config) {
            super(config);
            for (const customization of customizations) {
              this.middlewareStack.use(customization);
            }
          }
        };
    };
    getDefaultRoleAssumer2 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));
    getDefaultRoleAssumerWithWebIdentity2 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));
    decorateDefaultCredentialProvider2 = (provider) => (input) => provider({
      roleAssumer: getDefaultRoleAssumer2(input),
      roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity2(input),
      ...input
    });
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/models/index.js
var init_models3 = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/models/index.js"() {
    "use strict";
    init_models_0();
  }
});

// ../../node_modules/@aws-sdk/client-sts/dist-es/index.js
var init_dist_es49 = __esm({
  "../../node_modules/@aws-sdk/client-sts/dist-es/index.js"() {
    "use strict";
    init_STS();
    init_STSClient();
    init_commands3();
    init_defaultRoleAssumers();
    init_models3();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/endpoint/ruleset.js
var p4, q4, r4, s4, a4, b4, c4, d4, e4, f4, g4, h4, i4, j4, k4, l4, m4, n4, o4, _data4, ruleSet4;
var init_ruleset4 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/endpoint/ruleset.js"() {
    "use strict";
    p4 = "required";
    q4 = "fn";
    r4 = "argv";
    s4 = "ref";
    a4 = "PartitionResult";
    b4 = "tree";
    c4 = "error";
    d4 = "endpoint";
    e4 = { [p4]: false, "type": "String" };
    f4 = { [p4]: true, "default": false, "type": "Boolean" };
    g4 = { [s4]: "Endpoint" };
    h4 = { [q4]: "booleanEquals", [r4]: [{ [s4]: "UseFIPS" }, true] };
    i4 = { [q4]: "booleanEquals", [r4]: [{ [s4]: "UseDualStack" }, true] };
    j4 = {};
    k4 = { [q4]: "booleanEquals", [r4]: [true, { [q4]: "getAttr", [r4]: [{ [s4]: a4 }, "supportsFIPS"] }] };
    l4 = { [q4]: "booleanEquals", [r4]: [true, { [q4]: "getAttr", [r4]: [{ [s4]: a4 }, "supportsDualStack"] }] };
    m4 = [g4];
    n4 = [h4];
    o4 = [i4];
    _data4 = { version: "1.0", parameters: { Region: e4, UseDualStack: f4, UseFIPS: f4, Endpoint: e4 }, rules: [{ conditions: [{ [q4]: "aws.partition", [r4]: [{ [s4]: "Region" }], assign: a4 }], type: b4, rules: [{ conditions: [{ [q4]: "isSet", [r4]: m4 }, { [q4]: "parseURL", [r4]: m4, assign: "url" }], type: b4, rules: [{ conditions: n4, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c4 }, { type: b4, rules: [{ conditions: o4, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c4 }, { endpoint: { url: g4, properties: j4, headers: j4 }, type: d4 }] }] }, { conditions: [h4, i4], type: b4, rules: [{ conditions: [k4, l4], type: b4, rules: [{ endpoint: { url: "https://cognito-identity-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j4, headers: j4 }, type: d4 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c4 }] }, { conditions: n4, type: b4, rules: [{ conditions: [k4], type: b4, rules: [{ type: b4, rules: [{ endpoint: { url: "https://cognito-identity-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j4, headers: j4 }, type: d4 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c4 }] }, { conditions: o4, type: b4, rules: [{ conditions: [l4], type: b4, rules: [{ endpoint: { url: "https://cognito-identity.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j4, headers: j4 }, type: d4 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c4 }] }, { endpoint: { url: "https://cognito-identity.{Region}.{PartitionResult#dnsSuffix}", properties: j4, headers: j4 }, type: d4 }] }] };
    ruleSet4 = _data4;
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver4;
var init_endpointResolver4 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/endpoint/endpointResolver.js"() {
    "use strict";
    init_dist_es40();
    init_ruleset4();
    defaultEndpointResolver4 = (endpointParams, context = {}) => {
      return resolveEndpoint(ruleSet4, {
        endpointParams,
        logger: context.logger
      });
    };
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/runtimeConfig.shared.js
var getRuntimeConfig7;
var init_runtimeConfig_shared4 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/runtimeConfig.shared.js"() {
    "use strict";
    init_dist_es26();
    init_dist_es7();
    init_dist_es38();
    init_dist_es20();
    init_endpointResolver4();
    getRuntimeConfig7 = (config) => ({
      apiVersion: "2014-06-30",
      base64Decoder: config?.base64Decoder ?? fromBase64,
      base64Encoder: config?.base64Encoder ?? toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? defaultEndpointResolver4,
      logger: config?.logger ?? new NoOpLogger(),
      serviceId: config?.serviceId ?? "Cognito Identity",
      urlParser: config?.urlParser ?? parseUrl,
      utf8Decoder: config?.utf8Decoder ?? fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? toUtf8
    });
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/runtimeConfig.js
var getRuntimeConfig8;
var init_runtimeConfig4 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/runtimeConfig.js"() {
    "use strict";
    init_package();
    init_dist_es49();
    init_dist_es3();
    init_dist_es48();
    init_dist_es33();
    init_dist_es15();
    init_dist_es30();
    init_dist_es35();
    init_dist_es36();
    init_dist_es14();
    init_dist_es37();
    init_runtimeConfig_shared4();
    init_dist_es26();
    init_dist_es41();
    init_dist_es26();
    getRuntimeConfig8 = (config) => {
      emitWarningIfUnsupportedVersion(process.version);
      const defaultsMode = resolveDefaultsModeConfig(config);
      const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig7(config);
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider2(defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
        maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ?? loadConfig({
          ...NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
        }),
        sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
      };
    };
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/CognitoIdentityClient.js
var CognitoIdentityClient;
var init_CognitoIdentityClient = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/CognitoIdentityClient.js"() {
    "use strict";
    init_dist_es3();
    init_dist_es5();
    init_dist_es9();
    init_dist_es10();
    init_dist_es11();
    init_dist_es12();
    init_dist_es15();
    init_dist_es23();
    init_dist_es24();
    init_dist_es26();
    init_EndpointParameters();
    init_runtimeConfig4();
    CognitoIdentityClient = class extends Client {
      constructor(configuration) {
        const _config_0 = getRuntimeConfig8(configuration);
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = resolveRegionConfig(_config_1);
        const _config_3 = resolveEndpointConfig(_config_2);
        const _config_4 = resolveRetryConfig(_config_3);
        const _config_5 = resolveHostHeaderConfig(_config_4);
        const _config_6 = resolveAwsAuthConfig(_config_5);
        const _config_7 = resolveUserAgentConfig(_config_6);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use(getRetryPlugin(this.config));
        this.middlewareStack.use(getContentLengthPlugin(this.config));
        this.middlewareStack.use(getHostHeaderPlugin(this.config));
        this.middlewareStack.use(getLoggerPlugin(this.config));
        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(getUserAgentPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/models/CognitoIdentityServiceException.js
var CognitoIdentityServiceException;
var init_CognitoIdentityServiceException = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/models/CognitoIdentityServiceException.js"() {
    "use strict";
    init_dist_es26();
    CognitoIdentityServiceException = class _CognitoIdentityServiceException extends ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _CognitoIdentityServiceException.prototype);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/models/models_0.js
var AmbiguousRoleResolutionType, InternalErrorException, InvalidParameterException, LimitExceededException, NotAuthorizedException, ResourceConflictException, TooManyRequestsException2, ErrorCode, ResourceNotFoundException2, ExternalServiceException, InvalidIdentityPoolConfigurationException, MappingRuleMatchType, RoleMappingType, GetCredentialsForIdentityInputFilterSensitiveLog, GetCredentialsForIdentityResponseFilterSensitiveLog, GetIdInputFilterSensitiveLog, GetIdResponseFilterSensitiveLog;
var init_models_04 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/models/models_0.js"() {
    "use strict";
    init_CognitoIdentityServiceException();
    (function(AmbiguousRoleResolutionType2) {
      AmbiguousRoleResolutionType2["AUTHENTICATED_ROLE"] = "AuthenticatedRole";
      AmbiguousRoleResolutionType2["DENY"] = "Deny";
    })(AmbiguousRoleResolutionType || (AmbiguousRoleResolutionType = {}));
    InternalErrorException = class _InternalErrorException extends CognitoIdentityServiceException {
      constructor(opts) {
        super({
          name: "InternalErrorException",
          $fault: "server",
          ...opts
        });
        this.name = "InternalErrorException";
        this.$fault = "server";
        Object.setPrototypeOf(this, _InternalErrorException.prototype);
      }
    };
    InvalidParameterException = class _InvalidParameterException extends CognitoIdentityServiceException {
      constructor(opts) {
        super({
          name: "InvalidParameterException",
          $fault: "client",
          ...opts
        });
        this.name = "InvalidParameterException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidParameterException.prototype);
      }
    };
    LimitExceededException = class _LimitExceededException extends CognitoIdentityServiceException {
      constructor(opts) {
        super({
          name: "LimitExceededException",
          $fault: "client",
          ...opts
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _LimitExceededException.prototype);
      }
    };
    NotAuthorizedException = class _NotAuthorizedException extends CognitoIdentityServiceException {
      constructor(opts) {
        super({
          name: "NotAuthorizedException",
          $fault: "client",
          ...opts
        });
        this.name = "NotAuthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _NotAuthorizedException.prototype);
      }
    };
    ResourceConflictException = class _ResourceConflictException extends CognitoIdentityServiceException {
      constructor(opts) {
        super({
          name: "ResourceConflictException",
          $fault: "client",
          ...opts
        });
        this.name = "ResourceConflictException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _ResourceConflictException.prototype);
      }
    };
    TooManyRequestsException2 = class _TooManyRequestsException extends CognitoIdentityServiceException {
      constructor(opts) {
        super({
          name: "TooManyRequestsException",
          $fault: "client",
          ...opts
        });
        this.name = "TooManyRequestsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _TooManyRequestsException.prototype);
      }
    };
    (function(ErrorCode2) {
      ErrorCode2["ACCESS_DENIED"] = "AccessDenied";
      ErrorCode2["INTERNAL_SERVER_ERROR"] = "InternalServerError";
    })(ErrorCode || (ErrorCode = {}));
    ResourceNotFoundException2 = class _ResourceNotFoundException extends CognitoIdentityServiceException {
      constructor(opts) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...opts
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
      }
    };
    ExternalServiceException = class _ExternalServiceException extends CognitoIdentityServiceException {
      constructor(opts) {
        super({
          name: "ExternalServiceException",
          $fault: "client",
          ...opts
        });
        this.name = "ExternalServiceException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _ExternalServiceException.prototype);
      }
    };
    InvalidIdentityPoolConfigurationException = class _InvalidIdentityPoolConfigurationException extends CognitoIdentityServiceException {
      constructor(opts) {
        super({
          name: "InvalidIdentityPoolConfigurationException",
          $fault: "client",
          ...opts
        });
        this.name = "InvalidIdentityPoolConfigurationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidIdentityPoolConfigurationException.prototype);
      }
    };
    (function(MappingRuleMatchType2) {
      MappingRuleMatchType2["CONTAINS"] = "Contains";
      MappingRuleMatchType2["EQUALS"] = "Equals";
      MappingRuleMatchType2["NOT_EQUAL"] = "NotEqual";
      MappingRuleMatchType2["STARTS_WITH"] = "StartsWith";
    })(MappingRuleMatchType || (MappingRuleMatchType = {}));
    (function(RoleMappingType2) {
      RoleMappingType2["RULES"] = "Rules";
      RoleMappingType2["TOKEN"] = "Token";
    })(RoleMappingType || (RoleMappingType = {}));
    GetCredentialsForIdentityInputFilterSensitiveLog = (obj) => ({
      ...obj
    });
    GetCredentialsForIdentityResponseFilterSensitiveLog = (obj) => ({
      ...obj
    });
    GetIdInputFilterSensitiveLog = (obj) => ({
      ...obj
    });
    GetIdResponseFilterSensitiveLog = (obj) => ({
      ...obj
    });
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/protocols/Aws_json1_1.js
var serializeAws_json1_1GetCredentialsForIdentityCommand, serializeAws_json1_1GetIdCommand, deserializeAws_json1_1GetCredentialsForIdentityCommand, deserializeAws_json1_1GetCredentialsForIdentityCommandError, deserializeAws_json1_1GetIdCommand, deserializeAws_json1_1GetIdCommandError, deserializeAws_json1_1ExternalServiceExceptionResponse, deserializeAws_json1_1InternalErrorExceptionResponse, deserializeAws_json1_1InvalidIdentityPoolConfigurationExceptionResponse, deserializeAws_json1_1InvalidParameterExceptionResponse, deserializeAws_json1_1LimitExceededExceptionResponse, deserializeAws_json1_1NotAuthorizedExceptionResponse, deserializeAws_json1_1ResourceConflictExceptionResponse, deserializeAws_json1_1ResourceNotFoundExceptionResponse, deserializeAws_json1_1TooManyRequestsExceptionResponse, serializeAws_json1_1GetCredentialsForIdentityInput, serializeAws_json1_1GetIdInput, serializeAws_json1_1LoginsMap, deserializeAws_json1_1Credentials, deserializeAws_json1_1ExternalServiceException, deserializeAws_json1_1GetCredentialsForIdentityResponse, deserializeAws_json1_1GetIdResponse, deserializeAws_json1_1InternalErrorException, deserializeAws_json1_1InvalidIdentityPoolConfigurationException, deserializeAws_json1_1InvalidParameterException, deserializeAws_json1_1LimitExceededException, deserializeAws_json1_1NotAuthorizedException, deserializeAws_json1_1ResourceConflictException, deserializeAws_json1_1ResourceNotFoundException, deserializeAws_json1_1TooManyRequestsException, deserializeMetadata5, collectBody4, collectBodyString4, buildHttpRpcRequest2, parseBody4, parseErrorBody4, loadRestJsonErrorCode3;
var init_Aws_json1_1 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/protocols/Aws_json1_1.js"() {
    "use strict";
    init_dist_es4();
    init_dist_es26();
    init_CognitoIdentityServiceException();
    init_models_04();
    serializeAws_json1_1GetCredentialsForIdentityCommand = async (input, context) => {
      const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSCognitoIdentityService.GetCredentialsForIdentity"
      };
      let body;
      body = JSON.stringify(serializeAws_json1_1GetCredentialsForIdentityInput(input, context));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    };
    serializeAws_json1_1GetIdCommand = async (input, context) => {
      const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSCognitoIdentityService.GetId"
      };
      let body;
      body = JSON.stringify(serializeAws_json1_1GetIdInput(input, context));
      return buildHttpRpcRequest2(context, headers, "/", void 0, body);
    };
    deserializeAws_json1_1GetCredentialsForIdentityCommand = async (output, context) => {
      if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetCredentialsForIdentityCommandError(output, context);
      }
      const data = await parseBody4(output.body, context);
      let contents = {};
      contents = deserializeAws_json1_1GetCredentialsForIdentityResponse(data, context);
      const response = {
        $metadata: deserializeMetadata5(output),
        ...contents
      };
      return Promise.resolve(response);
    };
    deserializeAws_json1_1GetCredentialsForIdentityCommandError = async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await parseErrorBody4(output.body, context)
      };
      const errorCode = loadRestJsonErrorCode3(output, parsedOutput.body);
      switch (errorCode) {
        case "ExternalServiceException":
        case "com.amazonaws.cognitoidentity#ExternalServiceException":
          throw await deserializeAws_json1_1ExternalServiceExceptionResponse(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentity#InternalErrorException":
          throw await deserializeAws_json1_1InternalErrorExceptionResponse(parsedOutput, context);
        case "InvalidIdentityPoolConfigurationException":
        case "com.amazonaws.cognitoidentity#InvalidIdentityPoolConfigurationException":
          throw await deserializeAws_json1_1InvalidIdentityPoolConfigurationExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentity#InvalidParameterException":
          throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentity#NotAuthorizedException":
          throw await deserializeAws_json1_1NotAuthorizedExceptionResponse(parsedOutput, context);
        case "ResourceConflictException":
        case "com.amazonaws.cognitoidentity#ResourceConflictException":
          throw await deserializeAws_json1_1ResourceConflictExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentity#ResourceNotFoundException":
          throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentity#TooManyRequestsException":
          throw await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          throwDefaultError({
            output,
            parsedBody,
            exceptionCtor: CognitoIdentityServiceException,
            errorCode
          });
      }
    };
    deserializeAws_json1_1GetIdCommand = async (output, context) => {
      if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetIdCommandError(output, context);
      }
      const data = await parseBody4(output.body, context);
      let contents = {};
      contents = deserializeAws_json1_1GetIdResponse(data, context);
      const response = {
        $metadata: deserializeMetadata5(output),
        ...contents
      };
      return Promise.resolve(response);
    };
    deserializeAws_json1_1GetIdCommandError = async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await parseErrorBody4(output.body, context)
      };
      const errorCode = loadRestJsonErrorCode3(output, parsedOutput.body);
      switch (errorCode) {
        case "ExternalServiceException":
        case "com.amazonaws.cognitoidentity#ExternalServiceException":
          throw await deserializeAws_json1_1ExternalServiceExceptionResponse(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentity#InternalErrorException":
          throw await deserializeAws_json1_1InternalErrorExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentity#InvalidParameterException":
          throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentity#LimitExceededException":
          throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentity#NotAuthorizedException":
          throw await deserializeAws_json1_1NotAuthorizedExceptionResponse(parsedOutput, context);
        case "ResourceConflictException":
        case "com.amazonaws.cognitoidentity#ResourceConflictException":
          throw await deserializeAws_json1_1ResourceConflictExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentity#ResourceNotFoundException":
          throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentity#TooManyRequestsException":
          throw await deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          throwDefaultError({
            output,
            parsedBody,
            exceptionCtor: CognitoIdentityServiceException,
            errorCode
          });
      }
    };
    deserializeAws_json1_1ExternalServiceExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_json1_1ExternalServiceException(body, context);
      const exception = new ExternalServiceException({
        $metadata: deserializeMetadata5(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_json1_1InternalErrorExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_json1_1InternalErrorException(body, context);
      const exception = new InternalErrorException({
        $metadata: deserializeMetadata5(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_json1_1InvalidIdentityPoolConfigurationExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_json1_1InvalidIdentityPoolConfigurationException(body, context);
      const exception = new InvalidIdentityPoolConfigurationException({
        $metadata: deserializeMetadata5(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_json1_1InvalidParameterExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_json1_1InvalidParameterException(body, context);
      const exception = new InvalidParameterException({
        $metadata: deserializeMetadata5(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_json1_1LimitExceededExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_json1_1LimitExceededException(body, context);
      const exception = new LimitExceededException({
        $metadata: deserializeMetadata5(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_json1_1NotAuthorizedExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_json1_1NotAuthorizedException(body, context);
      const exception = new NotAuthorizedException({
        $metadata: deserializeMetadata5(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_json1_1ResourceConflictExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_json1_1ResourceConflictException(body, context);
      const exception = new ResourceConflictException({
        $metadata: deserializeMetadata5(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_json1_1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_json1_1ResourceNotFoundException(body, context);
      const exception = new ResourceNotFoundException2({
        $metadata: deserializeMetadata5(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    deserializeAws_json1_1TooManyRequestsExceptionResponse = async (parsedOutput, context) => {
      const body = parsedOutput.body;
      const deserialized = deserializeAws_json1_1TooManyRequestsException(body, context);
      const exception = new TooManyRequestsException2({
        $metadata: deserializeMetadata5(parsedOutput),
        ...deserialized
      });
      return decorateServiceException(exception, body);
    };
    serializeAws_json1_1GetCredentialsForIdentityInput = (input, context) => {
      return {
        ...input.CustomRoleArn != null && { CustomRoleArn: input.CustomRoleArn },
        ...input.IdentityId != null && { IdentityId: input.IdentityId },
        ...input.Logins != null && { Logins: serializeAws_json1_1LoginsMap(input.Logins, context) }
      };
    };
    serializeAws_json1_1GetIdInput = (input, context) => {
      return {
        ...input.AccountId != null && { AccountId: input.AccountId },
        ...input.IdentityPoolId != null && { IdentityPoolId: input.IdentityPoolId },
        ...input.Logins != null && { Logins: serializeAws_json1_1LoginsMap(input.Logins, context) }
      };
    };
    serializeAws_json1_1LoginsMap = (input, context) => {
      return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
          return acc;
        }
        acc[key] = value;
        return acc;
      }, {});
    };
    deserializeAws_json1_1Credentials = (output, context) => {
      return {
        AccessKeyId: expectString(output.AccessKeyId),
        Expiration: output.Expiration != null ? expectNonNull(parseEpochTimestamp(expectNumber(output.Expiration))) : void 0,
        SecretKey: expectString(output.SecretKey),
        SessionToken: expectString(output.SessionToken)
      };
    };
    deserializeAws_json1_1ExternalServiceException = (output, context) => {
      return {
        message: expectString(output.message)
      };
    };
    deserializeAws_json1_1GetCredentialsForIdentityResponse = (output, context) => {
      return {
        Credentials: output.Credentials != null ? deserializeAws_json1_1Credentials(output.Credentials, context) : void 0,
        IdentityId: expectString(output.IdentityId)
      };
    };
    deserializeAws_json1_1GetIdResponse = (output, context) => {
      return {
        IdentityId: expectString(output.IdentityId)
      };
    };
    deserializeAws_json1_1InternalErrorException = (output, context) => {
      return {
        message: expectString(output.message)
      };
    };
    deserializeAws_json1_1InvalidIdentityPoolConfigurationException = (output, context) => {
      return {
        message: expectString(output.message)
      };
    };
    deserializeAws_json1_1InvalidParameterException = (output, context) => {
      return {
        message: expectString(output.message)
      };
    };
    deserializeAws_json1_1LimitExceededException = (output, context) => {
      return {
        message: expectString(output.message)
      };
    };
    deserializeAws_json1_1NotAuthorizedException = (output, context) => {
      return {
        message: expectString(output.message)
      };
    };
    deserializeAws_json1_1ResourceConflictException = (output, context) => {
      return {
        message: expectString(output.message)
      };
    };
    deserializeAws_json1_1ResourceNotFoundException = (output, context) => {
      return {
        message: expectString(output.message)
      };
    };
    deserializeAws_json1_1TooManyRequestsException = (output, context) => {
      return {
        message: expectString(output.message)
      };
    };
    deserializeMetadata5 = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
    collectBody4 = (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
      }
      return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
    };
    collectBodyString4 = (streamBody, context) => collectBody4(streamBody, context).then((body) => context.utf8Encoder(body));
    buildHttpRpcRequest2 = async (context, headers, path, resolvedHostname, body) => {
      const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
      const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers
      };
      if (resolvedHostname !== void 0) {
        contents.hostname = resolvedHostname;
      }
      if (body !== void 0) {
        contents.body = body;
      }
      return new HttpRequest(contents);
    };
    parseBody4 = (streamBody, context) => collectBodyString4(streamBody, context).then((encoded) => {
      if (encoded.length) {
        return JSON.parse(encoded);
      }
      return {};
    });
    parseErrorBody4 = async (errorBody, context) => {
      const value = await parseBody4(errorBody, context);
      value.message = value.message ?? value.Message;
      return value;
    };
    loadRestJsonErrorCode3 = (output, data) => {
      const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
      const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
          cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
          cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
          cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
          cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
      };
      const headerKey = findKey(output.headers, "x-amzn-errortype");
      if (headerKey !== void 0) {
        return sanitizeErrorCode(output.headers[headerKey]);
      }
      if (data.code !== void 0) {
        return sanitizeErrorCode(data.code);
      }
      if (data["__type"] !== void 0) {
        return sanitizeErrorCode(data["__type"]);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/CreateIdentityPoolCommand.js
var init_CreateIdentityPoolCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/CreateIdentityPoolCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/DeleteIdentitiesCommand.js
var init_DeleteIdentitiesCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/DeleteIdentitiesCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/DeleteIdentityPoolCommand.js
var init_DeleteIdentityPoolCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/DeleteIdentityPoolCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/DescribeIdentityCommand.js
var init_DescribeIdentityCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/DescribeIdentityCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/DescribeIdentityPoolCommand.js
var init_DescribeIdentityPoolCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/DescribeIdentityPoolCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetCredentialsForIdentityCommand.js
var GetCredentialsForIdentityCommand;
var init_GetCredentialsForIdentityCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetCredentialsForIdentityCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
    init_models_04();
    init_Aws_json1_1();
    GetCredentialsForIdentityCommand = class _GetCredentialsForIdentityCommand extends Command {
      constructor(input) {
        super();
        this.input = input;
      }
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
          Endpoint: { type: "builtInParams", name: "endpoint" },
          Region: { type: "builtInParams", name: "region" },
          UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
        };
      }
      resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use(getEndpointPlugin(configuration, _GetCredentialsForIdentityCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger: logger3 } = configuration;
        const clientName = "CognitoIdentityClient";
        const commandName = "GetCredentialsForIdentityCommand";
        const handlerExecutionContext = {
          logger: logger3,
          clientName,
          commandName,
          inputFilterSensitiveLog: GetCredentialsForIdentityInputFilterSensitiveLog,
          outputFilterSensitiveLog: GetCredentialsForIdentityResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
      }
      serialize(input, context) {
        return serializeAws_json1_1GetCredentialsForIdentityCommand(input, context);
      }
      deserialize(output, context) {
        return deserializeAws_json1_1GetCredentialsForIdentityCommand(output, context);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetIdCommand.js
var GetIdCommand;
var init_GetIdCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetIdCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
    init_models_04();
    init_Aws_json1_1();
    GetIdCommand = class _GetIdCommand extends Command {
      constructor(input) {
        super();
        this.input = input;
      }
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
          Endpoint: { type: "builtInParams", name: "endpoint" },
          Region: { type: "builtInParams", name: "region" },
          UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
        };
      }
      resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use(getEndpointPlugin(configuration, _GetIdCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger: logger3 } = configuration;
        const clientName = "CognitoIdentityClient";
        const commandName = "GetIdCommand";
        const handlerExecutionContext = {
          logger: logger3,
          clientName,
          commandName,
          inputFilterSensitiveLog: GetIdInputFilterSensitiveLog,
          outputFilterSensitiveLog: GetIdResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
      }
      serialize(input, context) {
        return serializeAws_json1_1GetIdCommand(input, context);
      }
      deserialize(output, context) {
        return deserializeAws_json1_1GetIdCommand(output, context);
      }
    };
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetIdentityPoolRolesCommand.js
var init_GetIdentityPoolRolesCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetIdentityPoolRolesCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetOpenIdTokenCommand.js
var init_GetOpenIdTokenCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetOpenIdTokenCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetOpenIdTokenForDeveloperIdentityCommand.js
var init_GetOpenIdTokenForDeveloperIdentityCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetOpenIdTokenForDeveloperIdentityCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetPrincipalTagAttributeMapCommand.js
var init_GetPrincipalTagAttributeMapCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/GetPrincipalTagAttributeMapCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/ListIdentitiesCommand.js
var init_ListIdentitiesCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/ListIdentitiesCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/ListIdentityPoolsCommand.js
var init_ListIdentityPoolsCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/ListIdentityPoolsCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/ListTagsForResourceCommand.js
var init_ListTagsForResourceCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/ListTagsForResourceCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/LookupDeveloperIdentityCommand.js
var init_LookupDeveloperIdentityCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/LookupDeveloperIdentityCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/MergeDeveloperIdentitiesCommand.js
var init_MergeDeveloperIdentitiesCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/MergeDeveloperIdentitiesCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/SetIdentityPoolRolesCommand.js
var init_SetIdentityPoolRolesCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/SetIdentityPoolRolesCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/SetPrincipalTagAttributeMapCommand.js
var init_SetPrincipalTagAttributeMapCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/SetPrincipalTagAttributeMapCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/TagResourceCommand.js
var init_TagResourceCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/TagResourceCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/UnlinkDeveloperIdentityCommand.js
var init_UnlinkDeveloperIdentityCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/UnlinkDeveloperIdentityCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/UnlinkIdentityCommand.js
var init_UnlinkIdentityCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/UnlinkIdentityCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/UntagResourceCommand.js
var init_UntagResourceCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/UntagResourceCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/UpdateIdentityPoolCommand.js
var init_UpdateIdentityPoolCommand = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/UpdateIdentityPoolCommand.js"() {
    "use strict";
    init_dist_es9();
    init_dist_es8();
    init_dist_es23();
    init_dist_es26();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/CognitoIdentity.js
var init_CognitoIdentity = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/CognitoIdentity.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/index.js
var init_commands4 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/commands/index.js"() {
    "use strict";
    init_CreateIdentityPoolCommand();
    init_DeleteIdentitiesCommand();
    init_DeleteIdentityPoolCommand();
    init_DescribeIdentityCommand();
    init_DescribeIdentityPoolCommand();
    init_GetCredentialsForIdentityCommand();
    init_GetIdCommand();
    init_GetIdentityPoolRolesCommand();
    init_GetOpenIdTokenCommand();
    init_GetOpenIdTokenForDeveloperIdentityCommand();
    init_GetPrincipalTagAttributeMapCommand();
    init_ListIdentitiesCommand();
    init_ListIdentityPoolsCommand();
    init_ListTagsForResourceCommand();
    init_LookupDeveloperIdentityCommand();
    init_MergeDeveloperIdentitiesCommand();
    init_SetIdentityPoolRolesCommand();
    init_SetPrincipalTagAttributeMapCommand();
    init_TagResourceCommand();
    init_UnlinkDeveloperIdentityCommand();
    init_UnlinkIdentityCommand();
    init_UntagResourceCommand();
    init_UpdateIdentityPoolCommand();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/models/index.js
var init_models4 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/models/index.js"() {
    "use strict";
    init_models_04();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/pagination/Interfaces.js
var init_Interfaces2 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/pagination/Interfaces.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/pagination/ListIdentityPoolsPaginator.js
var init_ListIdentityPoolsPaginator = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/pagination/ListIdentityPoolsPaginator.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/pagination/index.js
var init_pagination3 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/pagination/index.js"() {
    "use strict";
    init_Interfaces2();
    init_ListIdentityPoolsPaginator();
  }
});

// ../../node_modules/@aws-sdk/client-cognito-identity/dist-es/index.js
var init_dist_es50 = __esm({
  "../../node_modules/@aws-sdk/client-cognito-identity/dist-es/index.js"() {
    "use strict";
    init_CognitoIdentity();
    init_CognitoIdentityClient();
    init_commands4();
    init_models4();
    init_pagination3();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/CognitoProviderParameters.js
var init_CognitoProviderParameters = __esm({
  "../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/CognitoProviderParameters.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/Logins.js
var init_Logins = __esm({
  "../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/Logins.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/Storage.js
var init_Storage = __esm({
  "../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/Storage.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/resolveLogins.js
function resolveLogins(logins) {
  return Promise.all(Object.keys(logins).reduce((arr, name) => {
    const tokenOrProvider = logins[name];
    if (typeof tokenOrProvider === "string") {
      arr.push([name, tokenOrProvider]);
    } else {
      arr.push(tokenOrProvider().then((token) => [name, token]));
    }
    return arr;
  }, [])).then((resolvedPairs) => resolvedPairs.reduce((logins2, [key, value]) => {
    logins2[key] = value;
    return logins2;
  }, {}));
}
var init_resolveLogins = __esm({
  "../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/resolveLogins.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/fromCognitoIdentity.js
function fromCognitoIdentity(parameters) {
  return async () => {
    const { Credentials: { AccessKeyId = throwOnMissingAccessKeyId(), Expiration, SecretKey = throwOnMissingSecretKey(), SessionToken } = throwOnMissingCredentials() } = await parameters.client.send(new GetCredentialsForIdentityCommand({
      CustomRoleArn: parameters.customRoleArn,
      IdentityId: parameters.identityId,
      Logins: parameters.logins ? await resolveLogins(parameters.logins) : void 0
    }));
    return {
      identityId: parameters.identityId,
      accessKeyId: AccessKeyId,
      secretAccessKey: SecretKey,
      sessionToken: SessionToken,
      expiration: Expiration
    };
  };
}
function throwOnMissingAccessKeyId() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no access key ID");
}
function throwOnMissingCredentials() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no credentials");
}
function throwOnMissingSecretKey() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no secret key");
}
var init_fromCognitoIdentity = __esm({
  "../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/fromCognitoIdentity.js"() {
    "use strict";
    init_dist_es50();
    init_dist_es16();
    init_resolveLogins();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/IndexedDbStorage.js
var STORE_NAME, IndexedDbStorage;
var init_IndexedDbStorage = __esm({
  "../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/IndexedDbStorage.js"() {
    "use strict";
    STORE_NAME = "IdentityIds";
    IndexedDbStorage = class {
      constructor(dbName = "aws:cognito-identity-ids") {
        this.dbName = dbName;
      }
      getItem(key) {
        return this.withObjectStore("readonly", (store) => {
          const req = store.get(key);
          return new Promise((resolve) => {
            req.onerror = () => resolve(null);
            req.onsuccess = () => resolve(req.result ? req.result.value : null);
          });
        }).catch(() => null);
      }
      removeItem(key) {
        return this.withObjectStore("readwrite", (store) => {
          const req = store.delete(key);
          return new Promise((resolve, reject) => {
            req.onerror = () => reject(req.error);
            req.onsuccess = () => resolve();
          });
        });
      }
      setItem(id, value) {
        return this.withObjectStore("readwrite", (store) => {
          const req = store.put({ id, value });
          return new Promise((resolve, reject) => {
            req.onerror = () => reject(req.error);
            req.onsuccess = () => resolve();
          });
        });
      }
      getDb() {
        const openDbRequest = self.indexedDB.open(this.dbName, 1);
        return new Promise((resolve, reject) => {
          openDbRequest.onsuccess = () => {
            resolve(openDbRequest.result);
          };
          openDbRequest.onerror = () => {
            reject(openDbRequest.error);
          };
          openDbRequest.onblocked = () => {
            reject(new Error("Unable to access DB"));
          };
          openDbRequest.onupgradeneeded = () => {
            const db = openDbRequest.result;
            db.onerror = () => {
              reject(new Error("Failed to create object store"));
            };
            db.createObjectStore(STORE_NAME, { keyPath: "id" });
          };
        });
      }
      withObjectStore(mode, action) {
        return this.getDb().then((db) => {
          const tx = db.transaction(STORE_NAME, mode);
          tx.oncomplete = () => db.close();
          return new Promise((resolve, reject) => {
            tx.onerror = () => reject(tx.error);
            resolve(action(tx.objectStore(STORE_NAME)));
          }).catch((err) => {
            db.close();
            throw err;
          });
        });
      }
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/InMemoryStorage.js
var InMemoryStorage;
var init_InMemoryStorage = __esm({
  "../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/InMemoryStorage.js"() {
    "use strict";
    InMemoryStorage = class {
      constructor(store = {}) {
        this.store = store;
      }
      getItem(key) {
        if (key in this.store) {
          return this.store[key];
        }
        return null;
      }
      removeItem(key) {
        delete this.store[key];
      }
      setItem(key, value) {
        this.store[key] = value;
      }
    };
  }
});

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/localStorage.js
function localStorage() {
  if (typeof self === "object" && self.indexedDB) {
    return new IndexedDbStorage();
  }
  if (typeof window === "object" && window.localStorage) {
    return window.localStorage;
  }
  return inMemoryStorage;
}
var inMemoryStorage;
var init_localStorage = __esm({
  "../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/localStorage.js"() {
    "use strict";
    init_IndexedDbStorage();
    init_InMemoryStorage();
    inMemoryStorage = new InMemoryStorage();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/fromCognitoIdentityPool.js
function fromCognitoIdentityPool({ accountId, cache = localStorage(), client, customRoleArn, identityPoolId, logins, userIdentifier = !logins || Object.keys(logins).length === 0 ? "ANONYMOUS" : void 0 }) {
  const cacheKey = userIdentifier ? `aws:cognito-identity-credentials:${identityPoolId}:${userIdentifier}` : void 0;
  let provider = async () => {
    let identityId = cacheKey && await cache.getItem(cacheKey);
    if (!identityId) {
      const { IdentityId = throwOnMissingId() } = await client.send(new GetIdCommand({
        AccountId: accountId,
        IdentityPoolId: identityPoolId,
        Logins: logins ? await resolveLogins(logins) : void 0
      }));
      identityId = IdentityId;
      if (cacheKey) {
        Promise.resolve(cache.setItem(cacheKey, identityId)).catch(() => {
        });
      }
    }
    provider = fromCognitoIdentity({
      client,
      customRoleArn,
      logins,
      identityId
    });
    return provider();
  };
  return () => provider().catch(async (err) => {
    if (cacheKey) {
      Promise.resolve(cache.removeItem(cacheKey)).catch(() => {
      });
    }
    throw err;
  });
}
function throwOnMissingId() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no identity ID");
}
var init_fromCognitoIdentityPool = __esm({
  "../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/fromCognitoIdentityPool.js"() {
    "use strict";
    init_dist_es50();
    init_dist_es16();
    init_fromCognitoIdentity();
    init_localStorage();
    init_resolveLogins();
  }
});

// ../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/index.js
var init_dist_es51 = __esm({
  "../../node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/index.js"() {
    "use strict";
    init_CognitoProviderParameters();
    init_Logins();
    init_Storage();
    init_fromCognitoIdentity();
    init_fromCognitoIdentityPool();
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromCognitoIdentity.js
var fromCognitoIdentity2;
var init_fromCognitoIdentity2 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromCognitoIdentity.js"() {
    "use strict";
    init_dist_es50();
    init_dist_es51();
    fromCognitoIdentity2 = (options) => fromCognitoIdentity({
      ...options,
      client: new CognitoIdentityClient(options.clientConfig ?? {})
    });
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromCognitoIdentityPool.js
var fromCognitoIdentityPool2;
var init_fromCognitoIdentityPool2 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromCognitoIdentityPool.js"() {
    "use strict";
    init_dist_es50();
    init_dist_es51();
    fromCognitoIdentityPool2 = (options) => fromCognitoIdentityPool({
      ...options,
      client: new CognitoIdentityClient(options.clientConfig ?? {})
    });
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromContainerMetadata.js
var fromContainerMetadata2;
var init_fromContainerMetadata2 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromContainerMetadata.js"() {
    "use strict";
    init_dist_es31();
    fromContainerMetadata2 = (init) => fromContainerMetadata(init);
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromEnv.js
var fromEnv3;
var init_fromEnv3 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromEnv.js"() {
    "use strict";
    init_dist_es28();
    fromEnv3 = () => fromEnv();
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromIni.js
var fromIni2;
var init_fromIni2 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromIni.js"() {
    "use strict";
    init_dist_es49();
    init_dist_es47();
    fromIni2 = (init = {}) => fromIni({
      ...init,
      roleAssumer: init.roleAssumer ?? getDefaultRoleAssumer2(init.clientConfig, init.clientPlugins),
      roleAssumerWithWebIdentity: init.roleAssumerWithWebIdentity ?? getDefaultRoleAssumerWithWebIdentity2(init.clientConfig, init.clientPlugins)
    });
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromInstanceMetadata.js
var fromInstanceMetadata2;
var init_fromInstanceMetadata2 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromInstanceMetadata.js"() {
    "use strict";
    init_dist_es31();
    fromInstanceMetadata2 = (init) => fromInstanceMetadata(init);
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromNodeProviderChain.js
var fromNodeProviderChain;
var init_fromNodeProviderChain = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromNodeProviderChain.js"() {
    "use strict";
    init_dist_es49();
    init_dist_es48();
    fromNodeProviderChain = (init = {}) => defaultProvider({
      ...init,
      roleAssumer: init.roleAssumer ?? getDefaultRoleAssumer2(init.clientConfig, init.clientPlugins),
      roleAssumerWithWebIdentity: init.roleAssumerWithWebIdentity ?? getDefaultRoleAssumerWithWebIdentity2(init.clientConfig, init.clientPlugins)
    });
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromProcess.js
var fromProcess2;
var init_fromProcess2 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromProcess.js"() {
    "use strict";
    init_dist_es32();
    fromProcess2 = (init) => fromProcess(init);
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromSSO.js
var fromSSO2;
var init_fromSSO2 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromSSO.js"() {
    "use strict";
    init_dist_es42();
    init_dist_es45();
    fromSSO2 = (init = {}) => fromSSO({ ...{ ssoClient: init.clientConfig ? new SSOClient(init.clientConfig) : void 0 }, ...init });
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromTemporaryCredentials.js
var fromTemporaryCredentials;
var init_fromTemporaryCredentials = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromTemporaryCredentials.js"() {
    "use strict";
    init_dist_es49();
    init_dist_es16();
    fromTemporaryCredentials = (options) => {
      let stsClient;
      return async () => {
        const params = { ...options.params, RoleSessionName: options.params.RoleSessionName ?? "aws-sdk-js-" + Date.now() };
        if (params?.SerialNumber) {
          if (!options.mfaCodeProvider) {
            throw new CredentialsProviderError(`Temporary credential requires multi-factor authentication, but no MFA code callback was provided.`, false);
          }
          params.TokenCode = await options.mfaCodeProvider(params?.SerialNumber);
        }
        if (!stsClient)
          stsClient = new STSClient({ ...options.clientConfig, credentials: options.masterCredentials });
        if (options.clientPlugins) {
          for (const plugin of options.clientPlugins) {
            stsClient.middlewareStack.use(plugin);
          }
        }
        const { Credentials } = await stsClient.send(new AssumeRoleCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
          throw new CredentialsProviderError(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
        }
        return {
          accessKeyId: Credentials.AccessKeyId,
          secretAccessKey: Credentials.SecretAccessKey,
          sessionToken: Credentials.SessionToken,
          expiration: Credentials.Expiration
        };
      };
    };
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromTokenFile.js
var fromTokenFile2;
var init_fromTokenFile2 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromTokenFile.js"() {
    "use strict";
    init_dist_es49();
    init_dist_es46();
    fromTokenFile2 = (init = {}) => fromTokenFile({
      ...init,
      roleAssumerWithWebIdentity: init.roleAssumerWithWebIdentity ?? getDefaultRoleAssumerWithWebIdentity2(init.clientConfig, init.clientPlugins)
    });
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/fromWebToken.js
var fromWebToken2;
var init_fromWebToken2 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/fromWebToken.js"() {
    "use strict";
    init_dist_es49();
    init_dist_es46();
    fromWebToken2 = (init) => fromWebToken({
      ...init,
      roleAssumerWithWebIdentity: init.roleAssumerWithWebIdentity ?? getDefaultRoleAssumerWithWebIdentity2(init.clientConfig, init.clientPlugins)
    });
  }
});

// ../../node_modules/@aws-sdk/credential-providers/dist-es/index.js
var dist_es_exports = {};
__export(dist_es_exports, {
  fromCognitoIdentity: () => fromCognitoIdentity2,
  fromCognitoIdentityPool: () => fromCognitoIdentityPool2,
  fromContainerMetadata: () => fromContainerMetadata2,
  fromEnv: () => fromEnv3,
  fromIni: () => fromIni2,
  fromInstanceMetadata: () => fromInstanceMetadata2,
  fromNodeProviderChain: () => fromNodeProviderChain,
  fromProcess: () => fromProcess2,
  fromSSO: () => fromSSO2,
  fromTemporaryCredentials: () => fromTemporaryCredentials,
  fromTokenFile: () => fromTokenFile2,
  fromWebToken: () => fromWebToken2
});
var init_dist_es52 = __esm({
  "../../node_modules/@aws-sdk/credential-providers/dist-es/index.js"() {
    "use strict";
    init_fromCognitoIdentity2();
    init_fromCognitoIdentityPool2();
    init_fromContainerMetadata2();
    init_fromEnv3();
    init_fromIni2();
    init_fromInstanceMetadata2();
    init_fromNodeProviderChain();
    init_fromProcess2();
    init_fromSSO2();
    init_fromTemporaryCredentials();
    init_fromTokenFile2();
    init_fromWebToken2();
  }
});

// ../../node_modules/obliterator/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/obliterator/iterator.js"(exports, module2) {
    "use strict";
    function Iterator(next) {
      Object.defineProperty(this, "_next", {
        writable: false,
        enumerable: false,
        value: next
      });
      this.done = false;
    }
    Iterator.prototype.next = function() {
      if (this.done)
        return { done: true };
      var step = this._next();
      if (step.done)
        this.done = true;
      return step;
    };
    if (typeof Symbol !== "undefined")
      Iterator.prototype[Symbol.iterator] = function() {
        return this;
      };
    Iterator.of = function() {
      var args = arguments, l10 = args.length, i10 = 0;
      return new Iterator(function() {
        if (i10 >= l10)
          return { done: true };
        return { done: false, value: args[i10++] };
      });
    };
    Iterator.empty = function() {
      var iterator = new Iterator(null);
      iterator.done = true;
      return iterator;
    };
    Iterator.is = function(value) {
      if (value instanceof Iterator)
        return true;
      return typeof value === "object" && value !== null && typeof value.next === "function";
    };
    module2.exports = Iterator;
  }
});

// ../../node_modules/obliterator/foreach.js
var require_foreach = __commonJS({
  "../../node_modules/obliterator/foreach.js"(exports, module2) {
    "use strict";
    var ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== "undefined";
    var SYMBOL_SUPPORT = typeof Symbol !== "undefined";
    function forEach2(iterable, callback) {
      var iterator, k10, i10, l10, s10;
      if (!iterable)
        throw new Error("obliterator/forEach: invalid iterable.");
      if (typeof callback !== "function")
        throw new Error("obliterator/forEach: expecting a callback.");
      if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
        for (i10 = 0, l10 = iterable.length; i10 < l10; i10++)
          callback(iterable[i10], i10);
        return;
      }
      if (typeof iterable.forEach === "function") {
        iterable.forEach(callback);
        return;
      }
      if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
        iterable = iterable[Symbol.iterator]();
      }
      if (typeof iterable.next === "function") {
        iterator = iterable;
        i10 = 0;
        while (s10 = iterator.next(), s10.done !== true) {
          callback(s10.value, i10);
          i10++;
        }
        return;
      }
      for (k10 in iterable) {
        if (iterable.hasOwnProperty(k10)) {
          callback(iterable[k10], k10);
        }
      }
      return;
    }
    forEach2.forEachWithNullKeys = function(iterable, callback) {
      var iterator, k10, i10, l10, s10;
      if (!iterable)
        throw new Error("obliterator/forEachWithNullKeys: invalid iterable.");
      if (typeof callback !== "function")
        throw new Error("obliterator/forEachWithNullKeys: expecting a callback.");
      if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
        for (i10 = 0, l10 = iterable.length; i10 < l10; i10++)
          callback(iterable[i10], null);
        return;
      }
      if (iterable instanceof Set) {
        iterable.forEach(function(value) {
          callback(value, null);
        });
        return;
      }
      if (typeof iterable.forEach === "function") {
        iterable.forEach(callback);
        return;
      }
      if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
        iterable = iterable[Symbol.iterator]();
      }
      if (typeof iterable.next === "function") {
        iterator = iterable;
        i10 = 0;
        while (s10 = iterator.next(), s10.done !== true) {
          callback(s10.value, null);
          i10++;
        }
        return;
      }
      for (k10 in iterable) {
        if (iterable.hasOwnProperty(k10)) {
          callback(iterable[k10], k10);
        }
      }
      return;
    };
    module2.exports = forEach2;
  }
});

// ../../node_modules/mnemonist/utils/typed-arrays.js
var require_typed_arrays = __commonJS({
  "../../node_modules/mnemonist/utils/typed-arrays.js"(exports) {
    "use strict";
    var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1;
    var MAX_16BIT_INTEGER = Math.pow(2, 16) - 1;
    var MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
    var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1;
    var MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1;
    var MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
    exports.getPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_8BIT_INTEGER)
        return Uint8Array;
      if (maxIndex <= MAX_16BIT_INTEGER)
        return Uint16Array;
      if (maxIndex <= MAX_32BIT_INTEGER)
        return Uint32Array;
      return Float64Array;
    };
    exports.getSignedPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
        return Int8Array;
      if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
        return Int16Array;
      if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
        return Int32Array;
      return Float64Array;
    };
    exports.getNumberType = function(value) {
      if (value === (value | 0)) {
        if (Math.sign(value) === -1) {
          if (value <= 127 && value >= -128)
            return Int8Array;
          if (value <= 32767 && value >= -32768)
            return Int16Array;
          return Int32Array;
        } else {
          if (value <= 255)
            return Uint8Array;
          if (value <= 65535)
            return Uint16Array;
          return Uint32Array;
        }
      }
      return Float64Array;
    };
    var TYPE_PRIORITY = {
      Uint8Array: 1,
      Int8Array: 2,
      Uint16Array: 3,
      Int16Array: 4,
      Uint32Array: 5,
      Int32Array: 6,
      Float32Array: 7,
      Float64Array: 8
    };
    exports.getMinimalRepresentation = function(array2, getter3) {
      var maxType = null, maxPriority = 0, p10, t5, v6, i10, l10;
      for (i10 = 0, l10 = array2.length; i10 < l10; i10++) {
        v6 = getter3 ? getter3(array2[i10]) : array2[i10];
        t5 = exports.getNumberType(v6);
        p10 = TYPE_PRIORITY[t5.name];
        if (p10 > maxPriority) {
          maxPriority = p10;
          maxType = t5;
        }
      }
      return maxType;
    };
    exports.isTypedArray = function(value) {
      return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
    };
    exports.concat = function() {
      var length = 0, i10, o10, l10;
      for (i10 = 0, l10 = arguments.length; i10 < l10; i10++)
        length += arguments[i10].length;
      var array2 = new arguments[0].constructor(length);
      for (i10 = 0, o10 = 0; i10 < l10; i10++) {
        array2.set(arguments[i10], o10);
        o10 += arguments[i10].length;
      }
      return array2;
    };
    exports.indices = function(length) {
      var PointerArray = exports.getPointerArray(length);
      var array2 = new PointerArray(length);
      for (var i10 = 0; i10 < length; i10++)
        array2[i10] = i10;
      return array2;
    };
  }
});

// ../../node_modules/mnemonist/utils/iterables.js
var require_iterables = __commonJS({
  "../../node_modules/mnemonist/utils/iterables.js"(exports) {
    "use strict";
    var forEach2 = require_foreach();
    var typed = require_typed_arrays();
    function isArrayLike(target) {
      return Array.isArray(target) || typed.isTypedArray(target);
    }
    function guessLength(target) {
      if (typeof target.length === "number")
        return target.length;
      if (typeof target.size === "number")
        return target.size;
      return;
    }
    function toArray2(target) {
      var l10 = guessLength(target);
      var array2 = typeof l10 === "number" ? new Array(l10) : [];
      var i10 = 0;
      forEach2(target, function(value) {
        array2[i10++] = value;
      });
      return array2;
    }
    function toArrayWithIndices(target) {
      var l10 = guessLength(target);
      var IndexArray = typeof l10 === "number" ? typed.getPointerArray(l10) : Array;
      var array2 = typeof l10 === "number" ? new Array(l10) : [];
      var indices = typeof l10 === "number" ? new IndexArray(l10) : [];
      var i10 = 0;
      forEach2(target, function(value) {
        array2[i10] = value;
        indices[i10] = i10++;
      });
      return [array2, indices];
    }
    exports.isArrayLike = isArrayLike;
    exports.guessLength = guessLength;
    exports.toArray = toArray2;
    exports.toArrayWithIndices = toArrayWithIndices;
  }
});

// ../../node_modules/mnemonist/lru-cache.js
var require_lru_cache = __commonJS({
  "../../node_modules/mnemonist/lru-cache.js"(exports, module2) {
    "use strict";
    var Iterator = require_iterator();
    var forEach2 = require_foreach();
    var typed = require_typed_arrays();
    var iterables = require_iterables();
    function LRUCache2(Keys, Values, capacity) {
      if (arguments.length < 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
      }
      this.capacity = capacity;
      if (typeof this.capacity !== "number" || this.capacity <= 0)
        throw new Error("mnemonist/lru-cache: capacity should be positive number.");
      var PointerArray = typed.getPointerArray(capacity);
      this.forward = new PointerArray(capacity);
      this.backward = new PointerArray(capacity);
      this.K = typeof Keys === "function" ? new Keys(capacity) : new Array(capacity);
      this.V = typeof Values === "function" ? new Values(capacity) : new Array(capacity);
      this.size = 0;
      this.head = 0;
      this.tail = 0;
      this.items = {};
    }
    LRUCache2.prototype.clear = function() {
      this.size = 0;
      this.head = 0;
      this.tail = 0;
      this.items = {};
    };
    LRUCache2.prototype.splayOnTop = function(pointer) {
      var oldHead = this.head;
      if (this.head === pointer)
        return this;
      var previous = this.backward[pointer], next = this.forward[pointer];
      if (this.tail === pointer) {
        this.tail = previous;
      } else {
        this.backward[next] = previous;
      }
      this.forward[previous] = next;
      this.backward[oldHead] = pointer;
      this.head = pointer;
      this.forward[pointer] = oldHead;
      return this;
    };
    LRUCache2.prototype.set = function(key, value) {
      var pointer = this.items[key];
      if (typeof pointer !== "undefined") {
        this.splayOnTop(pointer);
        this.V[pointer] = value;
        return;
      }
      if (this.size < this.capacity) {
        pointer = this.size++;
      } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        delete this.items[this.K[pointer]];
      }
      this.items[key] = pointer;
      this.K[pointer] = key;
      this.V[pointer] = value;
      this.forward[pointer] = this.head;
      this.backward[this.head] = pointer;
      this.head = pointer;
    };
    LRUCache2.prototype.setpop = function(key, value) {
      var oldValue = null;
      var oldKey = null;
      var pointer = this.items[key];
      if (typeof pointer !== "undefined") {
        this.splayOnTop(pointer);
        oldValue = this.V[pointer];
        this.V[pointer] = value;
        return { evicted: false, key, value: oldValue };
      }
      if (this.size < this.capacity) {
        pointer = this.size++;
      } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        oldValue = this.V[pointer];
        oldKey = this.K[pointer];
        delete this.items[this.K[pointer]];
      }
      this.items[key] = pointer;
      this.K[pointer] = key;
      this.V[pointer] = value;
      this.forward[pointer] = this.head;
      this.backward[this.head] = pointer;
      this.head = pointer;
      if (oldKey) {
        return { evicted: true, key: oldKey, value: oldValue };
      } else {
        return null;
      }
    };
    LRUCache2.prototype.has = function(key) {
      return key in this.items;
    };
    LRUCache2.prototype.get = function(key) {
      var pointer = this.items[key];
      if (typeof pointer === "undefined")
        return;
      this.splayOnTop(pointer);
      return this.V[pointer];
    };
    LRUCache2.prototype.peek = function(key) {
      var pointer = this.items[key];
      if (typeof pointer === "undefined")
        return;
      return this.V[pointer];
    };
    LRUCache2.prototype.forEach = function(callback, scope) {
      scope = arguments.length > 1 ? scope : this;
      var i10 = 0, l10 = this.size;
      var pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
      while (i10 < l10) {
        callback.call(scope, values[pointer], keys[pointer], this);
        pointer = forward[pointer];
        i10++;
      }
    };
    LRUCache2.prototype.keys = function() {
      var i10 = 0, l10 = this.size;
      var pointer = this.head, keys = this.K, forward = this.forward;
      return new Iterator(function() {
        if (i10 >= l10)
          return { done: true };
        var key = keys[pointer];
        i10++;
        if (i10 < l10)
          pointer = forward[pointer];
        return {
          done: false,
          value: key
        };
      });
    };
    LRUCache2.prototype.values = function() {
      var i10 = 0, l10 = this.size;
      var pointer = this.head, values = this.V, forward = this.forward;
      return new Iterator(function() {
        if (i10 >= l10)
          return { done: true };
        var value = values[pointer];
        i10++;
        if (i10 < l10)
          pointer = forward[pointer];
        return {
          done: false,
          value
        };
      });
    };
    LRUCache2.prototype.entries = function() {
      var i10 = 0, l10 = this.size;
      var pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
      return new Iterator(function() {
        if (i10 >= l10)
          return { done: true };
        var key = keys[pointer], value = values[pointer];
        i10++;
        if (i10 < l10)
          pointer = forward[pointer];
        return {
          done: false,
          value: [key, value]
        };
      });
    };
    if (typeof Symbol !== "undefined")
      LRUCache2.prototype[Symbol.iterator] = LRUCache2.prototype.entries;
    LRUCache2.prototype.inspect = function() {
      var proxy = /* @__PURE__ */ new Map();
      var iterator = this.entries(), step;
      while (step = iterator.next(), !step.done)
        proxy.set(step.value[0], step.value[1]);
      Object.defineProperty(proxy, "constructor", {
        value: LRUCache2,
        enumerable: false
      });
      return proxy;
    };
    if (typeof Symbol !== "undefined")
      LRUCache2.prototype[Symbol.for("nodejs.util.inspect.custom")] = LRUCache2.prototype.inspect;
    LRUCache2.from = function(iterable, Keys, Values, capacity) {
      if (arguments.length < 2) {
        capacity = iterables.guessLength(iterable);
        if (typeof capacity !== "number")
          throw new Error("mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.");
      } else if (arguments.length === 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
      }
      var cache = new LRUCache2(Keys, Values, capacity);
      forEach2(iterable, function(value, key) {
        cache.set(key, value);
      });
      return cache;
    };
    module2.exports = LRUCache2;
  }
});

// ../../node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d10, b10) {
  extendStatics(d10, b10);
  function __() {
    this.constructor = d10;
  }
  d10.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
function __rest(s10, e10) {
  var t5 = {};
  for (var p10 in s10)
    if (Object.prototype.hasOwnProperty.call(s10, p10) && e10.indexOf(p10) < 0)
      t5[p10] = s10[p10];
  if (s10 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i10 = 0, p10 = Object.getOwnPropertySymbols(s10); i10 < p10.length; i10++) {
      if (e10.indexOf(p10[i10]) < 0 && Object.prototype.propertyIsEnumerable.call(s10, p10[i10]))
        t5[p10[i10]] = s10[p10[i10]];
    }
  return t5;
}
function __decorate(decorators, target, key, desc) {
  var c10 = arguments.length, r10 = c10 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d10;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r10 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i10 = decorators.length - 1; i10 >= 0; i10--)
      if (d10 = decorators[i10])
        r10 = (c10 < 3 ? d10(r10) : c10 > 3 ? d10(target, key, r10) : d10(target, key)) || r10;
  return c10 > 3 && r10 && Object.defineProperty(target, key, r10), r10;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e10) {
        reject(e10);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e10) {
        reject(e10);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t5[0] & 1)
      throw t5[1];
    return t5[1];
  }, trys: [], ops: [] }, f10, y3, t5, g10;
  return g10 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g10[Symbol.iterator] = function() {
    return this;
  }), g10;
  function verb(n10) {
    return function(v6) {
      return step([n10, v6]);
    };
  }
  function step(op) {
    if (f10)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f10 = 1, y3 && (t5 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t5 = y3["return"]) && t5.call(y3), 0) : y3.next) && !(t5 = t5.call(y3, op[1])).done)
          return t5;
        if (y3 = 0, t5)
          op = [op[0] & 2, t5.value];
        switch (op[0]) {
          case 0:
          case 1:
            t5 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t5 = _.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t5[1]) {
              _.label = t5[1];
              t5 = op;
              break;
            }
            if (t5 && _.label < t5[2]) {
              _.label = t5[2];
              _.ops.push(op);
              break;
            }
            if (t5[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e10) {
        op = [6, e10];
        y3 = 0;
      } finally {
        f10 = t5 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o10, m10, k10, k22) {
  if (k22 === void 0)
    k22 = k10;
  o10[k22] = m10[k10];
}
function __exportStar(m10, exports) {
  for (var p10 in m10)
    if (p10 !== "default" && !exports.hasOwnProperty(p10))
      exports[p10] = m10[p10];
}
function __values(o10) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m10 = s10 && o10[s10], i10 = 0;
  if (m10)
    return m10.call(o10);
  if (o10 && typeof o10.length === "number")
    return {
      next: function() {
        if (o10 && i10 >= o10.length)
          o10 = void 0;
        return { value: o10 && o10[i10++], done: !o10 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o10, n10) {
  var m10 = typeof Symbol === "function" && o10[Symbol.iterator];
  if (!m10)
    return o10;
  var i10 = m10.call(o10), r10, ar = [], e10;
  try {
    while ((n10 === void 0 || n10-- > 0) && !(r10 = i10.next()).done)
      ar.push(r10.value);
  } catch (error) {
    e10 = { error };
  } finally {
    try {
      if (r10 && !r10.done && (m10 = i10["return"]))
        m10.call(i10);
    } finally {
      if (e10)
        throw e10.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i10 = 0; i10 < arguments.length; i10++)
    ar = ar.concat(__read(arguments[i10]));
  return ar;
}
function __spreadArrays() {
  for (var s10 = 0, i10 = 0, il = arguments.length; i10 < il; i10++)
    s10 += arguments[i10].length;
  for (var r10 = Array(s10), k10 = 0, i10 = 0; i10 < il; i10++)
    for (var a10 = arguments[i10], j10 = 0, jl = a10.length; j10 < jl; j10++, k10++)
      r10[k10] = a10[j10];
  return r10;
}
function __await(v6) {
  return this instanceof __await ? (this.v = v6, this) : new __await(v6);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g10 = generator.apply(thisArg, _arguments || []), i10, q10 = [];
  return i10 = {}, verb("next"), verb("throw"), verb("return"), i10[Symbol.asyncIterator] = function() {
    return this;
  }, i10;
  function verb(n10) {
    if (g10[n10])
      i10[n10] = function(v6) {
        return new Promise(function(a10, b10) {
          q10.push([n10, v6, a10, b10]) > 1 || resume(n10, v6);
        });
      };
  }
  function resume(n10, v6) {
    try {
      step(g10[n10](v6));
    } catch (e10) {
      settle(q10[0][3], e10);
    }
  }
  function step(r10) {
    r10.value instanceof __await ? Promise.resolve(r10.value.v).then(fulfill, reject) : settle(q10[0][2], r10);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f10, v6) {
    if (f10(v6), q10.shift(), q10.length)
      resume(q10[0][0], q10[0][1]);
  }
}
function __asyncDelegator(o10) {
  var i10, p10;
  return i10 = {}, verb("next"), verb("throw", function(e10) {
    throw e10;
  }), verb("return"), i10[Symbol.iterator] = function() {
    return this;
  }, i10;
  function verb(n10, f10) {
    i10[n10] = o10[n10] ? function(v6) {
      return (p10 = !p10) ? { value: __await(o10[n10](v6)), done: n10 === "return" } : f10 ? f10(v6) : v6;
    } : f10;
  }
}
function __asyncValues(o10) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m10 = o10[Symbol.asyncIterator], i10;
  return m10 ? m10.call(o10) : (o10 = typeof __values === "function" ? __values(o10) : o10[Symbol.iterator](), i10 = {}, verb("next"), verb("throw"), verb("return"), i10[Symbol.asyncIterator] = function() {
    return this;
  }, i10);
  function verb(n10) {
    i10[n10] = o10[n10] && function(v6) {
      return new Promise(function(resolve, reject) {
        v6 = o10[n10](v6), settle(resolve, reject, v6.done, v6.value);
      });
    };
  }
  function settle(resolve, reject, d10, v6) {
    Promise.resolve(v6).then(function(v7) {
      resolve({ value: v7, done: d10 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k10 in mod)
      if (Object.hasOwnProperty.call(mod, k10))
        result[k10] = mod[k10];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "../../node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js"() {
    "use strict";
    extendStatics = function(d10, b10) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d11, b11) {
        d11.__proto__ = b11;
      } || function(d11, b11) {
        for (var p10 in b11)
          if (b11.hasOwnProperty(p10))
            d11[p10] = b11[p10];
      };
      return extendStatics(d10, b10);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t5) {
        for (var s10, i10 = 1, n10 = arguments.length; i10 < n10; i10++) {
          s10 = arguments[i10];
          for (var p10 in s10)
            if (Object.prototype.hasOwnProperty.call(s10, p10))
              t5[p10] = s10[p10];
        }
        return t5;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js
var fromUtf82, toUtf82;
var init_pureJs = __esm({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js"() {
    "use strict";
    fromUtf82 = (input) => {
      const bytes = [];
      for (let i10 = 0, len = input.length; i10 < len; i10++) {
        const value = input.charCodeAt(i10);
        if (value < 128) {
          bytes.push(value);
        } else if (value < 2048) {
          bytes.push(value >> 6 | 192, value & 63 | 128);
        } else if (i10 + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i10 + 1) & 64512) === 56320) {
          const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i10) & 1023);
          bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
        } else {
          bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
        }
      }
      return Uint8Array.from(bytes);
    };
    toUtf82 = (input) => {
      let decoded = "";
      for (let i10 = 0, len = input.length; i10 < len; i10++) {
        const byte = input[i10];
        if (byte < 128) {
          decoded += String.fromCharCode(byte);
        } else if (192 <= byte && byte < 224) {
          const nextByte = input[++i10];
          decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
        } else if (240 <= byte && byte < 365) {
          const surrogatePair = [byte, input[++i10], input[++i10], input[++i10]];
          const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
          decoded += decodeURIComponent(encoded);
        } else {
          decoded += String.fromCharCode((byte & 15) << 12 | (input[++i10] & 63) << 6 | input[++i10] & 63);
        }
      }
      return decoded;
    };
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js
function fromUtf83(input) {
  return new TextEncoder().encode(input);
}
function toUtf83(input) {
  return new TextDecoder("utf-8").decode(input);
}
var init_whatwgEncodingApi = __esm({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js"() {
    "use strict";
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js
var dist_es_exports2 = {};
__export(dist_es_exports2, {
  fromUtf8: () => fromUtf84,
  toUtf8: () => toUtf84
});
var fromUtf84, toUtf84;
var init_dist_es53 = __esm({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js"() {
    "use strict";
    init_pureJs();
    init_whatwgEncodingApi();
    fromUtf84 = (input) => typeof TextEncoder === "function" ? fromUtf83(input) : fromUtf82(input);
    toUtf84 = (input) => typeof TextDecoder === "function" ? toUtf83(input) : toUtf82(input);
  }
});

// ../../node_modules/@aws-crypto/util/build/convertToBuffer.js
var require_convertToBuffer = __commonJS({
  "../../node_modules/@aws-crypto/util/build/convertToBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToBuffer = void 0;
    var util_utf8_browser_1 = (init_dist_es53(), __toCommonJS(dist_es_exports2));
    var fromUtf86 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
      return Buffer.from(input, "utf8");
    } : util_utf8_browser_1.fromUtf8;
    function convertToBuffer(data) {
      if (data instanceof Uint8Array)
        return data;
      if (typeof data === "string") {
        return fromUtf86(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
    exports.convertToBuffer = convertToBuffer;
  }
});

// ../../node_modules/@aws-crypto/util/build/isEmptyData.js
var require_isEmptyData = __commonJS({
  "../../node_modules/@aws-crypto/util/build/isEmptyData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData;
  }
});

// ../../node_modules/@aws-crypto/util/build/numToUint8.js
var require_numToUint8 = __commonJS({
  "../../node_modules/@aws-crypto/util/build/numToUint8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numToUint8 = void 0;
    function numToUint8(num) {
      return new Uint8Array([
        (num & 4278190080) >> 24,
        (num & 16711680) >> 16,
        (num & 65280) >> 8,
        num & 255
      ]);
    }
    exports.numToUint8 = numToUint8;
  }
});

// ../../node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS({
  "../../node_modules/@aws-crypto/util/build/uint32ArrayFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = void 0;
    function uint32ArrayFrom(a_lookUpTable) {
      if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
          return_array[a_index] = a_lookUpTable[a_index];
          a_index += 1;
        }
        return return_array;
      }
      return Uint32Array.from(a_lookUpTable);
    }
    exports.uint32ArrayFrom = uint32ArrayFrom;
  }
});

// ../../node_modules/@aws-crypto/util/build/index.js
var require_build = __commonJS({
  "../../node_modules/@aws-crypto/util/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    var convertToBuffer_1 = require_convertToBuffer();
    Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
      return convertToBuffer_1.convertToBuffer;
    } });
    var isEmptyData_1 = require_isEmptyData();
    Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
      return isEmptyData_1.isEmptyData;
    } });
    var numToUint8_1 = require_numToUint8();
    Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
      return numToUint8_1.numToUint8;
    } });
    var uint32ArrayFrom_1 = require_uint32ArrayFrom();
    Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
      return uint32ArrayFrom_1.uint32ArrayFrom;
    } });
  }
});

// ../../node_modules/@aws-crypto/crc32/build/aws_crc32.js
var require_aws_crc32 = __commonJS({
  "../../node_modules/@aws-crypto/crc32/build/aws_crc32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_build();
    var index_1 = require_build2();
    var AwsCrc32 = (
      /** @class */
      function() {
        function AwsCrc322() {
          this.crc32 = new index_1.Crc32();
        }
        AwsCrc322.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash))
            return;
          this.crc32.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc322.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              return [2, (0, util_1.numToUint8)(this.crc32.digest())];
            });
          });
        };
        AwsCrc322.prototype.reset = function() {
          this.crc32 = new index_1.Crc32();
        };
        return AwsCrc322;
      }()
    );
    exports.AwsCrc32 = AwsCrc32;
  }
});

// ../../node_modules/@aws-crypto/crc32/build/index.js
var require_build2 = __commonJS({
  "../../node_modules/@aws-crypto/crc32/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_build();
    function crc32(data) {
      return new Crc323().update(data).digest();
    }
    exports.crc32 = crc32;
    var Crc323 = (
      /** @class */
      function() {
        function Crc324() {
          this.checksum = 4294967295;
        }
        Crc324.prototype.update = function(data) {
          var e_1, _a;
          try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a = data_1.return))
                _a.call(data_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return this;
        };
        Crc324.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc324;
      }()
    );
    exports.Crc32 = Crc323;
    var a_lookUpTable = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
    var aws_crc32_1 = require_aws_crc32();
    Object.defineProperty(exports, "AwsCrc32", { enumerable: true, get: function() {
      return aws_crc32_1.AwsCrc32;
    } });
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/util.js
var require_util2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string2, regex) {
      const matches = [];
      let match = regex.exec(string2);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string2);
      }
      return matches;
    };
    var isName = function(string2) {
      const match = regexName.exec(string2);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v6) {
      return typeof v6 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a10, arrayMode) {
      if (a10) {
        const keys = Object.keys(a10);
        const len = keys.length;
        for (let i10 = 0; i10 < len; i10++) {
          if (arrayMode === "strict") {
            target[keys[i10]] = [a10[keys[i10]]];
          } else {
            target[keys[i10]] = a10[keys[i10]];
          }
        }
      }
    };
    exports.getValue = function(v6) {
      if (exports.isExist(v6)) {
        return v6;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/validator.js
var require_validator2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util = require_util2();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i10 = 0; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === "<" && xmlData[i10 + 1] === "?") {
          i10 += 2;
          i10 = readPI(xmlData, i10);
          if (i10.err)
            return i10;
        } else if (xmlData[i10] === "<") {
          let tagStartPos = i10;
          i10++;
          if (xmlData[i10] === "!") {
            i10 = readCommentAndCDATA(xmlData, i10);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i10] === "/") {
              closingTag = true;
              i10++;
            }
            let tagName = "";
            for (; i10 < xmlData.length && xmlData[i10] !== ">" && xmlData[i10] !== " " && xmlData[i10] !== "	" && xmlData[i10] !== "\n" && xmlData[i10] !== "\r"; i10++) {
              tagName += xmlData[i10];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i10--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i10));
            }
            const result = readAttributeStr(xmlData, i10);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i10));
            }
            let attrStr = result.value;
            i10 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i10 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i10));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i10 - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i10));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i10++; i10 < xmlData.length; i10++) {
              if (xmlData[i10] === "<") {
                if (xmlData[i10 + 1] === "!") {
                  i10++;
                  i10 = readCommentAndCDATA(xmlData, i10);
                  continue;
                } else if (xmlData[i10 + 1] === "?") {
                  i10 = readPI(xmlData, ++i10);
                  if (i10.err)
                    return i10;
                } else {
                  break;
                }
              } else if (xmlData[i10] === "&") {
                const afterAmp = validateAmpersand(xmlData, i10);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i10));
                i10 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i10])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i10));
                }
              }
            }
            if (xmlData[i10] === "<") {
              i10--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i10])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i10] + "' is not expected.", getLineNumberForPosition(xmlData, i10));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t5) => t5.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i10) {
      const start = i10;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] == "?" || xmlData[i10] == " ") {
          const tagname = xmlData.substr(start, i10 - start);
          if (i10 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i10));
          } else if (xmlData[i10] == "?" && xmlData[i10 + 1] == ">") {
            i10++;
            break;
          } else {
            continue;
          }
        }
      }
      return i10;
    }
    function readCommentAndCDATA(xmlData, i10) {
      if (xmlData.length > i10 + 5 && xmlData[i10 + 1] === "-" && xmlData[i10 + 2] === "-") {
        for (i10 += 3; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "-" && xmlData[i10 + 1] === "-" && xmlData[i10 + 2] === ">") {
            i10 += 2;
            break;
          }
        }
      } else if (xmlData.length > i10 + 8 && xmlData[i10 + 1] === "D" && xmlData[i10 + 2] === "O" && xmlData[i10 + 3] === "C" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "Y" && xmlData[i10 + 6] === "P" && xmlData[i10 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i10 += 8; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i10] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i10 + 9 && xmlData[i10 + 1] === "[" && xmlData[i10 + 2] === "C" && xmlData[i10 + 3] === "D" && xmlData[i10 + 4] === "A" && xmlData[i10 + 5] === "T" && xmlData[i10 + 6] === "A" && xmlData[i10 + 7] === "[") {
        for (i10 += 8; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "]" && xmlData[i10 + 1] === "]" && xmlData[i10 + 2] === ">") {
            i10 += 2;
            break;
          }
        }
      }
      return i10;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i10) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === doubleQuote || xmlData[i10] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i10];
          } else if (startChar !== xmlData[i10]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i10] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i10];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i10,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i10 = 0; i10 < matches.length; i10++) {
        if (matches[i10][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i10][2] + "' has no space in starting.", getPositionFromMatch(matches[i10]));
        } else if (matches[i10][3] !== void 0 && matches[i10][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i10][2] + "' is without value.", getPositionFromMatch(matches[i10]));
        } else if (matches[i10][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i10][2] + "' is not allowed.", getPositionFromMatch(matches[i10]));
        }
        const attrName = matches[i10][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i10]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i10]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i10) {
      let re = /\d/;
      if (xmlData[i10] === "x") {
        i10++;
        re = /[\da-fA-F]/;
      }
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === ";")
          return i10;
        if (!xmlData[i10].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i10) {
      i10++;
      if (xmlData[i10] === ";")
        return -1;
      if (xmlData[i10] === "#") {
        i10++;
        return validateNumberAmpersand(xmlData, i10);
      }
      let count2 = 0;
      for (; i10 < xmlData.length; i10++, count2++) {
        if (xmlData[i10].match(/\w/) && count2 < 20)
          continue;
        if (xmlData[i10] === ";")
          break;
        return -1;
      }
      return i10;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    "use strict";
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val2) {
        return val2;
      },
      attributeValueProcessor: function(attrName, val2) {
        return val2;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module2) {
    "use strict";
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val2) {
        if (key === "__proto__")
          key = "#__proto__";
        this.child.push({ [key]: val2 });
      }
      addChild(node) {
        if (node.tagname === "__proto__")
          node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module2.exports = XmlNode;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module2) {
    "use strict";
    var util = require_util2();
    function readDocType(xmlData, i10) {
      const entities = {};
      if (xmlData[i10 + 3] === "O" && xmlData[i10 + 4] === "C" && xmlData[i10 + 5] === "T" && xmlData[i10 + 6] === "Y" && xmlData[i10 + 7] === "P" && xmlData[i10 + 8] === "E") {
        i10 = i10 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for (; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i10)) {
              i10 += 7;
              [entityName, val, i10] = readEntityExp(xmlData, i10 + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i10))
              i10 += 8;
            else if (hasBody && isAttlist(xmlData, i10))
              i10 += 8;
            else if (hasBody && isNotation(xmlData, i10))
              i10 += 9;
            else if (isComment)
              comment = true;
            else
              throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i10] === ">") {
            if (comment) {
              if (xmlData[i10 - 1] === "-" && xmlData[i10 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i10] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i10];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i10 };
    }
    function readEntityExp(xmlData, i10) {
      let entityName2 = "";
      for (; i10 < xmlData.length && (xmlData[i10] !== "'" && xmlData[i10] !== '"'); i10++) {
        entityName2 += xmlData[i10];
      }
      entityName2 = entityName2.trim();
      if (entityName2.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
      const startChar = xmlData[i10++];
      let val2 = "";
      for (; i10 < xmlData.length && xmlData[i10] !== startChar; i10++) {
        val2 += xmlData[i10];
      }
      return [entityName2, val2, i10];
    }
    function isComment(xmlData, i10) {
      if (xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "-" && xmlData[i10 + 3] === "-")
        return true;
      return false;
    }
    function isEntity(xmlData, i10) {
      if (xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "E" && xmlData[i10 + 3] === "N" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "I" && xmlData[i10 + 6] === "T" && xmlData[i10 + 7] === "Y")
        return true;
      return false;
    }
    function isElement(xmlData, i10) {
      if (xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "E" && xmlData[i10 + 3] === "L" && xmlData[i10 + 4] === "E" && xmlData[i10 + 5] === "M" && xmlData[i10 + 6] === "E" && xmlData[i10 + 7] === "N" && xmlData[i10 + 8] === "T")
        return true;
      return false;
    }
    function isAttlist(xmlData, i10) {
      if (xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "A" && xmlData[i10 + 3] === "T" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "L" && xmlData[i10 + 6] === "I" && xmlData[i10 + 7] === "S" && xmlData[i10 + 8] === "T")
        return true;
      return false;
    }
    function isNotation(xmlData, i10) {
      if (xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "N" && xmlData[i10 + 3] === "O" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "A" && xmlData[i10 + 6] === "T" && xmlData[i10 + 7] === "I" && xmlData[i10 + 8] === "O" && xmlData[i10 + 9] === "N")
        return true;
      return false;
    }
    function validateEntityName(name) {
      if (util.isName(name))
        return name;
      else
        throw new Error(`Invalid entity name ${name}`);
    }
    module2.exports = readDocType;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module2) {
    "use strict";
    var util = require_util2();
    var xmlNode = require_xmlNode2();
    var readDocType = require_DocTypeReader2();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i10 = 0; i10 < entKeys.length; i10++) {
        const ent = entKeys[i10];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val2 !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val2 = val2.trim();
        }
        if (val2.length > 0) {
          if (!escapeEntities)
            val2 = this.replaceEntitiesValue(val2);
          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val2;
          } else if (typeof newval !== typeof val2 || newval !== val2) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val2.trim();
            if (trimmedVal === val2) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val2;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i10 = 0; i10 < len; i10++) {
          const attrName = this.resolveNameSpace(matches[i10][1]);
          let oldVal = matches[i10][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i10 = 0; i10 < xmlData.length; i10++) {
        const ch = xmlData[i10];
        if (ch === "<") {
          if (xmlData[i10 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i10, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i10 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i10 = closeIndex;
          } else if (xmlData[i10 + 1] === "?") {
            let tagData = readTagExp(xmlData, i10, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i10 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i10 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i10 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i10 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i10 = endIndex;
          } else if (xmlData.substr(i10 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i10);
            this.docTypeEntities = result.entities;
            i10 = result.i;
          } else if (xmlData.substr(i10 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i10, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i10 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val2 == void 0)
                val2 = "";
              currentNode.add(this.options.textNodeName, val2);
            }
            i10 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i10, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i10 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i10 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i10 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i10 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i10];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val2) {
      if (this.options.processEntities) {
        for (let entityName2 in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName2];
          val2 = val2.replace(entity.regx, entity.val);
        }
        for (let entityName2 in this.lastEntities) {
          const entity = this.lastEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName2 in this.htmlEntities) {
            const entity = this.htmlEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
        }
        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val2;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i10, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i10; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary)
            attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str, i10, errMsg) {
      const closingIndex = xmlData.indexOf(str, i10);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i10, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i10 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    function readStopNodeData(xmlData, tagName, i10) {
      const startIndex = i10;
      let openTagCount = 1;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === "<") {
          if (xmlData[i10 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i10, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i10 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i10),
                  i: closeIndex
                };
              }
            }
            i10 = closeIndex;
          } else if (xmlData[i10 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i10 + 1, "StopNode is not closed.");
            i10 = closeIndex;
          } else if (xmlData.substr(i10 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i10 + 3, "StopNode is not closed.");
            i10 = closeIndex;
          } else if (xmlData.substr(i10 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i10, "StopNode is not closed.") - 2;
            i10 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i10, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i10 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val2, shouldParse, options) {
      if (shouldParse && typeof val2 === "string") {
        const newval = val2.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val2, options);
      } else {
        if (util.isExist(val2)) {
          return val2;
        } else {
          return "";
        }
      }
    }
    module2.exports = OrderedObjParser;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i10 = 0; i10 < arr.length; i10++) {
        const tagObj = arr[i10];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val2 = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val2, options);
          if (tagObj[":@"]) {
            assignAttributes(val2, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val2 = val2[options.textNodeName];
          } else if (Object.keys(val2).length === 0) {
            if (options.alwaysCreateTextNode)
              val2[options.textNodeName] = "";
            else
              val2 = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val2);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val2];
            } else {
              compressedObj[property] = val2;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key = keys[i10];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i10 = 0; i10 < len; i10++) {
          const atrrName = keys[i10];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module2) {
    "use strict";
    var { buildOptions } = require_OptionsBuilder2();
    var OrderedObjParser = require_OrderedObjParser2();
    var { prettify } = require_node2json2();
    var validator = require_validator2();
    var XMLParser4 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module2.exports = XMLParser4;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module2) {
    "use strict";
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i10 = 0; i10 < arr.length; i10++) {
        const tagObj = arr[i10];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key = keys[i10];
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i10 = 0; i10 < options.entities.length; i10++) {
          const entity = options.entities[i10];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module2.exports = toXml;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module2) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml2();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a10) {
        return a10;
      },
      attributeValueProcessor: function(attrName, a10) {
        return a10;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val2 = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          if (key[0] === "?")
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val2 += this.replaceEntitiesValue(newval);
            } else {
              val2 += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          for (let j10 = 0; j10 < arrLen; j10++) {
            const item = jObj[key][j10];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                listTagVal += this.j2x(item, level + 1).val;
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level);
              }
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, "", level);
          }
          val2 += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L2 = Ks.length;
            for (let j10 = 0; j10 < L2; j10++) {
              attrStr += this.buildAttrPairStr(Ks[j10], "" + jObj[key][Ks[j10]]);
            }
          } else {
            val2 += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val: val2 };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val2) {
      val2 = this.options.attributeValueProcessor(attrName, "" + val2);
      val2 = this.replaceEntitiesValue(val2);
      if (this.options.suppressBooleanAttributes && val2 === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val2 + '"';
    };
    function processTextOrObjNode(object2, key, level) {
      const result = this.j2x(object2, level + 1);
      if (object2[this.options.textNodeName] !== void 0 && Object.keys(object2).length === 1) {
        return this.buildTextValNode(object2[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
      if (val2 === "") {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if (attrStr && val2.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val2);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i10 = 0; i10 < this.options.entities.length; i10++) {
          const entity = this.options.entities[i10];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix)) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module2.exports = Builder;
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/fxp.js
var require_fxp2 = __commonJS({
  "../../node_modules/@aws-sdk/client-dynamodb/node_modules/fast-xml-parser/src/fxp.js"(exports, module2) {
    "use strict";
    var validator = require_validator2();
    var XMLParser4 = require_XMLParser2();
    var XMLBuilder = require_json2xml2();
    module2.exports = {
      XMLParser: XMLParser4,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// ../../node_modules/chunk/src/chunk.js
var require_chunk = __commonJS({
  "../../node_modules/chunk/src/chunk.js"(exports, module2) {
    "use strict";
    (function() {
      function chunk2(collection, size) {
        var result = [];
        size = parseInt(size) || 2;
        for (var x4 = 0; x4 < Math.ceil(collection.length / size); x4++) {
          var start = x4 * size;
          var end = start + size;
          result.push(collection.slice(start, end));
        }
        return result;
      }
      if (typeof exports !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports = module2.exports = chunk2;
        }
        exports.chunk = chunk2;
      } else {
        this.chunk = chunk2;
      }
    }).call(exports);
  }
});

// ../../node_modules/throat/index.js
var require_throat = __commonJS({
  "../../node_modules/throat/index.js"(exports, module2) {
    "use strict";
    function throatInternal(size) {
      var queue = new Queue();
      var s10 = size | 0;
      function run(fn, self2, args) {
        if ((s10 | 0) !== 0) {
          s10 = (s10 | 0) - 1;
          return new Promise(function(resolve) {
            resolve(fn.apply(self2, args));
          }).then(onFulfill, onReject);
        }
        return new Promise(function(resolve) {
          queue.push(new Delayed(resolve, fn, self2, args));
        }).then(runDelayed);
      }
      function runDelayed(d10) {
        try {
          return Promise.resolve(d10.fn.apply(d10.self, d10.args)).then(
            onFulfill,
            onReject
          );
        } catch (ex) {
          onReject(ex);
        }
      }
      function onFulfill(result) {
        release3();
        return result;
      }
      function onReject(error) {
        release3();
        throw error;
      }
      function release3() {
        var next = queue.shift();
        if (next) {
          next.resolve(next);
        } else {
          s10 = (s10 | 0) + 1;
        }
      }
      return run;
    }
    function earlyBound(size, fn) {
      const run = throatInternal(size | 0);
      return function() {
        var args = new Array(arguments.length);
        for (var i10 = 0; i10 < arguments.length; i10++) {
          args[i10] = arguments[i10];
        }
        return run(fn, this, args);
      };
    }
    function lateBound(size) {
      const run = throatInternal(size | 0);
      return function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError(
            "Expected throat fn to be a function but got " + typeof fn
          );
        }
        var args = new Array(arguments.length - 1);
        for (var i10 = 1; i10 < arguments.length; i10++) {
          args[i10 - 1] = arguments[i10];
        }
        return run(fn, this, args);
      };
    }
    module2.exports = function throat2(size, fn) {
      if (typeof size === "function") {
        var temp = fn;
        fn = size;
        size = temp;
      }
      if (typeof size !== "number") {
        throw new TypeError(
          "Expected throat size to be a number but got " + typeof size
        );
      }
      if (fn !== void 0 && typeof fn !== "function") {
        throw new TypeError(
          "Expected throat fn to be a function but got " + typeof fn
        );
      }
      if (typeof fn === "function") {
        return earlyBound(size | 0, fn);
      } else {
        return lateBound(size | 0);
      }
    };
    module2.exports.default = module2.exports;
    function Delayed(resolve, fn, self2, args) {
      this.resolve = resolve;
      this.fn = fn;
      this.self = self2 || null;
      this.args = args;
    }
    var blockSize = 64;
    function Queue() {
      this._s1 = [];
      this._s2 = [];
      this._shiftBlock = this._pushBlock = new Array(blockSize);
      this._pushIndex = 0;
      this._shiftIndex = 0;
    }
    Queue.prototype.push = function(value) {
      if (this._pushIndex === blockSize) {
        this._pushIndex = 0;
        this._s1[this._s1.length] = this._pushBlock = new Array(blockSize);
      }
      this._pushBlock[this._pushIndex++] = value;
    };
    Queue.prototype.shift = function() {
      if (this._shiftIndex === blockSize) {
        var s22 = this._s2;
        if (s22.length === 0) {
          var s1 = this._s1;
          if (s1.length === 0) {
            return void 0;
          }
          this._s1 = s22;
          s22 = this._s2 = s1.reverse();
        }
        this._shiftIndex = 0;
        this._shiftBlock = s22.pop();
      }
      if (this._pushBlock === this._shiftBlock && this._pushIndex === this._shiftIndex) {
        return void 0;
      }
      var result = this._shiftBlock[this._shiftIndex];
      this._shiftBlock[this._shiftIndex++] = null;
      return result;
    };
  }
});

// ../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/deepmerge/dist/cjs.js"(exports, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val2) {
      return Array.isArray(val2) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object2, property) {
      try {
        return property in object2;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array2, options) {
      if (!Array.isArray(array2)) {
        throw new Error("first argument should be an array");
      }
      return array2.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module2.exports = deepmerge_1;
  }
});

// schedule/index.ts
var schedule_exports = {};
__export(schedule_exports, {
  Schedule: () => Schedule,
  ScheduleError: () => ScheduleError,
  convertRateToCron: () => convertRateToCron,
  default: () => schedule_default,
  getConfig: () => getConfig,
  getHandlers: () => getHandlers,
  schedule: () => schedule
});
module.exports = __toCommonJS(schedule_exports);
var import_cron_validate = __toESM(require_lib(), 1);

// schedule/schedule-utils.ts
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_utc = __toESM(require_utc(), 1);
import_dayjs.default.extend(import_utc.default);
function validUnit(unit, items) {
  return items.includes(unit) || items.includes(unit + "s");
}
function convertRateToCron(rate) {
  if (!rate) {
    return;
  }
  const [_num, unit] = rate.toLowerCase().split(" ");
  if (!validUnit(unit, ["minutes", "hours", "days"])) {
    return;
  }
  const num = Number.parseInt(_num);
  if (isNaN(num) || num <= 0) {
    return;
  }
  switch (unit) {
    case "minute":
    case "minutes":
      if (num < 60 && 60 % num === 0) {
        return `0/${num} * * * ? *`;
      }
      break;
    case "hour":
    case "hours":
      if (num < 24 && 24 % num === 0) {
        return `0 */${num} * * ? *`;
      }
      break;
  }
  return;
}

// ../../lib/aws/client.ts
var import_dread = __toESM(require_dread(), 1);
var import_node_crypto = require("crypto");

// ../../node_modules/aws4fetch/dist/aws4fetch.esm.mjs
var encoder = new TextEncoder();
var HOST_SERVICES = {
  appstream2: "appstream",
  cloudhsmv2: "cloudhsm",
  email: "ses",
  marketplace: "aws-marketplace",
  mobile: "AWSMobileHubService",
  pinpoint: "mobiletargeting",
  queue: "sqs",
  "git-codecommit": "codecommit",
  "mturk-requester-sandbox": "mturk-requester",
  "personalize-runtime": "personalize"
};
var UNSIGNABLE_HEADERS = /* @__PURE__ */ new Set([
  "authorization",
  "content-type",
  "content-length",
  "user-agent",
  "presigned-expires",
  "expect",
  "x-amzn-trace-id",
  "range",
  "connection"
]);
var AwsClient = class {
  constructor({ accessKeyId, secretAccessKey, sessionToken, service, region, cache, retries, initRetryMs }) {
    if (accessKeyId == null)
      throw new TypeError("accessKeyId is a required option");
    if (secretAccessKey == null)
      throw new TypeError("secretAccessKey is a required option");
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.sessionToken = sessionToken;
    this.service = service;
    this.region = region;
    this.cache = cache || /* @__PURE__ */ new Map();
    this.retries = retries != null ? retries : 10;
    this.initRetryMs = initRetryMs || 50;
  }
  async sign(input, init) {
    if (input instanceof Request) {
      const { method, url, headers, body } = input;
      init = Object.assign({ method, url, headers }, init);
      if (init.body == null && headers.has("Content-Type")) {
        init.body = body != null && headers.has("X-Amz-Content-Sha256") ? body : await input.clone().arrayBuffer();
      }
      input = url;
    }
    const signer = new AwsV4Signer(Object.assign({ url: input }, init, this, init && init.aws));
    const signed = Object.assign({}, init, await signer.sign());
    delete signed.aws;
    try {
      return new Request(signed.url.toString(), signed);
    } catch (e10) {
      if (e10 instanceof TypeError) {
        return new Request(signed.url.toString(), Object.assign({ duplex: "half" }, signed));
      }
      throw e10;
    }
  }
  async fetch(input, init) {
    for (let i10 = 0; i10 <= this.retries; i10++) {
      const fetched = fetch(await this.sign(input, init));
      if (i10 === this.retries) {
        return fetched;
      }
      const res = await fetched;
      if (res.status < 500 && res.status !== 429) {
        return res;
      }
      await new Promise((resolve) => setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i10)));
    }
    throw new Error("An unknown error occurred, ensure retries is not negative");
  }
};
var AwsV4Signer = class {
  constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {
    if (url == null)
      throw new TypeError("url is a required option");
    if (accessKeyId == null)
      throw new TypeError("accessKeyId is a required option");
    if (secretAccessKey == null)
      throw new TypeError("secretAccessKey is a required option");
    this.method = method || (body ? "POST" : "GET");
    this.url = new URL(url);
    this.headers = new Headers(headers || {});
    this.body = body;
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.sessionToken = sessionToken;
    let guessedService, guessedRegion;
    if (!service || !region) {
      [guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);
    }
    this.service = service || guessedService || "";
    this.region = region || guessedRegion || "us-east-1";
    this.cache = cache || /* @__PURE__ */ new Map();
    this.datetime = datetime || (/* @__PURE__ */ new Date()).toISOString().replace(/[:-]|\.\d{3}/g, "");
    this.signQuery = signQuery;
    this.appendSessionToken = appendSessionToken || this.service === "iotdevicegateway";
    this.headers.delete("Host");
    if (this.service === "s3" && !this.signQuery && !this.headers.has("X-Amz-Content-Sha256")) {
      this.headers.set("X-Amz-Content-Sha256", "UNSIGNED-PAYLOAD");
    }
    const params = this.signQuery ? this.url.searchParams : this.headers;
    params.set("X-Amz-Date", this.datetime);
    if (this.sessionToken && !this.appendSessionToken) {
      params.set("X-Amz-Security-Token", this.sessionToken);
    }
    this.signableHeaders = ["host", ...this.headers.keys()].filter((header) => allHeaders || !UNSIGNABLE_HEADERS.has(header)).sort();
    this.signedHeaders = this.signableHeaders.join(";");
    this.canonicalHeaders = this.signableHeaders.map((header) => header + ":" + (header === "host" ? this.url.host : (this.headers.get(header) || "").replace(/\s+/g, " "))).join("\n");
    this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, "aws4_request"].join("/");
    if (this.signQuery) {
      if (this.service === "s3" && !params.has("X-Amz-Expires")) {
        params.set("X-Amz-Expires", "86400");
      }
      params.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256");
      params.set("X-Amz-Credential", this.accessKeyId + "/" + this.credentialString);
      params.set("X-Amz-SignedHeaders", this.signedHeaders);
    }
    if (this.service === "s3") {
      try {
        this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, " "));
      } catch (e10) {
        this.encodedPath = this.url.pathname;
      }
    } else {
      this.encodedPath = this.url.pathname.replace(/\/+/g, "/");
    }
    if (!singleEncode) {
      this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, "/");
    }
    this.encodedPath = encodeRfc3986(this.encodedPath);
    const seenKeys = /* @__PURE__ */ new Set();
    this.encodedSearch = [...this.url.searchParams].filter(([k10]) => {
      if (!k10)
        return false;
      if (this.service === "s3") {
        if (seenKeys.has(k10))
          return false;
        seenKeys.add(k10);
      }
      return true;
    }).map((pair) => pair.map((p10) => encodeRfc3986(encodeURIComponent(p10)))).sort(([k1, v1], [k22, v22]) => k1 < k22 ? -1 : k1 > k22 ? 1 : v1 < v22 ? -1 : v1 > v22 ? 1 : 0).map((pair) => pair.join("=")).join("&");
  }
  async sign() {
    if (this.signQuery) {
      this.url.searchParams.set("X-Amz-Signature", await this.signature());
      if (this.sessionToken && this.appendSessionToken) {
        this.url.searchParams.set("X-Amz-Security-Token", this.sessionToken);
      }
    } else {
      this.headers.set("Authorization", await this.authHeader());
    }
    return {
      method: this.method,
      url: this.url,
      headers: this.headers,
      body: this.body
    };
  }
  async authHeader() {
    return [
      "AWS4-HMAC-SHA256 Credential=" + this.accessKeyId + "/" + this.credentialString,
      "SignedHeaders=" + this.signedHeaders,
      "Signature=" + await this.signature()
    ].join(", ");
  }
  async signature() {
    const date2 = this.datetime.slice(0, 8);
    const cacheKey = [this.secretAccessKey, date2, this.region, this.service].join();
    let kCredentials = this.cache.get(cacheKey);
    if (!kCredentials) {
      const kDate = await hmac("AWS4" + this.secretAccessKey, date2);
      const kRegion = await hmac(kDate, this.region);
      const kService = await hmac(kRegion, this.service);
      kCredentials = await hmac(kService, "aws4_request");
      this.cache.set(cacheKey, kCredentials);
    }
    return buf2hex(await hmac(kCredentials, await this.stringToSign()));
  }
  async stringToSign() {
    return [
      "AWS4-HMAC-SHA256",
      this.datetime,
      this.credentialString,
      buf2hex(await hash(await this.canonicalString()))
    ].join("\n");
  }
  async canonicalString() {
    return [
      this.method.toUpperCase(),
      this.encodedPath,
      this.encodedSearch,
      this.canonicalHeaders + "\n",
      this.signedHeaders,
      await this.hexBodyHash()
    ].join("\n");
  }
  async hexBodyHash() {
    let hashHeader = this.headers.get("X-Amz-Content-Sha256") || (this.service === "s3" && this.signQuery ? "UNSIGNED-PAYLOAD" : null);
    if (hashHeader == null) {
      if (this.body && typeof this.body !== "string" && !("byteLength" in this.body)) {
        throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");
      }
      hashHeader = buf2hex(await hash(this.body || ""));
    }
    return hashHeader;
  }
};
async function hmac(key, string2) {
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    typeof key === "string" ? encoder.encode(key) : key,
    { name: "HMAC", hash: { name: "SHA-256" } },
    false,
    ["sign"]
  );
  return crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(string2));
}
async function hash(content) {
  return crypto.subtle.digest("SHA-256", typeof content === "string" ? encoder.encode(content) : content);
}
function buf2hex(buffer) {
  return Array.prototype.map.call(new Uint8Array(buffer), (x4) => ("0" + x4.toString(16)).slice(-2)).join("");
}
function encodeRfc3986(urlEncodedStr) {
  return urlEncodedStr.replace(/[!'()*]/g, (c10) => "%" + c10.charCodeAt(0).toString(16).toUpperCase());
}
function guessServiceRegion(url, headers) {
  const { hostname, pathname } = url;
  if (hostname.endsWith(".r2.cloudflarestorage.com")) {
    return ["s3", "auto"];
  }
  if (hostname.endsWith(".backblazeb2.com")) {
    const match2 = hostname.match(/^(?:[^.]+\.)?s3\.([^.]+)\.backblazeb2\.com$/);
    return match2 != null ? ["s3", match2[1]] : ["", ""];
  }
  const match = hostname.replace("dualstack.", "").match(/([^.]+)\.(?:([^.]*)\.)?amazonaws\.com(?:\.cn)?$/);
  let [service, region] = (match || ["", ""]).slice(1, 3);
  if (region === "us-gov") {
    region = "us-gov-west-1";
  } else if (region === "s3" || region === "s3-accelerate") {
    region = "us-east-1";
    service = "s3";
  } else if (service === "iot") {
    if (hostname.startsWith("iot.")) {
      service = "execute-api";
    } else if (hostname.startsWith("data.jobs.iot.")) {
      service = "iot-jobs-data";
    } else {
      service = pathname === "/mqtt" ? "iotdevicegateway" : "iotdata";
    }
  } else if (service === "autoscaling") {
    const targetPrefix = (headers.get("X-Amz-Target") || "").split(".")[0];
    if (targetPrefix === "AnyScaleFrontendService") {
      service = "application-autoscaling";
    } else if (targetPrefix === "AnyScaleScalingPlannerFrontendService") {
      service = "autoscaling-plans";
    }
  } else if (region == null && service.startsWith("s3-")) {
    region = service.slice(3).replace(/^fips-|^external-1/, "");
    service = "s3";
  } else if (service.endsWith("-fips")) {
    service = service.slice(0, -5);
  } else if (region && /-\d$/.test(service) && !/-\d$/.test(region)) {
    [service, region] = [region, service];
  }
  return [HOST_SERVICES[service] || service, region];
}

// ../../lib/runtime-store/index.ts
var import_node_async_hooks = require("async_hooks");
function getStore() {
  return globalThis.RuntimeStore?.getStore();
}
function getInvocationId() {
  const store = getStore();
  return store?.event?.executionId || store?.context?.awsRequestId;
}
function getInvocationType() {
  const store = getStore();
  return store?.invocationType;
}

// ../../lib/runtime-logging/index.ts
function systemError(errOrMsg, _msg) {
  const err = typeof errOrMsg === "string" ? void 0 : errOrMsg;
  const msg = typeof errOrMsg === "string" ? errOrMsg : _msg;
  const reqId = getInvocationId();
  const type = getInvocationType() || "system";
  process.stdout.write(
    JSON.stringify({
      _slsLog: true,
      time: Date.now(),
      level: 50,
      msg,
      reqId,
      type,
      ...err && { err: { message: err.message, stack: err.stack, code: err.code, name: err.name } }
    }) + "\n"
  );
}
function applicationWarning(errOrMsg, _msg) {
  const err = typeof errOrMsg === "string" ? void 0 : errOrMsg;
  const msg = typeof errOrMsg === "string" ? errOrMsg : _msg;
  const reqId = getInvocationId();
  const type = getInvocationType() || "system";
  process.stdout.write(
    JSON.stringify({
      time: Date.now(),
      level: 40,
      reqId,
      type,
      msg,
      ...err && { err: { message: err.message, stack: err.stack, code: err.code, name: err.name } }
    }) + "\n"
  );
}

// ../../lib/aws/credentials.ts
var import_promises = require("timers/promises");
var defaultProvider2;
async function loadDefaultProvider() {
  if (!defaultProvider2) {
    const { fromNodeProviderChain: fromNodeProviderChain2 } = await Promise.resolve().then(() => (init_dist_es52(), dist_es_exports));
    defaultProvider2 = fromNodeProviderChain2();
  }
  return defaultProvider2;
}
async function loadCredentials() {
  if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
    return {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      sessionToken: process.env.AWS_SESSION_TOKEN
    };
  }
  const defaultProvider4 = await loadDefaultProvider();
  for (let attempt = 0; attempt < 10; attempt++) {
    try {
      return await defaultProvider4();
    } catch (err) {
      await (0, import_promises.setTimeout)(1e3);
    }
  }
  throw new Error("Unable to load credentials");
}

// ../../lib/aws/client.ts
var _client;
var RetryableError = class extends Error {
  retryable = true;
  name = "RetryableError";
};
var AmptAwsClient = class extends AwsClient {
  fetch(input, init) {
    return (0, import_dread.default)(() => {
      try {
        return super.fetch(input, init);
      } catch (err) {
        systemError(err, "aws4fetch error");
        throw new RetryableError("aws4fetch error", { cause: err });
      }
    });
  }
};
async function getClient() {
  if (!_client) {
    const credentials = await loadCredentials();
    if (!globalThis.crypto) {
      Object.assign(globalThis, { crypto: import_node_crypto.webcrypto });
    }
    _client = new AmptAwsClient({
      accessKeyId: credentials.accessKeyId,
      secretAccessKey: credentials.secretAccessKey,
      sessionToken: credentials.sessionToken,
      region: process.env.AWS_REGION,
      retries: 7
      // 50ms, 100ms, 200ms, 400ms, 800ms, 1600ms, 3200ms (total 6.3s)
    });
    if (credentials.expiration) {
      setTimeout(() => {
        _client = void 0;
      }, credentials.expiration.getTime() - Date.now() - 3e4).unref();
    }
  }
  return _client;
}

// ../../lib/aws/lambda.ts
async function invoke(functionName, invocationType, body) {
  const client = await getClient();
  const url = `https://lambda.${process.env.AWS_REGION}.amazonaws.com/2015-03-31/functions/${functionName}/invocations`;
  const response = await client.fetch(url, {
    body,
    headers: {
      "X-Amz-Invocation-Type": invocationType,
      "X-Amz-Log-Type": "None"
    }
  });
  if (response.status === 200 || response.status === 202) {
    if (response.headers.get("content-type") === "application/json" && Number.parseInt(response.headers.get("content-length") || "0") > 0) {
      return await response.json();
    }
  } else {
    throw new Error(`Unable to invoke function "${functionName}": ${response.status}`);
  }
}

// ../../lib/runtime-api/tasks.ts
var MAX_TASK_TIMEOUT_MS = Number.parseInt(process.env.MAX_TASK_TIMEOUT_MS || "900000");
async function executeTask(name, config, body, after) {
  if (!process.env.RUNTIME_API_ARN) {
    throw new Error("RUNTIME_API_ARN is not defined");
  }
  const result = await invoke(
    process.env.RUNTIME_API_ARN,
    "RequestResponse",
    JSON.stringify({
      method: "Task:ExecuteTask" /* ExecuteTask */,
      args: {
        after,
        name,
        config,
        body
      }
    })
  );
  if (result.errorType) {
    throw new Error(result.errorMessage);
  }
  return result;
}
async function getExecution(id) {
  if (!process.env.RUNTIME_API_ARN) {
    throw new Error("RUNTIME_API_ARN is not defined");
  }
  const result = await invoke(
    process.env.RUNTIME_API_ARN,
    "RequestResponse",
    JSON.stringify({ method: "Task:GetExecution" /* GetExecution */, args: { id } })
  );
  if (result?.errorType) {
    throw new Error(result.errorMessage);
  }
  return result;
}

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/AddPermissionCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();

// ../../node_modules/@aws-sdk/client-sqs/dist-es/models/SQSServiceException.js
init_dist_es26();
var SQSServiceException = class _SQSServiceException extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _SQSServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/models/models_0.js
var OverLimit = class _OverLimit extends SQSServiceException {
  constructor(opts) {
    super({
      name: "OverLimit",
      $fault: "client",
      ...opts
    });
    this.name = "OverLimit";
    this.$fault = "client";
    Object.setPrototypeOf(this, _OverLimit.prototype);
  }
};
var MessageNotInflight = class _MessageNotInflight extends SQSServiceException {
  constructor(opts) {
    super({
      name: "MessageNotInflight",
      $fault: "client",
      ...opts
    });
    this.name = "MessageNotInflight";
    this.$fault = "client";
    Object.setPrototypeOf(this, _MessageNotInflight.prototype);
  }
};
var ReceiptHandleIsInvalid = class _ReceiptHandleIsInvalid extends SQSServiceException {
  constructor(opts) {
    super({
      name: "ReceiptHandleIsInvalid",
      $fault: "client",
      ...opts
    });
    this.name = "ReceiptHandleIsInvalid";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ReceiptHandleIsInvalid.prototype);
  }
};
var BatchEntryIdsNotDistinct = class _BatchEntryIdsNotDistinct extends SQSServiceException {
  constructor(opts) {
    super({
      name: "BatchEntryIdsNotDistinct",
      $fault: "client",
      ...opts
    });
    this.name = "BatchEntryIdsNotDistinct";
    this.$fault = "client";
    Object.setPrototypeOf(this, _BatchEntryIdsNotDistinct.prototype);
  }
};
var EmptyBatchRequest = class _EmptyBatchRequest extends SQSServiceException {
  constructor(opts) {
    super({
      name: "EmptyBatchRequest",
      $fault: "client",
      ...opts
    });
    this.name = "EmptyBatchRequest";
    this.$fault = "client";
    Object.setPrototypeOf(this, _EmptyBatchRequest.prototype);
  }
};
var InvalidBatchEntryId = class _InvalidBatchEntryId extends SQSServiceException {
  constructor(opts) {
    super({
      name: "InvalidBatchEntryId",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidBatchEntryId";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidBatchEntryId.prototype);
  }
};
var TooManyEntriesInBatchRequest = class _TooManyEntriesInBatchRequest extends SQSServiceException {
  constructor(opts) {
    super({
      name: "TooManyEntriesInBatchRequest",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyEntriesInBatchRequest";
    this.$fault = "client";
    Object.setPrototypeOf(this, _TooManyEntriesInBatchRequest.prototype);
  }
};
var QueueDeletedRecently = class _QueueDeletedRecently extends SQSServiceException {
  constructor(opts) {
    super({
      name: "QueueDeletedRecently",
      $fault: "client",
      ...opts
    });
    this.name = "QueueDeletedRecently";
    this.$fault = "client";
    Object.setPrototypeOf(this, _QueueDeletedRecently.prototype);
  }
};
var QueueNameExists = class _QueueNameExists extends SQSServiceException {
  constructor(opts) {
    super({
      name: "QueueNameExists",
      $fault: "client",
      ...opts
    });
    this.name = "QueueNameExists";
    this.$fault = "client";
    Object.setPrototypeOf(this, _QueueNameExists.prototype);
  }
};
var InvalidIdFormat = class _InvalidIdFormat extends SQSServiceException {
  constructor(opts) {
    super({
      name: "InvalidIdFormat",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidIdFormat";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidIdFormat.prototype);
  }
};
var InvalidAttributeName = class _InvalidAttributeName extends SQSServiceException {
  constructor(opts) {
    super({
      name: "InvalidAttributeName",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidAttributeName";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidAttributeName.prototype);
  }
};
var QueueDoesNotExist = class _QueueDoesNotExist extends SQSServiceException {
  constructor(opts) {
    super({
      name: "QueueDoesNotExist",
      $fault: "client",
      ...opts
    });
    this.name = "QueueDoesNotExist";
    this.$fault = "client";
    Object.setPrototypeOf(this, _QueueDoesNotExist.prototype);
  }
};
var PurgeQueueInProgress = class _PurgeQueueInProgress extends SQSServiceException {
  constructor(opts) {
    super({
      name: "PurgeQueueInProgress",
      $fault: "client",
      ...opts
    });
    this.name = "PurgeQueueInProgress";
    this.$fault = "client";
    Object.setPrototypeOf(this, _PurgeQueueInProgress.prototype);
  }
};
var InvalidMessageContents = class _InvalidMessageContents extends SQSServiceException {
  constructor(opts) {
    super({
      name: "InvalidMessageContents",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidMessageContents";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidMessageContents.prototype);
  }
};
var UnsupportedOperation = class _UnsupportedOperation extends SQSServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedOperation",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedOperation";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnsupportedOperation.prototype);
  }
};
var BatchRequestTooLong = class _BatchRequestTooLong extends SQSServiceException {
  constructor(opts) {
    super({
      name: "BatchRequestTooLong",
      $fault: "client",
      ...opts
    });
    this.name = "BatchRequestTooLong";
    this.$fault = "client";
    Object.setPrototypeOf(this, _BatchRequestTooLong.prototype);
  }
};
var AddPermissionRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var ChangeMessageVisibilityRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var ChangeMessageVisibilityBatchRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var ChangeMessageVisibilityBatchResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var CreateQueueRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var CreateQueueResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var DeleteMessageRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var DeleteMessageBatchRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var DeleteMessageBatchResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var DeleteQueueRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var GetQueueAttributesRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var GetQueueAttributesResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var GetQueueUrlRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var GetQueueUrlResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var ListDeadLetterSourceQueuesRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var ListDeadLetterSourceQueuesResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var ListQueuesRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var ListQueuesResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var ListQueueTagsRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var ListQueueTagsResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var PurgeQueueRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var ReceiveMessageRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var ReceiveMessageResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var RemovePermissionRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var SendMessageRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var SendMessageResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var SendMessageBatchRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var SendMessageBatchResultFilterSensitiveLog = (obj) => ({
  ...obj
});
var SetQueueAttributesRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var TagQueueRequestFilterSensitiveLog = (obj) => ({
  ...obj
});
var UntagQueueRequestFilterSensitiveLog = (obj) => ({
  ...obj
});

// ../../node_modules/@aws-sdk/client-sqs/dist-es/protocols/Aws_query.js
init_dist_es4();
init_dist_es26();
var import_fast_xml_parser2 = __toESM(require_fxp());
var serializeAws_queryAddPermissionCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryAddPermissionRequest(input, context),
    Action: "AddPermission",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryChangeMessageVisibilityCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryChangeMessageVisibilityRequest(input, context),
    Action: "ChangeMessageVisibility",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryChangeMessageVisibilityBatchCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryChangeMessageVisibilityBatchRequest(input, context),
    Action: "ChangeMessageVisibilityBatch",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryCreateQueueCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryCreateQueueRequest(input, context),
    Action: "CreateQueue",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryDeleteMessageCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryDeleteMessageRequest(input, context),
    Action: "DeleteMessage",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryDeleteMessageBatchCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryDeleteMessageBatchRequest(input, context),
    Action: "DeleteMessageBatch",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryDeleteQueueCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryDeleteQueueRequest(input, context),
    Action: "DeleteQueue",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryGetQueueAttributesCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryGetQueueAttributesRequest(input, context),
    Action: "GetQueueAttributes",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryGetQueueUrlCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryGetQueueUrlRequest(input, context),
    Action: "GetQueueUrl",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryListDeadLetterSourceQueuesCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryListDeadLetterSourceQueuesRequest(input, context),
    Action: "ListDeadLetterSourceQueues",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryListQueuesCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryListQueuesRequest(input, context),
    Action: "ListQueues",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryListQueueTagsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryListQueueTagsRequest(input, context),
    Action: "ListQueueTags",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryPurgeQueueCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryPurgeQueueRequest(input, context),
    Action: "PurgeQueue",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryReceiveMessageCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryReceiveMessageRequest(input, context),
    Action: "ReceiveMessage",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryRemovePermissionCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryRemovePermissionRequest(input, context),
    Action: "RemovePermission",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_querySendMessageCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_querySendMessageRequest(input, context),
    Action: "SendMessage",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_querySendMessageBatchCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_querySendMessageBatchRequest(input, context),
    Action: "SendMessageBatch",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_querySetQueueAttributesCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_querySetQueueAttributesRequest(input, context),
    Action: "SetQueueAttributes",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryTagQueueCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryTagQueueRequest(input, context),
    Action: "TagQueue",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var serializeAws_queryUntagQueueCommand = async (input, context) => {
  const headers = {
    "content-type": "application/x-www-form-urlencoded"
  };
  let body;
  body = buildFormUrlencodedString2({
    ...serializeAws_queryUntagQueueRequest(input, context),
    Action: "UntagQueue",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest3(context, headers, "/", void 0, body);
};
var deserializeAws_queryAddPermissionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryAddPermissionCommandError(output, context);
  }
  await collectBody5(output.body, context);
  const response = {
    $metadata: deserializeMetadata6(output)
  };
  return Promise.resolve(response);
};
var deserializeAws_queryAddPermissionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "OverLimit":
    case "com.amazonaws.sqs#OverLimit":
      throw await deserializeAws_queryOverLimitResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryChangeMessageVisibilityCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryChangeMessageVisibilityCommandError(output, context);
  }
  await collectBody5(output.body, context);
  const response = {
    $metadata: deserializeMetadata6(output)
  };
  return Promise.resolve(response);
};
var deserializeAws_queryChangeMessageVisibilityCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.MessageNotInflight":
    case "com.amazonaws.sqs#MessageNotInflight":
      throw await deserializeAws_queryMessageNotInflightResponse(parsedOutput, context);
    case "ReceiptHandleIsInvalid":
    case "com.amazonaws.sqs#ReceiptHandleIsInvalid":
      throw await deserializeAws_queryReceiptHandleIsInvalidResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryChangeMessageVisibilityBatchCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryChangeMessageVisibilityBatchCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_queryChangeMessageVisibilityBatchResult(data.ChangeMessageVisibilityBatchResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryChangeMessageVisibilityBatchCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.BatchEntryIdsNotDistinct":
    case "com.amazonaws.sqs#BatchEntryIdsNotDistinct":
      throw await deserializeAws_queryBatchEntryIdsNotDistinctResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.EmptyBatchRequest":
    case "com.amazonaws.sqs#EmptyBatchRequest":
      throw await deserializeAws_queryEmptyBatchRequestResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.InvalidBatchEntryId":
    case "com.amazonaws.sqs#InvalidBatchEntryId":
      throw await deserializeAws_queryInvalidBatchEntryIdResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.TooManyEntriesInBatchRequest":
    case "com.amazonaws.sqs#TooManyEntriesInBatchRequest":
      throw await deserializeAws_queryTooManyEntriesInBatchRequestResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryCreateQueueCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryCreateQueueCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_queryCreateQueueResult(data.CreateQueueResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryCreateQueueCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.QueueDeletedRecently":
    case "com.amazonaws.sqs#QueueDeletedRecently":
      throw await deserializeAws_queryQueueDeletedRecentlyResponse(parsedOutput, context);
    case "QueueAlreadyExists":
    case "com.amazonaws.sqs#QueueNameExists":
      throw await deserializeAws_queryQueueNameExistsResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryDeleteMessageCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryDeleteMessageCommandError(output, context);
  }
  await collectBody5(output.body, context);
  const response = {
    $metadata: deserializeMetadata6(output)
  };
  return Promise.resolve(response);
};
var deserializeAws_queryDeleteMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidIdFormat":
    case "com.amazonaws.sqs#InvalidIdFormat":
      throw await deserializeAws_queryInvalidIdFormatResponse(parsedOutput, context);
    case "ReceiptHandleIsInvalid":
    case "com.amazonaws.sqs#ReceiptHandleIsInvalid":
      throw await deserializeAws_queryReceiptHandleIsInvalidResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryDeleteMessageBatchCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryDeleteMessageBatchCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_queryDeleteMessageBatchResult(data.DeleteMessageBatchResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryDeleteMessageBatchCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.BatchEntryIdsNotDistinct":
    case "com.amazonaws.sqs#BatchEntryIdsNotDistinct":
      throw await deserializeAws_queryBatchEntryIdsNotDistinctResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.EmptyBatchRequest":
    case "com.amazonaws.sqs#EmptyBatchRequest":
      throw await deserializeAws_queryEmptyBatchRequestResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.InvalidBatchEntryId":
    case "com.amazonaws.sqs#InvalidBatchEntryId":
      throw await deserializeAws_queryInvalidBatchEntryIdResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.TooManyEntriesInBatchRequest":
    case "com.amazonaws.sqs#TooManyEntriesInBatchRequest":
      throw await deserializeAws_queryTooManyEntriesInBatchRequestResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryDeleteQueueCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryDeleteQueueCommandError(output, context);
  }
  await collectBody5(output.body, context);
  const response = {
    $metadata: deserializeMetadata6(output)
  };
  return Promise.resolve(response);
};
var deserializeAws_queryDeleteQueueCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  throwDefaultError({
    output,
    parsedBody: parsedBody.Error,
    exceptionCtor: SQSServiceException,
    errorCode
  });
};
var deserializeAws_queryGetQueueAttributesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryGetQueueAttributesCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_queryGetQueueAttributesResult(data.GetQueueAttributesResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryGetQueueAttributesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidAttributeName":
    case "com.amazonaws.sqs#InvalidAttributeName":
      throw await deserializeAws_queryInvalidAttributeNameResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryGetQueueUrlCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryGetQueueUrlCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_queryGetQueueUrlResult(data.GetQueueUrlResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryGetQueueUrlCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.NonExistentQueue":
    case "com.amazonaws.sqs#QueueDoesNotExist":
      throw await deserializeAws_queryQueueDoesNotExistResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryListDeadLetterSourceQueuesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryListDeadLetterSourceQueuesCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_queryListDeadLetterSourceQueuesResult(data.ListDeadLetterSourceQueuesResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryListDeadLetterSourceQueuesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.NonExistentQueue":
    case "com.amazonaws.sqs#QueueDoesNotExist":
      throw await deserializeAws_queryQueueDoesNotExistResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryListQueuesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryListQueuesCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_queryListQueuesResult(data.ListQueuesResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryListQueuesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  throwDefaultError({
    output,
    parsedBody: parsedBody.Error,
    exceptionCtor: SQSServiceException,
    errorCode
  });
};
var deserializeAws_queryListQueueTagsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryListQueueTagsCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_queryListQueueTagsResult(data.ListQueueTagsResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryListQueueTagsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  throwDefaultError({
    output,
    parsedBody: parsedBody.Error,
    exceptionCtor: SQSServiceException,
    errorCode
  });
};
var deserializeAws_queryPurgeQueueCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryPurgeQueueCommandError(output, context);
  }
  await collectBody5(output.body, context);
  const response = {
    $metadata: deserializeMetadata6(output)
  };
  return Promise.resolve(response);
};
var deserializeAws_queryPurgeQueueCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.NonExistentQueue":
    case "com.amazonaws.sqs#QueueDoesNotExist":
      throw await deserializeAws_queryQueueDoesNotExistResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.PurgeQueueInProgress":
    case "com.amazonaws.sqs#PurgeQueueInProgress":
      throw await deserializeAws_queryPurgeQueueInProgressResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryReceiveMessageCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryReceiveMessageCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_queryReceiveMessageResult(data.ReceiveMessageResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_queryReceiveMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "OverLimit":
    case "com.amazonaws.sqs#OverLimit":
      throw await deserializeAws_queryOverLimitResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryRemovePermissionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryRemovePermissionCommandError(output, context);
  }
  await collectBody5(output.body, context);
  const response = {
    $metadata: deserializeMetadata6(output)
  };
  return Promise.resolve(response);
};
var deserializeAws_queryRemovePermissionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  throwDefaultError({
    output,
    parsedBody: parsedBody.Error,
    exceptionCtor: SQSServiceException,
    errorCode
  });
};
var deserializeAws_querySendMessageCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_querySendMessageCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_querySendMessageResult(data.SendMessageResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_querySendMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.UnsupportedOperation":
    case "com.amazonaws.sqs#UnsupportedOperation":
      throw await deserializeAws_queryUnsupportedOperationResponse(parsedOutput, context);
    case "InvalidMessageContents":
    case "com.amazonaws.sqs#InvalidMessageContents":
      throw await deserializeAws_queryInvalidMessageContentsResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_querySendMessageBatchCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_querySendMessageBatchCommandError(output, context);
  }
  const data = await parseBody5(output.body, context);
  let contents = {};
  contents = deserializeAws_querySendMessageBatchResult(data.SendMessageBatchResult, context);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return Promise.resolve(response);
};
var deserializeAws_querySendMessageBatchCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.BatchEntryIdsNotDistinct":
    case "com.amazonaws.sqs#BatchEntryIdsNotDistinct":
      throw await deserializeAws_queryBatchEntryIdsNotDistinctResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.BatchRequestTooLong":
    case "com.amazonaws.sqs#BatchRequestTooLong":
      throw await deserializeAws_queryBatchRequestTooLongResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.EmptyBatchRequest":
    case "com.amazonaws.sqs#EmptyBatchRequest":
      throw await deserializeAws_queryEmptyBatchRequestResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.InvalidBatchEntryId":
    case "com.amazonaws.sqs#InvalidBatchEntryId":
      throw await deserializeAws_queryInvalidBatchEntryIdResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.TooManyEntriesInBatchRequest":
    case "com.amazonaws.sqs#TooManyEntriesInBatchRequest":
      throw await deserializeAws_queryTooManyEntriesInBatchRequestResponse(parsedOutput, context);
    case "AWS.SimpleQueueService.UnsupportedOperation":
    case "com.amazonaws.sqs#UnsupportedOperation":
      throw await deserializeAws_queryUnsupportedOperationResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_querySetQueueAttributesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_querySetQueueAttributesCommandError(output, context);
  }
  await collectBody5(output.body, context);
  const response = {
    $metadata: deserializeMetadata6(output)
  };
  return Promise.resolve(response);
};
var deserializeAws_querySetQueueAttributesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidAttributeName":
    case "com.amazonaws.sqs#InvalidAttributeName":
      throw await deserializeAws_queryInvalidAttributeNameResponse(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: SQSServiceException,
        errorCode
      });
  }
};
var deserializeAws_queryTagQueueCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryTagQueueCommandError(output, context);
  }
  await collectBody5(output.body, context);
  const response = {
    $metadata: deserializeMetadata6(output)
  };
  return Promise.resolve(response);
};
var deserializeAws_queryTagQueueCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  throwDefaultError({
    output,
    parsedBody: parsedBody.Error,
    exceptionCtor: SQSServiceException,
    errorCode
  });
};
var deserializeAws_queryUntagQueueCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return deserializeAws_queryUntagQueueCommandError(output, context);
  }
  await collectBody5(output.body, context);
  const response = {
    $metadata: deserializeMetadata6(output)
  };
  return Promise.resolve(response);
};
var deserializeAws_queryUntagQueueCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  throwDefaultError({
    output,
    parsedBody: parsedBody.Error,
    exceptionCtor: SQSServiceException,
    errorCode
  });
};
var deserializeAws_queryBatchEntryIdsNotDistinctResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryBatchEntryIdsNotDistinct(body.Error, context);
  const exception = new BatchEntryIdsNotDistinct({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryBatchRequestTooLongResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryBatchRequestTooLong(body.Error, context);
  const exception = new BatchRequestTooLong({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryEmptyBatchRequestResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryEmptyBatchRequest(body.Error, context);
  const exception = new EmptyBatchRequest({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryInvalidAttributeNameResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryInvalidAttributeName(body.Error, context);
  const exception = new InvalidAttributeName({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryInvalidBatchEntryIdResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryInvalidBatchEntryId(body.Error, context);
  const exception = new InvalidBatchEntryId({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryInvalidIdFormatResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryInvalidIdFormat(body.Error, context);
  const exception = new InvalidIdFormat({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryInvalidMessageContentsResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryInvalidMessageContents(body.Error, context);
  const exception = new InvalidMessageContents({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryMessageNotInflightResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryMessageNotInflight(body.Error, context);
  const exception = new MessageNotInflight({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryOverLimitResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryOverLimit(body.Error, context);
  const exception = new OverLimit({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryPurgeQueueInProgressResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryPurgeQueueInProgress(body.Error, context);
  const exception = new PurgeQueueInProgress({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryQueueDeletedRecentlyResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryQueueDeletedRecently(body.Error, context);
  const exception = new QueueDeletedRecently({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryQueueDoesNotExistResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryQueueDoesNotExist(body.Error, context);
  const exception = new QueueDoesNotExist({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryQueueNameExistsResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryQueueNameExists(body.Error, context);
  const exception = new QueueNameExists({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryReceiptHandleIsInvalidResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryReceiptHandleIsInvalid(body.Error, context);
  const exception = new ReceiptHandleIsInvalid({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryTooManyEntriesInBatchRequestResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryTooManyEntriesInBatchRequest(body.Error, context);
  const exception = new TooManyEntriesInBatchRequest({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var deserializeAws_queryUnsupportedOperationResponse = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = deserializeAws_queryUnsupportedOperation(body.Error, context);
  const exception = new UnsupportedOperation({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var serializeAws_queryActionNameList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var serializeAws_queryAddPermissionRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.Label != null) {
    entries["Label"] = input.Label;
  }
  if (input.AWSAccountIds != null) {
    const memberEntries = serializeAws_queryAWSAccountIdList(input.AWSAccountIds, context);
    if (input.AWSAccountIds?.length === 0) {
      entries.AWSAccountId = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AWSAccountId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Actions != null) {
    const memberEntries = serializeAws_queryActionNameList(input.Actions, context);
    if (input.Actions?.length === 0) {
      entries.ActionName = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ActionName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var serializeAws_queryAttributeNameList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var serializeAws_queryAWSAccountIdList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var serializeAws_queryBinaryList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`BinaryListValue.${counter}`] = context.base64Encoder(entry);
    counter++;
  }
  return entries;
};
var serializeAws_queryChangeMessageVisibilityBatchRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.Entries != null) {
    const memberEntries = serializeAws_queryChangeMessageVisibilityBatchRequestEntryList(input.Entries, context);
    if (input.Entries?.length === 0) {
      entries.ChangeMessageVisibilityBatchRequestEntry = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ChangeMessageVisibilityBatchRequestEntry.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var serializeAws_queryChangeMessageVisibilityBatchRequestEntry = (input, context) => {
  const entries = {};
  if (input.Id != null) {
    entries["Id"] = input.Id;
  }
  if (input.ReceiptHandle != null) {
    entries["ReceiptHandle"] = input.ReceiptHandle;
  }
  if (input.VisibilityTimeout != null) {
    entries["VisibilityTimeout"] = input.VisibilityTimeout;
  }
  return entries;
};
var serializeAws_queryChangeMessageVisibilityBatchRequestEntryList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = serializeAws_queryChangeMessageVisibilityBatchRequestEntry(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var serializeAws_queryChangeMessageVisibilityRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.ReceiptHandle != null) {
    entries["ReceiptHandle"] = input.ReceiptHandle;
  }
  if (input.VisibilityTimeout != null) {
    entries["VisibilityTimeout"] = input.VisibilityTimeout;
  }
  return entries;
};
var serializeAws_queryCreateQueueRequest = (input, context) => {
  const entries = {};
  if (input.QueueName != null) {
    entries["QueueName"] = input.QueueName;
  }
  if (input.tags != null) {
    const memberEntries = serializeAws_queryTagMap(input.tags, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Attributes != null) {
    const memberEntries = serializeAws_queryQueueAttributeMap(input.Attributes, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Attribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var serializeAws_queryDeleteMessageBatchRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.Entries != null) {
    const memberEntries = serializeAws_queryDeleteMessageBatchRequestEntryList(input.Entries, context);
    if (input.Entries?.length === 0) {
      entries.DeleteMessageBatchRequestEntry = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DeleteMessageBatchRequestEntry.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var serializeAws_queryDeleteMessageBatchRequestEntry = (input, context) => {
  const entries = {};
  if (input.Id != null) {
    entries["Id"] = input.Id;
  }
  if (input.ReceiptHandle != null) {
    entries["ReceiptHandle"] = input.ReceiptHandle;
  }
  return entries;
};
var serializeAws_queryDeleteMessageBatchRequestEntryList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = serializeAws_queryDeleteMessageBatchRequestEntry(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var serializeAws_queryDeleteMessageRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.ReceiptHandle != null) {
    entries["ReceiptHandle"] = input.ReceiptHandle;
  }
  return entries;
};
var serializeAws_queryDeleteQueueRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  return entries;
};
var serializeAws_queryGetQueueAttributesRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.AttributeNames != null) {
    const memberEntries = serializeAws_queryAttributeNameList(input.AttributeNames, context);
    if (input.AttributeNames?.length === 0) {
      entries.AttributeName = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AttributeName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var serializeAws_queryGetQueueUrlRequest = (input, context) => {
  const entries = {};
  if (input.QueueName != null) {
    entries["QueueName"] = input.QueueName;
  }
  if (input.QueueOwnerAWSAccountId != null) {
    entries["QueueOwnerAWSAccountId"] = input.QueueOwnerAWSAccountId;
  }
  return entries;
};
var serializeAws_queryListDeadLetterSourceQueuesRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.NextToken != null) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.MaxResults != null) {
    entries["MaxResults"] = input.MaxResults;
  }
  return entries;
};
var serializeAws_queryListQueuesRequest = (input, context) => {
  const entries = {};
  if (input.QueueNamePrefix != null) {
    entries["QueueNamePrefix"] = input.QueueNamePrefix;
  }
  if (input.NextToken != null) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.MaxResults != null) {
    entries["MaxResults"] = input.MaxResults;
  }
  return entries;
};
var serializeAws_queryListQueueTagsRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  return entries;
};
var serializeAws_queryMessageAttributeNameList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var serializeAws_queryMessageAttributeValue = (input, context) => {
  const entries = {};
  if (input.StringValue != null) {
    entries["StringValue"] = input.StringValue;
  }
  if (input.BinaryValue != null) {
    entries["BinaryValue"] = context.base64Encoder(input.BinaryValue);
  }
  if (input.StringListValues != null) {
    const memberEntries = serializeAws_queryStringList(input.StringListValues, context);
    if (input.StringListValues?.length === 0) {
      entries.StringListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `StringListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.BinaryListValues != null) {
    const memberEntries = serializeAws_queryBinaryList(input.BinaryListValues, context);
    if (input.BinaryListValues?.length === 0) {
      entries.BinaryListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BinaryListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DataType != null) {
    entries["DataType"] = input.DataType;
  }
  return entries;
};
var serializeAws_queryMessageBodyAttributeMap = (input, context) => {
  const entries = {};
  let counter = 1;
  Object.keys(input).filter((key) => input[key] != null).forEach((key) => {
    entries[`entry.${counter}.Name`] = key;
    const memberEntries = serializeAws_queryMessageAttributeValue(input[key], context);
    Object.entries(memberEntries).forEach(([key2, value]) => {
      entries[`entry.${counter}.Value.${key2}`] = value;
    });
    counter++;
  });
  return entries;
};
var serializeAws_queryMessageBodySystemAttributeMap = (input, context) => {
  const entries = {};
  let counter = 1;
  Object.keys(input).filter((key) => input[key] != null).forEach((key) => {
    entries[`entry.${counter}.Name`] = key;
    const memberEntries = serializeAws_queryMessageSystemAttributeValue(input[key], context);
    Object.entries(memberEntries).forEach(([key2, value]) => {
      entries[`entry.${counter}.Value.${key2}`] = value;
    });
    counter++;
  });
  return entries;
};
var serializeAws_queryMessageSystemAttributeValue = (input, context) => {
  const entries = {};
  if (input.StringValue != null) {
    entries["StringValue"] = input.StringValue;
  }
  if (input.BinaryValue != null) {
    entries["BinaryValue"] = context.base64Encoder(input.BinaryValue);
  }
  if (input.StringListValues != null) {
    const memberEntries = serializeAws_queryStringList(input.StringListValues, context);
    if (input.StringListValues?.length === 0) {
      entries.StringListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `StringListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.BinaryListValues != null) {
    const memberEntries = serializeAws_queryBinaryList(input.BinaryListValues, context);
    if (input.BinaryListValues?.length === 0) {
      entries.BinaryListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BinaryListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DataType != null) {
    entries["DataType"] = input.DataType;
  }
  return entries;
};
var serializeAws_queryPurgeQueueRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  return entries;
};
var serializeAws_queryQueueAttributeMap = (input, context) => {
  const entries = {};
  let counter = 1;
  Object.keys(input).filter((key) => input[key] != null).forEach((key) => {
    entries[`entry.${counter}.Name`] = key;
    entries[`entry.${counter}.Value`] = input[key];
    counter++;
  });
  return entries;
};
var serializeAws_queryReceiveMessageRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.AttributeNames != null) {
    const memberEntries = serializeAws_queryAttributeNameList(input.AttributeNames, context);
    if (input.AttributeNames?.length === 0) {
      entries.AttributeName = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AttributeName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageAttributeNames != null) {
    const memberEntries = serializeAws_queryMessageAttributeNameList(input.MessageAttributeNames, context);
    if (input.MessageAttributeNames?.length === 0) {
      entries.MessageAttributeName = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageAttributeName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxNumberOfMessages != null) {
    entries["MaxNumberOfMessages"] = input.MaxNumberOfMessages;
  }
  if (input.VisibilityTimeout != null) {
    entries["VisibilityTimeout"] = input.VisibilityTimeout;
  }
  if (input.WaitTimeSeconds != null) {
    entries["WaitTimeSeconds"] = input.WaitTimeSeconds;
  }
  if (input.ReceiveRequestAttemptId != null) {
    entries["ReceiveRequestAttemptId"] = input.ReceiveRequestAttemptId;
  }
  return entries;
};
var serializeAws_queryRemovePermissionRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.Label != null) {
    entries["Label"] = input.Label;
  }
  return entries;
};
var serializeAws_querySendMessageBatchRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.Entries != null) {
    const memberEntries = serializeAws_querySendMessageBatchRequestEntryList(input.Entries, context);
    if (input.Entries?.length === 0) {
      entries.SendMessageBatchRequestEntry = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SendMessageBatchRequestEntry.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var serializeAws_querySendMessageBatchRequestEntry = (input, context) => {
  const entries = {};
  if (input.Id != null) {
    entries["Id"] = input.Id;
  }
  if (input.MessageBody != null) {
    entries["MessageBody"] = input.MessageBody;
  }
  if (input.DelaySeconds != null) {
    entries["DelaySeconds"] = input.DelaySeconds;
  }
  if (input.MessageAttributes != null) {
    const memberEntries = serializeAws_queryMessageBodyAttributeMap(input.MessageAttributes, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageAttribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageSystemAttributes != null) {
    const memberEntries = serializeAws_queryMessageBodySystemAttributeMap(input.MessageSystemAttributes, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageSystemAttribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageDeduplicationId != null) {
    entries["MessageDeduplicationId"] = input.MessageDeduplicationId;
  }
  if (input.MessageGroupId != null) {
    entries["MessageGroupId"] = input.MessageGroupId;
  }
  return entries;
};
var serializeAws_querySendMessageBatchRequestEntryList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = serializeAws_querySendMessageBatchRequestEntry(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var serializeAws_querySendMessageRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.MessageBody != null) {
    entries["MessageBody"] = input.MessageBody;
  }
  if (input.DelaySeconds != null) {
    entries["DelaySeconds"] = input.DelaySeconds;
  }
  if (input.MessageAttributes != null) {
    const memberEntries = serializeAws_queryMessageBodyAttributeMap(input.MessageAttributes, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageAttribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageSystemAttributes != null) {
    const memberEntries = serializeAws_queryMessageBodySystemAttributeMap(input.MessageSystemAttributes, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageSystemAttribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageDeduplicationId != null) {
    entries["MessageDeduplicationId"] = input.MessageDeduplicationId;
  }
  if (input.MessageGroupId != null) {
    entries["MessageGroupId"] = input.MessageGroupId;
  }
  return entries;
};
var serializeAws_querySetQueueAttributesRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.Attributes != null) {
    const memberEntries = serializeAws_queryQueueAttributeMap(input.Attributes, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Attribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var serializeAws_queryStringList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`StringListValue.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var serializeAws_queryTagKeyList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var serializeAws_queryTagMap = (input, context) => {
  const entries = {};
  let counter = 1;
  Object.keys(input).filter((key) => input[key] != null).forEach((key) => {
    entries[`entry.${counter}.Key`] = key;
    entries[`entry.${counter}.Value`] = input[key];
    counter++;
  });
  return entries;
};
var serializeAws_queryTagQueueRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.Tags != null) {
    const memberEntries = serializeAws_queryTagMap(input.Tags, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var serializeAws_queryUntagQueueRequest = (input, context) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.TagKeys != null) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    if (input.TagKeys?.length === 0) {
      entries.TagKey = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagKey.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var deserializeAws_queryBatchEntryIdsNotDistinct = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryBatchRequestTooLong = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryBatchResultErrorEntry = (output, context) => {
  const contents = {
    Id: void 0,
    SenderFault: void 0,
    Code: void 0,
    Message: void 0
  };
  if (output["Id"] !== void 0) {
    contents.Id = expectString(output["Id"]);
  }
  if (output["SenderFault"] !== void 0) {
    contents.SenderFault = parseBoolean(output["SenderFault"]);
  }
  if (output["Code"] !== void 0) {
    contents.Code = expectString(output["Code"]);
  }
  if (output["Message"] !== void 0) {
    contents.Message = expectString(output["Message"]);
  }
  return contents;
};
var deserializeAws_queryBatchResultErrorEntryList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return deserializeAws_queryBatchResultErrorEntry(entry, context);
  });
};
var deserializeAws_queryBinaryList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return context.base64Decoder(entry);
  });
};
var deserializeAws_queryChangeMessageVisibilityBatchResult = (output, context) => {
  const contents = {
    Successful: void 0,
    Failed: void 0
  };
  if (output.ChangeMessageVisibilityBatchResultEntry === "") {
    contents.Successful = [];
  } else if (output["ChangeMessageVisibilityBatchResultEntry"] !== void 0) {
    contents.Successful = deserializeAws_queryChangeMessageVisibilityBatchResultEntryList(getArrayIfSingleItem(output["ChangeMessageVisibilityBatchResultEntry"]), context);
  }
  if (output.BatchResultErrorEntry === "") {
    contents.Failed = [];
  } else if (output["BatchResultErrorEntry"] !== void 0) {
    contents.Failed = deserializeAws_queryBatchResultErrorEntryList(getArrayIfSingleItem(output["BatchResultErrorEntry"]), context);
  }
  return contents;
};
var deserializeAws_queryChangeMessageVisibilityBatchResultEntry = (output, context) => {
  const contents = {
    Id: void 0
  };
  if (output["Id"] !== void 0) {
    contents.Id = expectString(output["Id"]);
  }
  return contents;
};
var deserializeAws_queryChangeMessageVisibilityBatchResultEntryList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return deserializeAws_queryChangeMessageVisibilityBatchResultEntry(entry, context);
  });
};
var deserializeAws_queryCreateQueueResult = (output, context) => {
  const contents = {
    QueueUrl: void 0
  };
  if (output["QueueUrl"] !== void 0) {
    contents.QueueUrl = expectString(output["QueueUrl"]);
  }
  return contents;
};
var deserializeAws_queryDeleteMessageBatchResult = (output, context) => {
  const contents = {
    Successful: void 0,
    Failed: void 0
  };
  if (output.DeleteMessageBatchResultEntry === "") {
    contents.Successful = [];
  } else if (output["DeleteMessageBatchResultEntry"] !== void 0) {
    contents.Successful = deserializeAws_queryDeleteMessageBatchResultEntryList(getArrayIfSingleItem(output["DeleteMessageBatchResultEntry"]), context);
  }
  if (output.BatchResultErrorEntry === "") {
    contents.Failed = [];
  } else if (output["BatchResultErrorEntry"] !== void 0) {
    contents.Failed = deserializeAws_queryBatchResultErrorEntryList(getArrayIfSingleItem(output["BatchResultErrorEntry"]), context);
  }
  return contents;
};
var deserializeAws_queryDeleteMessageBatchResultEntry = (output, context) => {
  const contents = {
    Id: void 0
  };
  if (output["Id"] !== void 0) {
    contents.Id = expectString(output["Id"]);
  }
  return contents;
};
var deserializeAws_queryDeleteMessageBatchResultEntryList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return deserializeAws_queryDeleteMessageBatchResultEntry(entry, context);
  });
};
var deserializeAws_queryEmptyBatchRequest = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryGetQueueAttributesResult = (output, context) => {
  const contents = {
    Attributes: void 0
  };
  if (output.Attribute === "") {
    contents.Attributes = {};
  } else if (output["Attribute"] !== void 0) {
    contents.Attributes = deserializeAws_queryQueueAttributeMap(getArrayIfSingleItem(output["Attribute"]), context);
  }
  return contents;
};
var deserializeAws_queryGetQueueUrlResult = (output, context) => {
  const contents = {
    QueueUrl: void 0
  };
  if (output["QueueUrl"] !== void 0) {
    contents.QueueUrl = expectString(output["QueueUrl"]);
  }
  return contents;
};
var deserializeAws_queryInvalidAttributeName = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryInvalidBatchEntryId = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryInvalidIdFormat = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryInvalidMessageContents = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryListDeadLetterSourceQueuesResult = (output, context) => {
  const contents = {
    queueUrls: void 0,
    NextToken: void 0
  };
  if (output.QueueUrl === "") {
    contents.queueUrls = [];
  } else if (output["QueueUrl"] !== void 0) {
    contents.queueUrls = deserializeAws_queryQueueUrlList(getArrayIfSingleItem(output["QueueUrl"]), context);
  }
  if (output["NextToken"] !== void 0) {
    contents.NextToken = expectString(output["NextToken"]);
  }
  return contents;
};
var deserializeAws_queryListQueuesResult = (output, context) => {
  const contents = {
    NextToken: void 0,
    QueueUrls: void 0
  };
  if (output["NextToken"] !== void 0) {
    contents.NextToken = expectString(output["NextToken"]);
  }
  if (output.QueueUrl === "") {
    contents.QueueUrls = [];
  } else if (output["QueueUrl"] !== void 0) {
    contents.QueueUrls = deserializeAws_queryQueueUrlList(getArrayIfSingleItem(output["QueueUrl"]), context);
  }
  return contents;
};
var deserializeAws_queryListQueueTagsResult = (output, context) => {
  const contents = {
    Tags: void 0
  };
  if (output.Tag === "") {
    contents.Tags = {};
  } else if (output["Tag"] !== void 0) {
    contents.Tags = deserializeAws_queryTagMap(getArrayIfSingleItem(output["Tag"]), context);
  }
  return contents;
};
var deserializeAws_queryMessage = (output, context) => {
  const contents = {
    MessageId: void 0,
    ReceiptHandle: void 0,
    MD5OfBody: void 0,
    Body: void 0,
    Attributes: void 0,
    MD5OfMessageAttributes: void 0,
    MessageAttributes: void 0
  };
  if (output["MessageId"] !== void 0) {
    contents.MessageId = expectString(output["MessageId"]);
  }
  if (output["ReceiptHandle"] !== void 0) {
    contents.ReceiptHandle = expectString(output["ReceiptHandle"]);
  }
  if (output["MD5OfBody"] !== void 0) {
    contents.MD5OfBody = expectString(output["MD5OfBody"]);
  }
  if (output["Body"] !== void 0) {
    contents.Body = expectString(output["Body"]);
  }
  if (output.Attribute === "") {
    contents.Attributes = {};
  } else if (output["Attribute"] !== void 0) {
    contents.Attributes = deserializeAws_queryMessageSystemAttributeMap(getArrayIfSingleItem(output["Attribute"]), context);
  }
  if (output["MD5OfMessageAttributes"] !== void 0) {
    contents.MD5OfMessageAttributes = expectString(output["MD5OfMessageAttributes"]);
  }
  if (output.MessageAttribute === "") {
    contents.MessageAttributes = {};
  } else if (output["MessageAttribute"] !== void 0) {
    contents.MessageAttributes = deserializeAws_queryMessageBodyAttributeMap(getArrayIfSingleItem(output["MessageAttribute"]), context);
  }
  return contents;
};
var deserializeAws_queryMessageAttributeValue = (output, context) => {
  const contents = {
    StringValue: void 0,
    BinaryValue: void 0,
    StringListValues: void 0,
    BinaryListValues: void 0,
    DataType: void 0
  };
  if (output["StringValue"] !== void 0) {
    contents.StringValue = expectString(output["StringValue"]);
  }
  if (output["BinaryValue"] !== void 0) {
    contents.BinaryValue = context.base64Decoder(output["BinaryValue"]);
  }
  if (output.StringListValue === "") {
    contents.StringListValues = [];
  } else if (output["StringListValue"] !== void 0) {
    contents.StringListValues = deserializeAws_queryStringList(getArrayIfSingleItem(output["StringListValue"]), context);
  }
  if (output.BinaryListValue === "") {
    contents.BinaryListValues = [];
  } else if (output["BinaryListValue"] !== void 0) {
    contents.BinaryListValues = deserializeAws_queryBinaryList(getArrayIfSingleItem(output["BinaryListValue"]), context);
  }
  if (output["DataType"] !== void 0) {
    contents.DataType = expectString(output["DataType"]);
  }
  return contents;
};
var deserializeAws_queryMessageBodyAttributeMap = (output, context) => {
  return output.reduce((acc, pair) => {
    if (pair["Value"] === null) {
      return acc;
    }
    acc[pair["Name"]] = deserializeAws_queryMessageAttributeValue(pair["Value"], context);
    return acc;
  }, {});
};
var deserializeAws_queryMessageList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return deserializeAws_queryMessage(entry, context);
  });
};
var deserializeAws_queryMessageNotInflight = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryMessageSystemAttributeMap = (output, context) => {
  return output.reduce((acc, pair) => {
    if (pair["Value"] === null) {
      return acc;
    }
    acc[pair["Name"]] = expectString(pair["Value"]);
    return acc;
  }, {});
};
var deserializeAws_queryOverLimit = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryPurgeQueueInProgress = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryQueueAttributeMap = (output, context) => {
  return output.reduce((acc, pair) => {
    if (pair["Value"] === null) {
      return acc;
    }
    acc[pair["Name"]] = expectString(pair["Value"]);
    return acc;
  }, {});
};
var deserializeAws_queryQueueDeletedRecently = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryQueueDoesNotExist = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryQueueNameExists = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryQueueUrlList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return expectString(entry);
  });
};
var deserializeAws_queryReceiptHandleIsInvalid = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryReceiveMessageResult = (output, context) => {
  const contents = {
    Messages: void 0
  };
  if (output.Message === "") {
    contents.Messages = [];
  } else if (output["Message"] !== void 0) {
    contents.Messages = deserializeAws_queryMessageList(getArrayIfSingleItem(output["Message"]), context);
  }
  return contents;
};
var deserializeAws_querySendMessageBatchResult = (output, context) => {
  const contents = {
    Successful: void 0,
    Failed: void 0
  };
  if (output.SendMessageBatchResultEntry === "") {
    contents.Successful = [];
  } else if (output["SendMessageBatchResultEntry"] !== void 0) {
    contents.Successful = deserializeAws_querySendMessageBatchResultEntryList(getArrayIfSingleItem(output["SendMessageBatchResultEntry"]), context);
  }
  if (output.BatchResultErrorEntry === "") {
    contents.Failed = [];
  } else if (output["BatchResultErrorEntry"] !== void 0) {
    contents.Failed = deserializeAws_queryBatchResultErrorEntryList(getArrayIfSingleItem(output["BatchResultErrorEntry"]), context);
  }
  return contents;
};
var deserializeAws_querySendMessageBatchResultEntry = (output, context) => {
  const contents = {
    Id: void 0,
    MessageId: void 0,
    MD5OfMessageBody: void 0,
    MD5OfMessageAttributes: void 0,
    MD5OfMessageSystemAttributes: void 0,
    SequenceNumber: void 0
  };
  if (output["Id"] !== void 0) {
    contents.Id = expectString(output["Id"]);
  }
  if (output["MessageId"] !== void 0) {
    contents.MessageId = expectString(output["MessageId"]);
  }
  if (output["MD5OfMessageBody"] !== void 0) {
    contents.MD5OfMessageBody = expectString(output["MD5OfMessageBody"]);
  }
  if (output["MD5OfMessageAttributes"] !== void 0) {
    contents.MD5OfMessageAttributes = expectString(output["MD5OfMessageAttributes"]);
  }
  if (output["MD5OfMessageSystemAttributes"] !== void 0) {
    contents.MD5OfMessageSystemAttributes = expectString(output["MD5OfMessageSystemAttributes"]);
  }
  if (output["SequenceNumber"] !== void 0) {
    contents.SequenceNumber = expectString(output["SequenceNumber"]);
  }
  return contents;
};
var deserializeAws_querySendMessageBatchResultEntryList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return deserializeAws_querySendMessageBatchResultEntry(entry, context);
  });
};
var deserializeAws_querySendMessageResult = (output, context) => {
  const contents = {
    MD5OfMessageBody: void 0,
    MD5OfMessageAttributes: void 0,
    MD5OfMessageSystemAttributes: void 0,
    MessageId: void 0,
    SequenceNumber: void 0
  };
  if (output["MD5OfMessageBody"] !== void 0) {
    contents.MD5OfMessageBody = expectString(output["MD5OfMessageBody"]);
  }
  if (output["MD5OfMessageAttributes"] !== void 0) {
    contents.MD5OfMessageAttributes = expectString(output["MD5OfMessageAttributes"]);
  }
  if (output["MD5OfMessageSystemAttributes"] !== void 0) {
    contents.MD5OfMessageSystemAttributes = expectString(output["MD5OfMessageSystemAttributes"]);
  }
  if (output["MessageId"] !== void 0) {
    contents.MessageId = expectString(output["MessageId"]);
  }
  if (output["SequenceNumber"] !== void 0) {
    contents.SequenceNumber = expectString(output["SequenceNumber"]);
  }
  return contents;
};
var deserializeAws_queryStringList = (output, context) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return expectString(entry);
  });
};
var deserializeAws_queryTagMap = (output, context) => {
  return output.reduce((acc, pair) => {
    if (pair["Value"] === null) {
      return acc;
    }
    acc[pair["Key"]] = expectString(pair["Value"]);
    return acc;
  }, {});
};
var deserializeAws_queryTooManyEntriesInBatchRequest = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeAws_queryUnsupportedOperation = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeMetadata6 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBody5 = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString5 = (streamBody, context) => collectBody5(streamBody, context).then((body) => context.utf8Encoder(body));
var buildHttpRpcRequest3 = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
};
var parseBody5 = (streamBody, context) => collectBodyString5(streamBody, context).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser2.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    const parsedObj = parser.parse(encoded);
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode(parsedObjToReturn);
  }
  return {};
});
var parseErrorBody5 = async (errorBody, context) => {
  const value = await parseBody5(errorBody, context);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
};
var buildFormUrlencodedString2 = (formEntries) => Object.entries(formEntries).map(([key, value]) => extendedEncodeURIComponent(key) + "=" + extendedEncodeURIComponent(value)).join("&");
var loadQueryErrorCode2 = (output, data) => {
  if (data.Error?.Code !== void 0) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/AddPermissionCommand.js
var AddPermissionCommand = class _AddPermissionCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _AddPermissionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "AddPermissionCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: AddPermissionRequestFilterSensitiveLog,
      outputFilterSensitiveLog: (output) => output
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryAddPermissionCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryAddPermissionCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/ChangeMessageVisibilityBatchCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var ChangeMessageVisibilityBatchCommand = class _ChangeMessageVisibilityBatchCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _ChangeMessageVisibilityBatchCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "ChangeMessageVisibilityBatchCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: ChangeMessageVisibilityBatchRequestFilterSensitiveLog,
      outputFilterSensitiveLog: ChangeMessageVisibilityBatchResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryChangeMessageVisibilityBatchCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryChangeMessageVisibilityBatchCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/ChangeMessageVisibilityCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var ChangeMessageVisibilityCommand = class _ChangeMessageVisibilityCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _ChangeMessageVisibilityCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "ChangeMessageVisibilityCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: ChangeMessageVisibilityRequestFilterSensitiveLog,
      outputFilterSensitiveLog: (output) => output
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryChangeMessageVisibilityCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryChangeMessageVisibilityCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/CreateQueueCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var CreateQueueCommand = class _CreateQueueCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _CreateQueueCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "CreateQueueCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: CreateQueueRequestFilterSensitiveLog,
      outputFilterSensitiveLog: CreateQueueResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryCreateQueueCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryCreateQueueCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/DeleteMessageBatchCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var DeleteMessageBatchCommand = class _DeleteMessageBatchCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _DeleteMessageBatchCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "DeleteMessageBatchCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: DeleteMessageBatchRequestFilterSensitiveLog,
      outputFilterSensitiveLog: DeleteMessageBatchResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryDeleteMessageBatchCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryDeleteMessageBatchCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/DeleteMessageCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var DeleteMessageCommand = class _DeleteMessageCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _DeleteMessageCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "DeleteMessageCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: DeleteMessageRequestFilterSensitiveLog,
      outputFilterSensitiveLog: (output) => output
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryDeleteMessageCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryDeleteMessageCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/DeleteQueueCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var DeleteQueueCommand = class _DeleteQueueCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _DeleteQueueCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "DeleteQueueCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: DeleteQueueRequestFilterSensitiveLog,
      outputFilterSensitiveLog: (output) => output
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryDeleteQueueCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryDeleteQueueCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/GetQueueAttributesCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var GetQueueAttributesCommand = class _GetQueueAttributesCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _GetQueueAttributesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "GetQueueAttributesCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetQueueAttributesRequestFilterSensitiveLog,
      outputFilterSensitiveLog: GetQueueAttributesResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryGetQueueAttributesCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryGetQueueAttributesCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/GetQueueUrlCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var GetQueueUrlCommand = class _GetQueueUrlCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _GetQueueUrlCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "GetQueueUrlCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetQueueUrlRequestFilterSensitiveLog,
      outputFilterSensitiveLog: GetQueueUrlResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryGetQueueUrlCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryGetQueueUrlCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/ListDeadLetterSourceQueuesCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var ListDeadLetterSourceQueuesCommand = class _ListDeadLetterSourceQueuesCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _ListDeadLetterSourceQueuesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "ListDeadLetterSourceQueuesCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: ListDeadLetterSourceQueuesRequestFilterSensitiveLog,
      outputFilterSensitiveLog: ListDeadLetterSourceQueuesResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryListDeadLetterSourceQueuesCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryListDeadLetterSourceQueuesCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/ListQueuesCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var ListQueuesCommand = class _ListQueuesCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _ListQueuesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "ListQueuesCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: ListQueuesRequestFilterSensitiveLog,
      outputFilterSensitiveLog: ListQueuesResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryListQueuesCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryListQueuesCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/ListQueueTagsCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var ListQueueTagsCommand = class _ListQueueTagsCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _ListQueueTagsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "ListQueueTagsCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: ListQueueTagsRequestFilterSensitiveLog,
      outputFilterSensitiveLog: ListQueueTagsResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryListQueueTagsCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryListQueueTagsCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/PurgeQueueCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var PurgeQueueCommand = class _PurgeQueueCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _PurgeQueueCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "PurgeQueueCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: PurgeQueueRequestFilterSensitiveLog,
      outputFilterSensitiveLog: (output) => output
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryPurgeQueueCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryPurgeQueueCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/ReceiveMessageCommand.js
init_dist_es9();

// ../../node_modules/@aws-sdk/middleware-sdk-sqs/dist-es/receive-message.js
init_dist_es17();
init_dist_es20();
function receiveMessageMiddleware(options) {
  return (next) => async (args) => {
    const resp = await next({ ...args });
    const output = resp.output;
    const messageIds = [];
    if (output.Messages !== void 0) {
      for (const message of output.Messages) {
        const md5 = message.MD5OfBody;
        const hash2 = new options.md5();
        hash2.update(toUint8Array(message.Body || ""));
        if (md5 !== toHex(await hash2.digest())) {
          messageIds.push(message.MessageId);
        }
      }
    }
    if (messageIds.length > 0) {
      throw new Error("Invalid MD5 checksum on messages: " + messageIds.join(", "));
    }
    return resp;
  };
}
var receiveMessageMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BODY_MD5"],
  name: "receiveMessageMiddleware",
  override: true
};
var getReceiveMessagePlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(receiveMessageMiddleware(config), receiveMessageMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-sdk-sqs/dist-es/send-message.js
init_dist_es17();
init_dist_es20();
var sendMessageMiddleware = (options) => (next) => async (args) => {
  const resp = await next({ ...args });
  const output = resp.output;
  const hash2 = new options.md5();
  hash2.update(toUint8Array(args.input.MessageBody || ""));
  if (output.MD5OfMessageBody !== toHex(await hash2.digest())) {
    throw new Error("InvalidChecksumError");
  }
  return resp;
};
var sendMessageMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BODY_MD5"],
  name: "sendMessageMiddleware",
  override: true
};
var getSendMessagePlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(sendMessageMiddleware(config), sendMessageMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-sdk-sqs/dist-es/send-message-batch.js
init_dist_es17();
init_dist_es20();
var sendMessageBatchMiddleware = (options) => (next) => async (args) => {
  const resp = await next({ ...args });
  const output = resp.output;
  const messageIds = [];
  const entries = {};
  if (output.Successful !== void 0) {
    for (const entry of output.Successful) {
      if (entry.Id !== void 0) {
        entries[entry.Id] = entry;
      }
    }
  }
  for (const entry of args.input.Entries) {
    if (entries[entry.Id]) {
      const md5 = entries[entry.Id].MD5OfMessageBody;
      const hash2 = new options.md5();
      hash2.update(toUint8Array(entry.MessageBody || ""));
      if (md5 !== toHex(await hash2.digest())) {
        messageIds.push(entries[entry.Id].MessageId);
      }
    }
  }
  if (messageIds.length > 0) {
    throw new Error("Invalid MD5 checksum on messages: " + messageIds.join(", "));
  }
  return resp;
};
var sendMessageBatchMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BODY_MD5"],
  name: "sendMessageBatchMiddleware",
  override: true
};
var getSendMessageBatchPlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(sendMessageBatchMiddleware(config), sendMessageBatchMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/ReceiveMessageCommand.js
init_dist_es8();
init_dist_es26();
var ReceiveMessageCommand = class _ReceiveMessageCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _ReceiveMessageCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getReceiveMessagePlugin(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "ReceiveMessageCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: ReceiveMessageRequestFilterSensitiveLog,
      outputFilterSensitiveLog: ReceiveMessageResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryReceiveMessageCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryReceiveMessageCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/RemovePermissionCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var RemovePermissionCommand = class _RemovePermissionCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _RemovePermissionCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "RemovePermissionCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: RemovePermissionRequestFilterSensitiveLog,
      outputFilterSensitiveLog: (output) => output
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryRemovePermissionCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryRemovePermissionCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/SendMessageBatchCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var SendMessageBatchCommand = class _SendMessageBatchCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _SendMessageBatchCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getSendMessageBatchPlugin(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "SendMessageBatchCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: SendMessageBatchRequestFilterSensitiveLog,
      outputFilterSensitiveLog: SendMessageBatchResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_querySendMessageBatchCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_querySendMessageBatchCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/SendMessageCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var SendMessageCommand = class _SendMessageCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _SendMessageCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getSendMessagePlugin(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "SendMessageCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: SendMessageRequestFilterSensitiveLog,
      outputFilterSensitiveLog: SendMessageResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_querySendMessageCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_querySendMessageCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/SetQueueAttributesCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var SetQueueAttributesCommand = class _SetQueueAttributesCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _SetQueueAttributesCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "SetQueueAttributesCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: SetQueueAttributesRequestFilterSensitiveLog,
      outputFilterSensitiveLog: (output) => output
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_querySetQueueAttributesCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_querySetQueueAttributesCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/TagQueueCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var TagQueueCommand = class _TagQueueCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _TagQueueCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "TagQueueCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: TagQueueRequestFilterSensitiveLog,
      outputFilterSensitiveLog: (output) => output
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryTagQueueCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryTagQueueCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/UntagQueueCommand.js
init_dist_es9();
init_dist_es8();
init_dist_es26();
var UntagQueueCommand = class _UntagQueueCommand extends Command {
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _UntagQueueCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SQSClient";
    const commandName = "UntagQueueCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: UntagQueueRequestFilterSensitiveLog,
      outputFilterSensitiveLog: (output) => output
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return serializeAws_queryUntagQueueCommand(input, context);
  }
  deserialize(output, context) {
    return deserializeAws_queryUntagQueueCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/SQSClient.js
init_dist_es3();
init_dist_es5();
init_dist_es9();
init_dist_es10();
init_dist_es11();
init_dist_es12();
init_dist_es15();
init_dist_es23();
init_dist_es24();
init_dist_es26();

// ../../node_modules/@aws-sdk/client-sqs/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters5 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "sqs"
  };
};

// ../../node_modules/@aws-sdk/client-sqs/package.json
var package_default5 = {
  name: "@aws-sdk/client-sqs",
  description: "AWS SDK for JavaScript Sqs Client for Node.js, Browser and React Native",
  version: "3.272.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sqs"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.272.0",
    "@aws-sdk/config-resolver": "3.272.0",
    "@aws-sdk/credential-provider-node": "3.272.0",
    "@aws-sdk/fetch-http-handler": "3.272.0",
    "@aws-sdk/hash-node": "3.272.0",
    "@aws-sdk/invalid-dependency": "3.272.0",
    "@aws-sdk/md5-js": "3.272.0",
    "@aws-sdk/middleware-content-length": "3.272.0",
    "@aws-sdk/middleware-endpoint": "3.272.0",
    "@aws-sdk/middleware-host-header": "3.272.0",
    "@aws-sdk/middleware-logger": "3.272.0",
    "@aws-sdk/middleware-recursion-detection": "3.272.0",
    "@aws-sdk/middleware-retry": "3.272.0",
    "@aws-sdk/middleware-sdk-sqs": "3.272.0",
    "@aws-sdk/middleware-serde": "3.272.0",
    "@aws-sdk/middleware-signing": "3.272.0",
    "@aws-sdk/middleware-stack": "3.272.0",
    "@aws-sdk/middleware-user-agent": "3.272.0",
    "@aws-sdk/node-config-provider": "3.272.0",
    "@aws-sdk/node-http-handler": "3.272.0",
    "@aws-sdk/protocol-http": "3.272.0",
    "@aws-sdk/smithy-client": "3.272.0",
    "@aws-sdk/types": "3.272.0",
    "@aws-sdk/url-parser": "3.272.0",
    "@aws-sdk/util-base64": "3.208.0",
    "@aws-sdk/util-body-length-browser": "3.188.0",
    "@aws-sdk/util-body-length-node": "3.208.0",
    "@aws-sdk/util-defaults-mode-browser": "3.272.0",
    "@aws-sdk/util-defaults-mode-node": "3.272.0",
    "@aws-sdk/util-endpoints": "3.272.0",
    "@aws-sdk/util-retry": "3.272.0",
    "@aws-sdk/util-user-agent-browser": "3.272.0",
    "@aws-sdk/util-user-agent-node": "3.272.0",
    "@aws-sdk/util-utf8": "3.254.0",
    "fast-xml-parser": "4.0.11",
    tslib: "^2.3.1"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.208.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.19.2",
    typescript: "~4.6.2"
  },
  overrides: {
    typedoc: {
      typescript: "~4.6.2"
    }
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sqs",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sqs"
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/runtimeConfig.js
init_dist_es49();
init_dist_es3();
init_dist_es48();
init_dist_es33();
init_dist_es15();
init_dist_es30();
init_dist_es35();
init_dist_es36();
init_dist_es14();
init_dist_es37();

// ../../node_modules/@aws-sdk/client-sqs/dist-es/runtimeConfig.shared.js
init_dist_es26();
init_dist_es7();
init_dist_es38();
init_dist_es20();

// ../../node_modules/@aws-sdk/client-sqs/dist-es/endpoint/endpointResolver.js
init_dist_es40();

// ../../node_modules/@aws-sdk/client-sqs/dist-es/endpoint/ruleset.js
var s5 = "required";
var t2 = "fn";
var u2 = "argv";
var v2 = "ref";
var a5 = "PartitionResult";
var b5 = "tree";
var c5 = "error";
var d5 = "endpoint";
var e5 = "getAttr";
var f5 = { [s5]: false, "type": "String" };
var g5 = { [s5]: true, "default": false, "type": "Boolean" };
var h5 = { [v2]: "Endpoint" };
var i5 = { [t2]: "booleanEquals", [u2]: [{ [v2]: "UseFIPS" }, true] };
var j5 = { [t2]: "booleanEquals", [u2]: [{ [v2]: "UseDualStack" }, true] };
var k5 = {};
var l5 = { [t2]: "booleanEquals", [u2]: [true, { [t2]: e5, [u2]: [{ [v2]: a5 }, "supportsFIPS"] }] };
var m5 = { [v2]: a5 };
var n5 = { [t2]: "booleanEquals", [u2]: [true, { [t2]: e5, [u2]: [m5, "supportsDualStack"] }] };
var o5 = { "url": "https://sqs.{Region}.{PartitionResult#dnsSuffix}", "properties": {}, "headers": {} };
var p5 = [h5];
var q5 = [i5];
var r5 = [j5];
var _data5 = { version: "1.0", parameters: { Region: f5, UseDualStack: g5, UseFIPS: g5, Endpoint: f5 }, rules: [{ conditions: [{ [t2]: "aws.partition", [u2]: [{ [v2]: "Region" }], assign: a5 }], type: b5, rules: [{ conditions: [{ [t2]: "isSet", [u2]: p5 }, { [t2]: "parseURL", [u2]: p5, assign: "url" }], type: b5, rules: [{ conditions: q5, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c5 }, { type: b5, rules: [{ conditions: r5, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c5 }, { endpoint: { url: h5, properties: k5, headers: k5 }, type: d5 }] }] }, { conditions: [i5, j5], type: b5, rules: [{ conditions: [l5, n5], type: b5, rules: [{ endpoint: { url: "https://sqs-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: k5, headers: k5 }, type: d5 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c5 }] }, { conditions: q5, type: b5, rules: [{ conditions: [l5], type: b5, rules: [{ type: b5, rules: [{ conditions: [{ [t2]: "stringEquals", [u2]: ["aws-us-gov", { [t2]: e5, [u2]: [m5, "name"] }] }], endpoint: o5, type: d5 }, { endpoint: { url: "https://sqs-fips.{Region}.{PartitionResult#dnsSuffix}", properties: k5, headers: k5 }, type: d5 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c5 }] }, { conditions: r5, type: b5, rules: [{ conditions: [n5], type: b5, rules: [{ endpoint: { url: "https://sqs.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: k5, headers: k5 }, type: d5 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c5 }] }, { endpoint: o5, type: d5 }] }] };
var ruleSet5 = _data5;

// ../../node_modules/@aws-sdk/client-sqs/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver5 = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet5, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/runtimeConfig.shared.js
var getRuntimeConfig9 = (config) => ({
  apiVersion: "2012-11-05",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver5,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "SQS",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf8,
  utf8Encoder: config?.utf8Encoder ?? toUtf8
});

// ../../node_modules/@aws-sdk/client-sqs/dist-es/runtimeConfig.js
init_dist_es26();
init_dist_es41();
init_dist_es26();
var getRuntimeConfig10 = (config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig9(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider2(defaultProvider),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default5.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    md5: config?.md5 ?? Hash.bind(null, "md5"),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/SQSClient.js
var SQSClient = class extends Client {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig10(configuration);
    const _config_1 = resolveClientEndpointParameters5(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveAwsAuthConfig(_config_5);
    const _config_7 = resolveUserAgentConfig(_config_6);
    super(_config_7);
    this.config = _config_7;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getAwsAuthPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/SQS.js
var SQS = class extends SQSClient {
  addPermission(args, optionsOrCb, cb) {
    const command = new AddPermissionCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  changeMessageVisibility(args, optionsOrCb, cb) {
    const command = new ChangeMessageVisibilityCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  changeMessageVisibilityBatch(args, optionsOrCb, cb) {
    const command = new ChangeMessageVisibilityBatchCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  createQueue(args, optionsOrCb, cb) {
    const command = new CreateQueueCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  deleteMessage(args, optionsOrCb, cb) {
    const command = new DeleteMessageCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  deleteMessageBatch(args, optionsOrCb, cb) {
    const command = new DeleteMessageBatchCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  deleteQueue(args, optionsOrCb, cb) {
    const command = new DeleteQueueCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  getQueueAttributes(args, optionsOrCb, cb) {
    const command = new GetQueueAttributesCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  getQueueUrl(args, optionsOrCb, cb) {
    const command = new GetQueueUrlCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  listDeadLetterSourceQueues(args, optionsOrCb, cb) {
    const command = new ListDeadLetterSourceQueuesCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  listQueues(args, optionsOrCb, cb) {
    const command = new ListQueuesCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  listQueueTags(args, optionsOrCb, cb) {
    const command = new ListQueueTagsCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  purgeQueue(args, optionsOrCb, cb) {
    const command = new PurgeQueueCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  receiveMessage(args, optionsOrCb, cb) {
    const command = new ReceiveMessageCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  removePermission(args, optionsOrCb, cb) {
    const command = new RemovePermissionCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  sendMessage(args, optionsOrCb, cb) {
    const command = new SendMessageCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  sendMessageBatch(args, optionsOrCb, cb) {
    const command = new SendMessageBatchCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  setQueueAttributes(args, optionsOrCb, cb) {
    const command = new SetQueueAttributesCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  tagQueue(args, optionsOrCb, cb) {
    const command = new TagQueueCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
  untagQueue(args, optionsOrCb, cb) {
    const command = new UntagQueueCommand(args);
    if (typeof optionsOrCb === "function") {
      this.send(command, optionsOrCb);
    } else if (typeof cb === "function") {
      if (typeof optionsOrCb !== "object")
        throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
      this.send(command, optionsOrCb || {}, cb);
    } else {
      return this.send(command, optionsOrCb);
    }
  }
};

// ../../node_modules/ulid/dist/index.esm.js
function createError(message) {
  var err = new Error(message);
  err.source = "ulid";
  return err;
}
var ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
var ENCODING_LEN = ENCODING.length;
var TIME_MAX = Math.pow(2, 48) - 1;
var TIME_LEN = 10;
var RANDOM_LEN = 16;
function randomChar(prng) {
  var rand = Math.floor(prng() * ENCODING_LEN);
  if (rand === ENCODING_LEN) {
    rand = ENCODING_LEN - 1;
  }
  return ENCODING.charAt(rand);
}
function encodeTime(now, len) {
  if (isNaN(now)) {
    throw new Error(now + " must be a number");
  }
  if (now > TIME_MAX) {
    throw createError("cannot encode time greater than " + TIME_MAX);
  }
  if (now < 0) {
    throw createError("time must be positive");
  }
  if (Number.isInteger(now) === false) {
    throw createError("time must be an integer");
  }
  var mod = void 0;
  var str = "";
  for (; len > 0; len--) {
    mod = now % ENCODING_LEN;
    str = ENCODING.charAt(mod) + str;
    now = (now - mod) / ENCODING_LEN;
  }
  return str;
}
function encodeRandom(len, prng) {
  var str = "";
  for (; len > 0; len--) {
    str = randomChar(prng) + str;
  }
  return str;
}
function detectPrng() {
  var allowInsecure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var root = arguments[1];
  if (!root) {
    root = typeof window !== "undefined" ? window : null;
  }
  var browserCrypto = root && (root.crypto || root.msCrypto);
  if (browserCrypto) {
    return function() {
      var buffer = new Uint8Array(1);
      browserCrypto.getRandomValues(buffer);
      return buffer[0] / 255;
    };
  } else {
    try {
      var nodeCrypto = require("crypto");
      return function() {
        return nodeCrypto.randomBytes(1).readUInt8() / 255;
      };
    } catch (e10) {
    }
  }
  if (allowInsecure) {
    try {
      console.error("secure crypto unusable, falling back to insecure Math.random()!");
    } catch (e10) {
    }
    return function() {
      return Math.random();
    };
  }
  throw createError("secure crypto unusable, insecure Math.random not allowed");
}
function factory(currPrng) {
  if (!currPrng) {
    currPrng = detectPrng();
  }
  return function ulid2(seedTime) {
    if (isNaN(seedTime)) {
      seedTime = Date.now();
    }
    return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);
  };
}
var ulid = factory();

// ../../node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/configurations.js
var ENV_ENDPOINT_DISCOVERY = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"];
var CONFIG_ENDPOINT_DISCOVERY = "endpoint_discovery_enabled";
var isFalsy = (value) => ["false", "0"].indexOf(value) >= 0;
var NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => {
    for (let i10 = 0; i10 < ENV_ENDPOINT_DISCOVERY.length; i10++) {
      const envKey = ENV_ENDPOINT_DISCOVERY[i10];
      if (envKey in env3) {
        const value = env3[envKey];
        if (value === "") {
          throw Error(`Environment variable ${envKey} can't be empty of undefined, got "${value}"`);
        }
        return !isFalsy(value);
      }
    }
  },
  configFileSelector: (profile) => {
    if (CONFIG_ENDPOINT_DISCOVERY in profile) {
      const value = profile[CONFIG_ENDPOINT_DISCOVERY];
      if (value === void 0) {
        throw Error(`Shared config entry ${CONFIG_ENDPOINT_DISCOVERY} can't be undefined, got "${value}"`);
      }
      return !isFalsy(value);
    }
  },
  default: void 0
};

// ../../node_modules/@smithy/types/dist-es/auth.js
var HttpAuthLocation2;
(function(HttpAuthLocation4) {
  HttpAuthLocation4["HEADER"] = "header";
  HttpAuthLocation4["QUERY"] = "query";
})(HttpAuthLocation2 || (HttpAuthLocation2 = {}));

// ../../node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme2;
(function(EndpointURLScheme4) {
  EndpointURLScheme4["HTTP"] = "http";
  EndpointURLScheme4["HTTPS"] = "https";
})(EndpointURLScheme2 || (EndpointURLScheme2 = {}));

// ../../node_modules/@smithy/types/dist-es/http.js
var FieldPosition2;
(function(FieldPosition3) {
  FieldPosition3[FieldPosition3["HEADER"] = 0] = "HEADER";
  FieldPosition3[FieldPosition3["TRAILER"] = 1] = "TRAILER";
})(FieldPosition2 || (FieldPosition2 = {}));

// ../../node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function(RequestHandlerProtocol3) {
  RequestHandlerProtocol3["HTTP_0_9"] = "http/0.9";
  RequestHandlerProtocol3["HTTP_1_0"] = "http/1.0";
  RequestHandlerProtocol3["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

// ../../node_modules/@smithy/protocol-http/dist-es/httpRequest.js
var HttpRequest2 = class _HttpRequest {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
    this.username = options.username;
    this.password = options.password;
    this.fragment = options.fragment;
  }
  static isInstance(request3) {
    if (!request3)
      return false;
    const req = request3;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    const cloned = new _HttpRequest({
      ...this,
      headers: { ...this.headers }
    });
    if (cloned.query)
      cloned.query = cloneQuery3(cloned.query);
    return cloned;
  }
};
function cloneQuery3(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}

// ../../node_modules/@smithy/protocol-http/dist-es/httpResponse.js
var HttpResponse2 = class {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.reason = options.reason;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
};

// ../../node_modules/@aws-sdk/endpoint-cache/dist-es/EndpointCache.js
var import_lru_cache = __toESM(require_lru_cache());
var EndpointCache = class {
  constructor(capacity) {
    this.cache = new import_lru_cache.default(capacity);
  }
  getEndpoint(key) {
    const endpointsWithExpiry = this.get(key);
    if (!endpointsWithExpiry || endpointsWithExpiry.length === 0) {
      return void 0;
    }
    const endpoints = endpointsWithExpiry.map((endpoint) => endpoint.Address);
    return endpoints[Math.floor(Math.random() * endpoints.length)];
  }
  get(key) {
    if (!this.has(key)) {
      return;
    }
    const value = this.cache.get(key);
    if (!value) {
      return;
    }
    const now = Date.now();
    const endpointsWithExpiry = value.filter((endpoint) => now < endpoint.Expires);
    if (endpointsWithExpiry.length === 0) {
      this.delete(key);
      return void 0;
    }
    return endpointsWithExpiry;
  }
  set(key, endpoints) {
    const now = Date.now();
    this.cache.set(key, endpoints.map(({ Address, CachePeriodInMinutes }) => ({
      Address,
      Expires: now + CachePeriodInMinutes * 60 * 1e3
    })));
  }
  delete(key) {
    this.cache.set(key, []);
  }
  has(key) {
    if (!this.cache.has(key)) {
      return false;
    }
    const endpoints = this.cache.peek(key);
    if (!endpoints) {
      return false;
    }
    return endpoints.length > 0;
  }
  clear() {
    this.cache.clear();
  }
};

// ../../node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/resolveEndpointDiscoveryConfig.js
var resolveEndpointDiscoveryConfig = (input, { endpointDiscoveryCommandCtor }) => ({
  ...input,
  endpointDiscoveryCommandCtor,
  endpointCache: new EndpointCache(input.endpointCacheSize ?? 1e3),
  endpointDiscoveryEnabled: input.endpointDiscoveryEnabled !== void 0 ? () => Promise.resolve(input.endpointDiscoveryEnabled) : input.endpointDiscoveryEnabledProvider,
  isClientEndpointDiscoveryEnabled: input.endpointDiscoveryEnabled !== void 0
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig2(input) {
  return input;
}
var hostHeaderMiddleware2 = (options) => (next) => async (args) => {
  if (!HttpRequest2.isInstance(args.request))
    return next(args);
  const { request: request3 } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request3.headers[":authority"]) {
    delete request3.headers["host"];
    request3.headers[":authority"] = "";
  } else if (!request3.headers["host"]) {
    let host = request3.hostname;
    if (request3.port != null)
      host += `:${request3.port}`;
    request3.headers["host"] = host;
  }
  return next(args);
};
var hostHeaderMiddlewareOptions2 = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var getHostHeaderPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware2(options), hostHeaderMiddlewareOptions2);
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
var loggerMiddleware2 = () => (next, context) => async (args) => {
  try {
    const response = await next(args);
    const { clientName, commandName, logger: logger3, dynamoDbDocumentClientOptions = {} } = context;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
    const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
    const { $metadata, ...outputWithoutMetadata } = response.output;
    logger3?.info?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      output: outputFilterSensitiveLog(outputWithoutMetadata),
      metadata: $metadata
    });
    return response;
  } catch (error) {
    const { clientName, commandName, logger: logger3, dynamoDbDocumentClientOptions = {} } = context;
    const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
    logger3?.error?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      error,
      metadata: error.$metadata
    });
    throw error;
  }
};
var loggerMiddlewareOptions2 = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
var getLoggerPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware2(), loggerMiddlewareOptions2);
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var TRACE_ID_HEADER_NAME2 = "X-Amzn-Trace-Id";
var ENV_LAMBDA_FUNCTION_NAME2 = "AWS_LAMBDA_FUNCTION_NAME";
var ENV_TRACE_ID2 = "_X_AMZN_TRACE_ID";
var recursionDetectionMiddleware2 = (options) => (next) => async (args) => {
  const { request: request3 } = args;
  if (!HttpRequest2.isInstance(request3) || options.runtime !== "node" || request3.headers.hasOwnProperty(TRACE_ID_HEADER_NAME2)) {
    return next(args);
  }
  const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME2];
  const traceId = process.env[ENV_TRACE_ID2];
  const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request3.headers[TRACE_ID_HEADER_NAME2] = traceId;
  }
  return next({
    ...args,
    request: request3
  });
};
var addRecursionDetectionMiddlewareOptions2 = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
var getRecursionDetectionPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware2(options), addRecursionDetectionMiddlewareOptions2);
  }
});

// ../../node_modules/@smithy/property-provider/dist-es/ProviderError.js
var ProviderError2 = class _ProviderError extends Error {
  constructor(message, tryNextLink = true) {
    super(message);
    this.tryNextLink = tryNextLink;
    this.name = "ProviderError";
    Object.setPrototypeOf(this, _ProviderError.prototype);
  }
  static from(error, tryNextLink = true) {
    return Object.assign(new this(error.message, tryNextLink), error);
  }
};

// ../../node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js
var CredentialsProviderError2 = class _CredentialsProviderError extends ProviderError2 {
  constructor(message, tryNextLink = true) {
    super(message, tryNextLink);
    this.tryNextLink = tryNextLink;
    this.name = "CredentialsProviderError";
    Object.setPrototypeOf(this, _CredentialsProviderError.prototype);
  }
};

// ../../node_modules/@smithy/property-provider/dist-es/TokenProviderError.js
var TokenProviderError2 = class _TokenProviderError extends ProviderError2 {
  constructor(message, tryNextLink = true) {
    super(message, tryNextLink);
    this.tryNextLink = tryNextLink;
    this.name = "TokenProviderError";
    Object.setPrototypeOf(this, _TokenProviderError.prototype);
  }
};

// ../../node_modules/@smithy/property-provider/dist-es/chain.js
function chain2(...providers) {
  return () => {
    let promise = Promise.reject(new ProviderError2("No providers in chain"));
    for (const provider of providers) {
      promise = promise.catch((err) => {
        if (err?.tryNextLink) {
          return provider();
        }
        throw err;
      });
    }
    return promise;
  };
}

// ../../node_modules/@smithy/property-provider/dist-es/fromStatic.js
var fromStatic3 = (staticValue) => () => Promise.resolve(staticValue);

// ../../node_modules/@smithy/property-provider/dist-es/memoize.js
var memoize2 = (provider, isExpired, requiresRefresh) => {
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async () => {
    if (!pending) {
      pending = provider();
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  };
  if (isExpired === void 0) {
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider();
      }
      return resolved;
    };
  }
  return async (options) => {
    if (!hasResult || options?.forceRefresh) {
      resolved = await coalesceProvider();
    }
    if (isConstant) {
      return resolved;
    }
    if (requiresRefresh && !requiresRefresh(resolved)) {
      isConstant = true;
      return resolved;
    }
    if (isExpired(resolved)) {
      await coalesceProvider();
      return resolved;
    }
    return resolved;
  };
};

// ../../node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
var import_crc322 = __toESM(require_build2());

// ../../node_modules/@smithy/util-hex-encoding/dist-es/index.js
var SHORT_TO_HEX2 = {};
var HEX_TO_SHORT2 = {};
for (let i10 = 0; i10 < 256; i10++) {
  let encodedByte = i10.toString(16).toLowerCase();
  if (encodedByte.length === 1) {
    encodedByte = `0${encodedByte}`;
  }
  SHORT_TO_HEX2[i10] = encodedByte;
  HEX_TO_SHORT2[encodedByte] = i10;
}
function fromHex(encoded) {
  if (encoded.length % 2 !== 0) {
    throw new Error("Hex encoded strings must have an even number length");
  }
  const out = new Uint8Array(encoded.length / 2);
  for (let i10 = 0; i10 < encoded.length; i10 += 2) {
    const encodedByte = encoded.slice(i10, i10 + 2).toLowerCase();
    if (encodedByte in HEX_TO_SHORT2) {
      out[i10 / 2] = HEX_TO_SHORT2[encodedByte];
    } else {
      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
    }
  }
  return out;
}
function toHex2(bytes) {
  let out = "";
  for (let i10 = 0; i10 < bytes.byteLength; i10++) {
    out += SHORT_TO_HEX2[bytes[i10]];
  }
  return out;
}

// ../../node_modules/@smithy/eventstream-codec/dist-es/Int64.js
var Int64 = class _Int64 {
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number2) {
    if (number2 > 9223372036854776e3 || number2 < -9223372036854776e3) {
      throw new Error(`${number2} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes = new Uint8Array(8);
    for (let i10 = 7, remaining = Math.abs(Math.round(number2)); i10 > -1 && remaining > 0; i10--, remaining /= 256) {
      bytes[i10] = remaining;
    }
    if (number2 < 0) {
      negate(bytes);
    }
    return new _Int64(bytes);
  }
  valueOf() {
    const bytes = this.bytes.slice(0);
    const negative = bytes[0] & 128;
    if (negative) {
      negate(bytes);
    }
    return parseInt(toHex2(bytes), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function negate(bytes) {
  for (let i10 = 0; i10 < 8; i10++) {
    bytes[i10] ^= 255;
  }
  for (let i10 = 7; i10 > -1; i10--) {
    bytes[i10]++;
    if (bytes[i10] !== 0)
      break;
  }
}

// ../../node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
var HeaderMarshaller = class {
  constructor(toUtf86, fromUtf86) {
    this.toUtf8 = toUtf86;
    this.fromUtf8 = fromUtf86;
  }
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes = this.fromUtf8(headerName);
      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
    let position = 0;
    for (const chunk2 of chunks) {
      out.set(chunk2, position);
      position += chunk2.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = this.fromUtf8(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
  parse(headers) {
    const out = {};
    let position = 0;
    while (position < headers.byteLength) {
      const nameLength = headers.getUint8(position++);
      const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
      position += nameLength;
      switch (headers.getUint8(position++)) {
        case 0:
          out[name] = {
            type: BOOLEAN_TAG,
            value: true
          };
          break;
        case 1:
          out[name] = {
            type: BOOLEAN_TAG,
            value: false
          };
          break;
        case 2:
          out[name] = {
            type: BYTE_TAG,
            value: headers.getInt8(position++)
          };
          break;
        case 3:
          out[name] = {
            type: SHORT_TAG,
            value: headers.getInt16(position, false)
          };
          position += 2;
          break;
        case 4:
          out[name] = {
            type: INT_TAG,
            value: headers.getInt32(position, false)
          };
          position += 4;
          break;
        case 5:
          out[name] = {
            type: LONG_TAG,
            value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
          };
          position += 8;
          break;
        case 6:
          const binaryLength = headers.getUint16(position, false);
          position += 2;
          out[name] = {
            type: BINARY_TAG,
            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
          };
          position += binaryLength;
          break;
        case 7:
          const stringLength = headers.getUint16(position, false);
          position += 2;
          out[name] = {
            type: STRING_TAG,
            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
          };
          position += stringLength;
          break;
        case 8:
          out[name] = {
            type: TIMESTAMP_TAG,
            value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
          };
          position += 8;
          break;
        case 9:
          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
          position += 16;
          out[name] = {
            type: UUID_TAG,
            value: `${toHex2(uuidBytes.subarray(0, 4))}-${toHex2(uuidBytes.subarray(4, 6))}-${toHex2(uuidBytes.subarray(6, 8))}-${toHex2(uuidBytes.subarray(8, 10))}-${toHex2(uuidBytes.subarray(10))}`
          };
          break;
        default:
          throw new Error(`Unrecognized header type tag`);
      }
    }
    return out;
  }
};
var HEADER_VALUE_TYPE;
(function(HEADER_VALUE_TYPE2) {
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
var BOOLEAN_TAG = "boolean";
var BYTE_TAG = "byte";
var SHORT_TAG = "short";
var INT_TAG = "integer";
var LONG_TAG = "long";
var BINARY_TAG = "binary";
var STRING_TAG = "string";
var TIMESTAMP_TAG = "timestamp";
var UUID_TAG = "uuid";
var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

// ../../node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
var import_crc32 = __toESM(require_build2());
var PRELUDE_MEMBER_LENGTH = 4;
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
var CHECKSUM_LENGTH = 4;
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;

// ../../node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
var MessageDecoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const bytes of this.options.inputStream) {
      const decoded = this.options.decoder.decode(bytes);
      yield decoded;
    }
  }
};

// ../../node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
var MessageEncoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const msg of this.options.messageStream) {
      const encoded = this.options.encoder.encode(msg);
      yield encoded;
    }
    if (this.options.includeEndFrame) {
      yield new Uint8Array(0);
    }
  }
};

// ../../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
var SmithyMessageDecoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const message of this.options.messageStream) {
      const deserialized = await this.options.deserializer(message);
      if (deserialized === void 0)
        continue;
      yield deserialized;
    }
  }
};

// ../../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
var SmithyMessageEncoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const chunk2 of this.options.inputStream) {
      const payloadBuf = this.options.serializer(chunk2);
      yield payloadBuf;
    }
  }
};

// ../../node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
var normalizeProvider2 = (input) => {
  if (typeof input === "function")
    return input;
  const promisified = Promise.resolve(input);
  return () => promisified;
};

// ../../node_modules/@smithy/is-array-buffer/dist-es/index.js
var isArrayBuffer2 = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// ../../node_modules/@smithy/util-buffer-from/dist-es/index.js
var import_buffer4 = require("buffer");
var fromArrayBuffer2 = (input, offset = 0, length = input.byteLength - offset) => {
  if (!isArrayBuffer2(input)) {
    throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
  }
  return import_buffer4.Buffer.from(input, offset, length);
};
var fromString2 = (input, encoding) => {
  if (typeof input !== "string") {
    throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
  }
  return encoding ? import_buffer4.Buffer.from(input, encoding) : import_buffer4.Buffer.from(input);
};

// ../../node_modules/@smithy/util-utf8/dist-es/fromUtf8.js
var fromUtf85 = (input) => {
  const buf = fromString2(input, "utf8");
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

// ../../node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
var toUint8Array2 = (data) => {
  if (typeof data === "string") {
    return fromUtf85(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
};

// ../../node_modules/@smithy/util-utf8/dist-es/toUtf8.js
var toUtf85 = (input) => fromArrayBuffer2(input.buffer, input.byteOffset, input.byteLength).toString("utf8");

// ../../node_modules/@smithy/signature-v4/dist-es/constants.js
var ALGORITHM_QUERY_PARAM2 = "X-Amz-Algorithm";
var CREDENTIAL_QUERY_PARAM2 = "X-Amz-Credential";
var AMZ_DATE_QUERY_PARAM2 = "X-Amz-Date";
var SIGNED_HEADERS_QUERY_PARAM2 = "X-Amz-SignedHeaders";
var EXPIRES_QUERY_PARAM2 = "X-Amz-Expires";
var SIGNATURE_QUERY_PARAM2 = "X-Amz-Signature";
var TOKEN_QUERY_PARAM2 = "X-Amz-Security-Token";
var AUTH_HEADER2 = "authorization";
var AMZ_DATE_HEADER2 = AMZ_DATE_QUERY_PARAM2.toLowerCase();
var DATE_HEADER2 = "date";
var GENERATED_HEADERS2 = [AUTH_HEADER2, AMZ_DATE_HEADER2, DATE_HEADER2];
var SIGNATURE_HEADER2 = SIGNATURE_QUERY_PARAM2.toLowerCase();
var SHA256_HEADER2 = "x-amz-content-sha256";
var TOKEN_HEADER2 = TOKEN_QUERY_PARAM2.toLowerCase();
var ALWAYS_UNSIGNABLE_HEADERS2 = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
var PROXY_HEADER_PATTERN2 = /^proxy-/;
var SEC_HEADER_PATTERN2 = /^sec-/;
var ALGORITHM_IDENTIFIER2 = "AWS4-HMAC-SHA256";
var EVENT_ALGORITHM_IDENTIFIER2 = "AWS4-HMAC-SHA256-PAYLOAD";
var UNSIGNED_PAYLOAD2 = "UNSIGNED-PAYLOAD";
var MAX_CACHE_SIZE2 = 50;
var KEY_TYPE_IDENTIFIER2 = "aws4_request";
var MAX_PRESIGNED_TTL2 = 60 * 60 * 24 * 7;

// ../../node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js
var signingKeyCache2 = {};
var cacheQueue2 = [];
var createScope2 = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER2}`;
var getSigningKey2 = async (sha256Constructor, credentials, shortDate, region, service) => {
  const credsHash = await hmac3(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
  const cacheKey = `${shortDate}:${region}:${service}:${toHex2(credsHash)}:${credentials.sessionToken}`;
  if (cacheKey in signingKeyCache2) {
    return signingKeyCache2[cacheKey];
  }
  cacheQueue2.push(cacheKey);
  while (cacheQueue2.length > MAX_CACHE_SIZE2) {
    delete signingKeyCache2[cacheQueue2.shift()];
  }
  let key = `AWS4${credentials.secretAccessKey}`;
  for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER2]) {
    key = await hmac3(sha256Constructor, key, signable);
  }
  return signingKeyCache2[cacheKey] = key;
};
var hmac3 = (ctor, secret, data) => {
  const hash2 = new ctor(secret);
  hash2.update(toUint8Array2(data));
  return hash2.digest();
};

// ../../node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js
var getCanonicalHeaders2 = ({ headers }, unsignableHeaders, signableHeaders) => {
  const canonical = {};
  for (const headerName of Object.keys(headers).sort()) {
    if (headers[headerName] == void 0) {
      continue;
    }
    const canonicalHeaderName = headerName.toLowerCase();
    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS2 || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN2.test(canonicalHeaderName) || SEC_HEADER_PATTERN2.test(canonicalHeaderName)) {
      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
        continue;
      }
    }
    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
  }
  return canonical;
};

// ../../node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
var escapeUri2 = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode2);
var hexEncode2 = (c10) => `%${c10.charCodeAt(0).toString(16).toUpperCase()}`;

// ../../node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js
var getCanonicalQuery2 = ({ query = {} }) => {
  const keys = [];
  const serialized = {};
  for (const key of Object.keys(query).sort()) {
    if (key.toLowerCase() === SIGNATURE_HEADER2) {
      continue;
    }
    keys.push(key);
    const value = query[key];
    if (typeof value === "string") {
      serialized[key] = `${escapeUri2(key)}=${escapeUri2(value)}`;
    } else if (Array.isArray(value)) {
      serialized[key] = value.slice(0).sort().reduce((encoded, value2) => encoded.concat([`${escapeUri2(key)}=${escapeUri2(value2)}`]), []).join("&");
    }
  }
  return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
};

// ../../node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash2 = async ({ headers, body }, hashConstructor) => {
  for (const headerName of Object.keys(headers)) {
    if (headerName.toLowerCase() === SHA256_HEADER2) {
      return headers[headerName];
    }
  }
  if (body == void 0) {
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer2(body)) {
    const hashCtor = new hashConstructor();
    hashCtor.update(toUint8Array2(body));
    return toHex2(await hashCtor.digest());
  }
  return UNSIGNED_PAYLOAD2;
};

// ../../node_modules/@smithy/signature-v4/dist-es/headerUtil.js
var hasHeader2 = (soughtHeader, headers) => {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// ../../node_modules/@smithy/signature-v4/dist-es/cloneRequest.js
var cloneRequest2 = ({ headers, query, ...rest }) => ({
  ...rest,
  headers: { ...headers },
  query: query ? cloneQuery4(query) : void 0
});
var cloneQuery4 = (query) => Object.keys(query).reduce((carry, paramName) => {
  const param = query[paramName];
  return {
    ...carry,
    [paramName]: Array.isArray(param) ? [...param] : param
  };
}, {});

// ../../node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
var moveHeadersToQuery2 = (request3, options = {}) => {
  const { headers, query = {} } = typeof request3.clone === "function" ? request3.clone() : cloneRequest2(request3);
  for (const name of Object.keys(headers)) {
    const lname = name.toLowerCase();
    if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
      query[name] = headers[name];
      delete headers[name];
    }
  }
  return {
    ...request3,
    headers,
    query
  };
};

// ../../node_modules/@smithy/signature-v4/dist-es/prepareRequest.js
var prepareRequest2 = (request3) => {
  request3 = typeof request3.clone === "function" ? request3.clone() : cloneRequest2(request3);
  for (const headerName of Object.keys(request3.headers)) {
    if (GENERATED_HEADERS2.indexOf(headerName.toLowerCase()) > -1) {
      delete request3.headers[headerName];
    }
  }
  return request3;
};

// ../../node_modules/@smithy/signature-v4/dist-es/utilDate.js
var iso86012 = (time) => toDate2(time).toISOString().replace(/\.\d{3}Z$/, "Z");
var toDate2 = (time) => {
  if (typeof time === "number") {
    return new Date(time * 1e3);
  }
  if (typeof time === "string") {
    if (Number(time)) {
      return new Date(Number(time) * 1e3);
    }
    return new Date(time);
  }
  return time;
};

// ../../node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
var SignatureV42 = class {
  constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
    this.headerMarshaller = new HeaderMarshaller(toUtf85, fromUtf85);
    this.service = service;
    this.sha256 = sha256;
    this.uriEscapePath = uriEscapePath;
    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
    this.regionProvider = normalizeProvider2(region);
    this.credentialProvider = normalizeProvider2(credentials);
  }
  async presign(originalRequest, options = {}) {
    const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { longDate, shortDate } = formatDate2(signingDate);
    if (expiresIn > MAX_PRESIGNED_TTL2) {
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    }
    const scope = createScope2(shortDate, region, signingService ?? this.service);
    const request3 = moveHeadersToQuery2(prepareRequest2(originalRequest), { unhoistableHeaders });
    if (credentials.sessionToken) {
      request3.query[TOKEN_QUERY_PARAM2] = credentials.sessionToken;
    }
    request3.query[ALGORITHM_QUERY_PARAM2] = ALGORITHM_IDENTIFIER2;
    request3.query[CREDENTIAL_QUERY_PARAM2] = `${credentials.accessKeyId}/${scope}`;
    request3.query[AMZ_DATE_QUERY_PARAM2] = longDate;
    request3.query[EXPIRES_QUERY_PARAM2] = expiresIn.toString(10);
    const canonicalHeaders = getCanonicalHeaders2(request3, unsignableHeaders, signableHeaders);
    request3.query[SIGNED_HEADERS_QUERY_PARAM2] = getCanonicalHeaderList2(canonicalHeaders);
    request3.query[SIGNATURE_QUERY_PARAM2] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request3, canonicalHeaders, await getPayloadHash2(originalRequest, this.sha256)));
    return request3;
  }
  async sign(toSign, options) {
    if (typeof toSign === "string") {
      return this.signString(toSign, options);
    } else if (toSign.headers && toSign.payload) {
      return this.signEvent(toSign, options);
    } else if (toSign.message) {
      return this.signMessage(toSign, options);
    } else {
      return this.signRequest(toSign, options);
    }
  }
  async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate, longDate } = formatDate2(signingDate);
    const scope = createScope2(shortDate, region, signingService ?? this.service);
    const hashedPayload = await getPayloadHash2({ headers: {}, body: payload }, this.sha256);
    const hash2 = new this.sha256();
    hash2.update(headers);
    const hashedHeaders = toHex2(await hash2.digest());
    const stringToSign = [
      EVENT_ALGORITHM_IDENTIFIER2,
      longDate,
      scope,
      priorSignature,
      hashedHeaders,
      hashedPayload
    ].join("\n");
    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
  }
  async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
    const promise = this.signEvent({
      headers: this.headerMarshaller.format(signableMessage.message.headers),
      payload: signableMessage.message.body
    }, {
      signingDate,
      signingRegion,
      signingService,
      priorSignature: signableMessage.priorSignature
    });
    return promise.then((signature) => {
      return { message: signableMessage.message, signature };
    });
  }
  async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate } = formatDate2(signingDate);
    const hash2 = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
    hash2.update(toUint8Array2(stringToSign));
    return toHex2(await hash2.digest());
  }
  async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const request3 = prepareRequest2(requestToSign);
    const { longDate, shortDate } = formatDate2(signingDate);
    const scope = createScope2(shortDate, region, signingService ?? this.service);
    request3.headers[AMZ_DATE_HEADER2] = longDate;
    if (credentials.sessionToken) {
      request3.headers[TOKEN_HEADER2] = credentials.sessionToken;
    }
    const payloadHash = await getPayloadHash2(request3, this.sha256);
    if (!hasHeader2(SHA256_HEADER2, request3.headers) && this.applyChecksum) {
      request3.headers[SHA256_HEADER2] = payloadHash;
    }
    const canonicalHeaders = getCanonicalHeaders2(request3, unsignableHeaders, signableHeaders);
    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request3, canonicalHeaders, payloadHash));
    request3.headers[AUTH_HEADER2] = `${ALGORITHM_IDENTIFIER2} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList2(canonicalHeaders)}, Signature=${signature}`;
    return request3;
  }
  createCanonicalRequest(request3, canonicalHeaders, payloadHash) {
    const sortedHeaders = Object.keys(canonicalHeaders).sort();
    return `${request3.method}
${this.getCanonicalPath(request3)}
${getCanonicalQuery2(request3)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
  }
  async createStringToSign(longDate, credentialScope, canonicalRequest) {
    const hash2 = new this.sha256();
    hash2.update(toUint8Array2(canonicalRequest));
    const hashedRequest = await hash2.digest();
    return `${ALGORITHM_IDENTIFIER2}
${longDate}
${credentialScope}
${toHex2(hashedRequest)}`;
  }
  getCanonicalPath({ path }) {
    if (this.uriEscapePath) {
      const normalizedPathSegments = [];
      for (const pathSegment of path.split("/")) {
        if (pathSegment?.length === 0)
          continue;
        if (pathSegment === ".")
          continue;
        if (pathSegment === "..") {
          normalizedPathSegments.pop();
        } else {
          normalizedPathSegments.push(pathSegment);
        }
      }
      const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
      const doubleEncoded = encodeURIComponent(normalizedPath);
      return doubleEncoded.replace(/%2F/g, "/");
    }
    return path;
  }
  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
    const hash2 = new this.sha256(await keyPromise);
    hash2.update(toUint8Array2(stringToSign));
    return toHex2(await hash2.digest());
  }
  getSigningKey(credentials, region, shortDate, service) {
    return getSigningKey2(this.sha256, credentials, shortDate, region, service || this.service);
  }
  validateResolvedCredentials(credentials) {
    if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
      throw new Error("Resolved credential object is not valid");
    }
  }
};
var formatDate2 = (now) => {
  const longDate = iso86012(now).replace(/[\-:]/g, "");
  return {
    longDate,
    shortDate: longDate.slice(0, 8)
  };
};
var getCanonicalHeaderList2 = (headers) => Object.keys(headers).sort().join(";");

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthConfiguration.js
var CREDENTIAL_EXPIRE_WINDOW2 = 3e5;
var resolveAwsAuthConfig2 = (input) => {
  const normalizedCreds = input.credentials ? normalizeCredentialProvider2(input.credentials) : input.credentialDefaultProvider(input);
  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
  let signer;
  if (input.signer) {
    signer = normalizeProvider2(input.signer);
  } else if (input.regionInfoProvider) {
    signer = () => normalizeProvider2(input.region)().then(async (region) => [
      await input.regionInfoProvider(region, {
        useFipsEndpoint: await input.useFipsEndpoint(),
        useDualstackEndpoint: await input.useDualstackEndpoint()
      }) || {},
      region
    ]).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      input.signingRegion = input.signingRegion || signingRegion || region;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV42;
      return new SignerCtor(params);
    });
  } else {
    signer = async (authScheme) => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: input.signingName || input.defaultSigningName,
        signingRegion: await normalizeProvider2(input.region)(),
        properties: {}
      }, authScheme);
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      input.signingRegion = input.signingRegion || signingRegion;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV42;
      return new SignerCtor(params);
    };
  }
  return {
    ...input,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
};
var normalizeCredentialProvider2 = (credentials) => {
  if (typeof credentials === "function") {
    return memoize2(credentials, (credentials2) => credentials2.expiration !== void 0 && credentials2.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW2, (credentials2) => credentials2.expiration !== void 0);
  }
  return normalizeProvider2(credentials);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate2 = (systemClockOffset) => new Date(Date.now() + systemClockOffset);

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js
var isClockSkewed2 = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate2(systemClockOffset).getTime() - clockTime) >= 3e5;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset2 = (clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed2(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthMiddleware.js
var awsAuthMiddleware2 = (options) => (next, context) => async function(args) {
  if (!HttpRequest2.isInstance(args.request))
    return next(args);
  const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
  const multiRegionOverride = authScheme?.name === "sigv4a" ? authScheme?.signingRegionSet?.join(",") : void 0;
  const signer = await options.signer(authScheme);
  const output = await next({
    ...args,
    request: await signer.sign(args.request, {
      signingDate: getSkewCorrectedDate2(options.systemClockOffset),
      signingRegion: multiRegionOverride || context["signing_region"],
      signingService: context["signing_service"]
    })
  }).catch((error) => {
    const serverTime = error.ServerTime ?? getDateHeader2(error.$response);
    if (serverTime) {
      options.systemClockOffset = getUpdatedSystemClockOffset2(serverTime, options.systemClockOffset);
    }
    throw error;
  });
  const dateHeader = getDateHeader2(output.response);
  if (dateHeader) {
    options.systemClockOffset = getUpdatedSystemClockOffset2(dateHeader, options.systemClockOffset);
  }
  return output;
};
var getDateHeader2 = (response) => HttpResponse2.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0;
var awsAuthMiddlewareOptions2 = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: true
};
var getAwsAuthPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(awsAuthMiddleware2(options), awsAuthMiddlewareOptions2);
  }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function resolveUserAgentConfig2(input) {
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
  };
}

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default2 = {
  partitions: [{
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  }, {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  }, {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  }, {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  }, {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  }, {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      name: "aws-iso-e",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {}
  }, {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      name: "aws-iso-f",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }],
  version: "1.1"
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var selectedPartitionsInfo = partitions_default2;
var selectedUserAgentPrefix = "";
var partition2 = (value) => {
  const { partitions: partitions2 } = selectedPartitionsInfo;
  for (const partition3 of partitions2) {
    const { regions, outputs } = partition3;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition3 of partitions2) {
    const { regionRegex, outputs } = partition3;
    if (new RegExp(regionRegex).test(value)) {
      return {
        ...outputs
      };
    }
  }
  const DEFAULT_PARTITION2 = partitions2.find((partition3) => partition3.id === "aws");
  if (!DEFAULT_PARTITION2) {
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION2.outputs
  };
};
var setPartitionInfo = (partitionsInfo, userAgentPrefix = "") => {
  selectedPartitionsInfo = partitionsInfo;
  selectedUserAgentPrefix = userAgentPrefix;
};
var useDefaultPartitionInfo = () => {
  setPartitionInfo(partitions_default2, "");
};
var getUserAgentPrefix = () => selectedUserAgentPrefix;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/debug/debugId.js
var debugId2 = "endpoints";

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString2(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString2(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString2).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
var EndpointError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "EndpointError";
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  aws: () => aws_exports2,
  booleanEquals: () => booleanEquals2,
  getAttr: () => getAttr2,
  isSet: () => isSet2,
  isValidHostLabel: () => isValidHostLabel2,
  not: () => not2,
  parseURL: () => parseURL2,
  stringEquals: () => stringEquals2,
  substring: () => substring2,
  uriEncode: () => uriEncode2
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/index.js
var aws_exports2 = {};
__export(aws_exports2, {
  getUserAgentPrefix: () => getUserAgentPrefix,
  isVirtualHostableS3Bucket: () => isVirtualHostableS3Bucket2,
  parseArn: () => parseArn2,
  partition: () => partition2,
  setPartitionInfo: () => setPartitionInfo,
  useDefaultPartitionInfo: () => useDefaultPartitionInfo
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
var IP_V4_REGEX2 = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
var isIpAddress2 = (value) => IP_V4_REGEX2.test(value) || value.startsWith("[") && value.endsWith("]");

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/isValidHostLabel.js
var VALID_HOST_LABEL_REGEX2 = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
var isValidHostLabel2 = (value, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX2.test(value);
  }
  const labels = value.split(".");
  for (const label of labels) {
    if (!isValidHostLabel2(label)) {
      return false;
    }
  }
  return true;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket2 = (value, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value.split(".")) {
      if (!isVirtualHostableS3Bucket2(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel2(value)) {
    return false;
  }
  if (value.length < 3 || value.length > 63) {
    return false;
  }
  if (value !== value.toLowerCase()) {
    return false;
  }
  if (isIpAddress2(value)) {
    return false;
  }
  return true;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
var parseArn2 = (value) => {
  const segments = value.split(":");
  if (segments.length < 6)
    return null;
  const [arn, partition3, service, region, accountId, ...resourceId] = segments;
  if (arn !== "arn" || partition3 === "" || service === "" || resourceId[0] === "")
    return null;
  return {
    partition: partition3,
    service,
    region,
    accountId,
    resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/booleanEquals.js
var booleanEquals2 = (value1, value2) => value1 === value2;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttrPathList.js
var getAttrPathList2 = (path) => {
  const parts = path.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError2(`Path: '${path}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError2(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttr.js
var getAttr2 = (value, path) => getAttrPathList2(path).reduce((acc, index) => {
  if (typeof acc !== "object") {
    throw new EndpointError2(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index)];
  }
  return acc[index];
}, value);

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/isSet.js
var isSet2 = (value) => value != null;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/not.js
var not2 = (value) => !value;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/types/dist-es/auth.js
var HttpAuthLocation3;
(function(HttpAuthLocation4) {
  HttpAuthLocation4["HEADER"] = "header";
  HttpAuthLocation4["QUERY"] = "query";
})(HttpAuthLocation3 || (HttpAuthLocation3 = {}));

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/types/dist-es/dns.js
var HostAddressType2;
(function(HostAddressType3) {
  HostAddressType3["AAAA"] = "AAAA";
  HostAddressType3["A"] = "A";
})(HostAddressType2 || (HostAddressType2 = {}));

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/types/dist-es/endpoint.js
var EndpointURLScheme3;
(function(EndpointURLScheme4) {
  EndpointURLScheme4["HTTP"] = "http";
  EndpointURLScheme4["HTTPS"] = "https";
})(EndpointURLScheme3 || (EndpointURLScheme3 = {}));

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/types/dist-es/transfer.js
var RequestHandlerProtocol2;
(function(RequestHandlerProtocol3) {
  RequestHandlerProtocol3["HTTP_0_9"] = "http/0.9";
  RequestHandlerProtocol3["HTTP_1_0"] = "http/1.0";
  RequestHandlerProtocol3["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol2 || (RequestHandlerProtocol2 = {}));

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/parseURL.js
var DEFAULT_PORTS2 = {
  [EndpointURLScheme3.HTTP]: 80,
  [EndpointURLScheme3.HTTPS]: 443
};
var parseURL2 = (value) => {
  const whatwgURL = (() => {
    try {
      if (value instanceof URL) {
        return value;
      }
      if (typeof value === "object" && "hostname" in value) {
        const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
        const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
        url.search = Object.entries(query).map(([k10, v6]) => `${k10}=${v6}`).join("&");
        return url;
      }
      return new URL(value);
    } catch (error) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname, pathname, protocol, search } = whatwgURL;
  if (search) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(EndpointURLScheme3).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress2(hostname);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS2[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS2[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS2[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/stringEquals.js
var stringEquals2 = (value1, value2) => value1 === value2;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/substring.js
var substring2 = (input, start, stop, reverse) => {
  if (start >= stop || input.length < stop) {
    return null;
  }
  if (!reverse) {
    return input.substring(start, stop);
  }
  return input.substring(input.length - stop, input.length - start);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/lib/uriEncode.js
var uriEncode2 = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c10) => `%${c10.charCodeAt(0).toString(16).toUpperCase()}`);

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTemplate.js
var evaluateTemplate2 = (template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr2(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/getReferenceValue.js
var getReferenceValue2 = ({ ref }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref];
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression2 = (obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate2(obj, options);
  } else if (obj["fn"]) {
    return callFunction2(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue2(obj, options);
  }
  throw new EndpointError2(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/callFunction.js
var callFunction2 = ({ fn, argv }, options) => {
  const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression2(arg, "arg", options));
  return fn.split(".").reduce((acc, key) => acc[key], lib_exports2)(...evaluatedArgs);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition2 = ({ assign, ...fnArgs }, options) => {
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError2(`'${assign}' is already defined in Reference Record.`);
  }
  const value = callFunction2(fnArgs, options);
  options.logger?.debug?.(debugId2, `evaluateCondition: ${toDebugString2(fnArgs)} = ${toDebugString2(value)}`);
  return {
    result: value === "" ? true : !!value,
    ...assign != null && { toAssign: { name: assign, value } }
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions2 = (conditions = [], options) => {
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition2(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      options.logger?.debug?.(debugId2, `assign: ${toAssign.name} := ${toDebugString2(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointHeaders.js
var getEndpointHeaders2 = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression2(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError2(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperty.js
var getEndpointProperty2 = (property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty2(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate2(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError2(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties2(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError2(`Unexpected endpoint property type: ${typeof property}`);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties2 = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty2(propertyVal, options)
}), {});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointUrl.js
var getEndpointUrl2 = (endpointUrl, options) => {
  const expression = evaluateExpression2(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error) {
      console.error(`Failed to construct URL with ${expression}`, error);
      throw error;
    }
  }
  throw new EndpointError2(`Endpoint URL must be a string, got ${typeof expression}`);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule2 = (endpointRule, options) => {
  const { conditions, endpoint } = endpointRule;
  const { result, referenceRecord } = evaluateConditions2(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url, properties, headers } = endpoint;
  options.logger?.debug?.(debugId2, `Resolving endpoint from template: ${toDebugString2(endpoint)}`);
  return {
    ...headers != void 0 && {
      headers: getEndpointHeaders2(headers, endpointRuleOptions)
    },
    ...properties != void 0 && {
      properties: getEndpointProperties2(properties, endpointRuleOptions)
    },
    url: getEndpointUrl2(url, endpointRuleOptions)
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateErrorRule.js
var evaluateErrorRule2 = (errorRule, options) => {
  const { conditions, error } = errorRule;
  const { result, referenceRecord } = evaluateConditions2(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError2(evaluateExpression2(error, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTreeRule.js
var evaluateTreeRule2 = (treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions2(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules2(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules2 = (rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule2(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule2(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule2(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError2(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError2(`Rules evaluation failed`);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint2 = (ruleSetObject, options) => {
  const { endpointParams, logger: logger3 } = options;
  const { parameters, rules } = ruleSetObject;
  options.logger?.debug?.(`${debugId2} Initial EndpointParams: ${toDebugString2(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters).filter(([, v6]) => v6.default != null).map(([k10, v6]) => [k10, v6.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters).filter(([, v6]) => v6.required).map(([k10]) => k10);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError2(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint = evaluateRules2(rules, { endpointParams, logger: logger3, referenceRecord: {} });
  if (options.endpointParams?.Endpoint) {
    try {
      const givenEndpoint = new URL(options.endpointParams.Endpoint);
      const { protocol, port } = givenEndpoint;
      endpoint.url.protocol = protocol;
      endpoint.url.port = port;
    } catch (e10) {
    }
  }
  options.logger?.debug?.(`${debugId2} Resolved endpoint: ${toDebugString2(endpoint)}`);
  return endpoint;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT2 = "user-agent";
var X_AMZ_USER_AGENT2 = "x-amz-user-agent";
var SPACE2 = " ";
var UA_NAME_SEPARATOR = "/";
var UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
var UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
var UA_ESCAPE_CHAR = "-";

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware2 = (options) => (next, context) => async (args) => {
  const { request: request3 } = args;
  if (!HttpRequest2.isInstance(request3))
    return next(args);
  const { headers } = request3;
  const userAgent = context?.userAgent?.map(escapeUserAgent2) || [];
  const defaultUserAgent3 = (await options.defaultUserAgentProvider()).map(escapeUserAgent2);
  const customUserAgent = options?.customUserAgent?.map(escapeUserAgent2) || [];
  const prefix = getUserAgentPrefix();
  const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent3, ...userAgent, ...customUserAgent]).join(SPACE2);
  const normalUAValue = [
    ...defaultUserAgent3.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE2);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT2] = headers[X_AMZ_USER_AGENT2] ? `${headers[USER_AGENT2]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT2] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT2] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request: request3
  });
};
var escapeUserAgent2 = (userAgentPair) => {
  const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
  const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
  const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
  const prefix = name.substring(0, prefixSeparatorIndex);
  let uaName = name.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
    switch (index) {
      case 0:
        return item;
      case 1:
        return `${acc}/${item}`;
      default:
        return `${acc}#${item}`;
    }
  }, "");
};
var getUserAgentMiddlewareOptions2 = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var getUserAgentPlugin2 = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware2(config), getUserAgentMiddlewareOptions2);
  }
});

// ../../node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js
var SelectorType2;
(function(SelectorType3) {
  SelectorType3["ENV"] = "env";
  SelectorType3["CONFIG"] = "shared config entry";
})(SelectorType2 || (SelectorType2 = {}));
var booleanSelector2 = (obj, key, type) => {
  if (!(key in obj))
    return void 0;
  if (obj[key] === "true")
    return true;
  if (obj[key] === "false")
    return false;
  throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var ENV_USE_DUALSTACK_ENDPOINT2 = "AWS_USE_DUALSTACK_ENDPOINT";
var CONFIG_USE_DUALSTACK_ENDPOINT2 = "use_dualstack_endpoint";
var NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => booleanSelector2(env3, ENV_USE_DUALSTACK_ENDPOINT2, SelectorType2.ENV),
  configFileSelector: (profile) => booleanSelector2(profile, CONFIG_USE_DUALSTACK_ENDPOINT2, SelectorType2.CONFIG),
  default: false
};

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var ENV_USE_FIPS_ENDPOINT2 = "AWS_USE_FIPS_ENDPOINT";
var CONFIG_USE_FIPS_ENDPOINT2 = "use_fips_endpoint";
var NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => booleanSelector2(env3, ENV_USE_FIPS_ENDPOINT2, SelectorType2.ENV),
  configFileSelector: (profile) => booleanSelector2(profile, CONFIG_USE_FIPS_ENDPOINT2, SelectorType2.CONFIG),
  default: false
};

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js
var REGION_ENV_NAME2 = "AWS_REGION";
var REGION_INI_NAME2 = "region";
var NODE_REGION_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => env3[REGION_ENV_NAME2],
  configFileSelector: (profile) => profile[REGION_INI_NAME2],
  default: () => {
    throw new Error("Region is missing");
  }
};
var NODE_REGION_CONFIG_FILE_OPTIONS2 = {
  preferredFile: "credentials"
};

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js
var isFipsRegion2 = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion2 = (region) => isFipsRegion2(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig2 = (input) => {
  const { region, useFipsEndpoint } = input;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion2(region);
      }
      const providedRegion = await region();
      return getRealRegion2(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion2(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
};

// ../../node_modules/@smithy/middleware-content-length/dist-es/index.js
var CONTENT_LENGTH_HEADER2 = "content-length";
function contentLengthMiddleware2(bodyLengthChecker) {
  return (next) => async (args) => {
    const request3 = args.request;
    if (HttpRequest2.isInstance(request3)) {
      const { body, headers } = request3;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER2) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request3.headers = {
            ...request3.headers,
            [CONTENT_LENGTH_HEADER2]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request: request3
    });
  };
}
var contentLengthMiddlewareOptions2 = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
var getContentLengthPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware2(options.bodyLengthChecker), contentLengthMiddlewareOptions2);
  }
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
var resolveParamsForS32 = async (endpointParams) => {
  const bucket = endpointParams?.Bucket || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName2(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName2(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
};
var DOMAIN_PATTERN2 = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
var IP_ADDRESS_PATTERN2 = /(\d+\.){3}\d+/;
var DOTS_PATTERN2 = /\.\./;
var isDnsCompatibleBucketName2 = (bucketName) => DOMAIN_PATTERN2.test(bucketName) && !IP_ADDRESS_PATTERN2.test(bucketName) && !DOTS_PATTERN2.test(bucketName);
var isArnBucketName2 = (bucketName) => {
  const [arn, partition3, service, region, account, typeOrId] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = [arn, partition3, service, account, typeOrId].filter(Boolean).length === 5;
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return arn === "arn" && !!partition3 && !!service && !!account && !!typeOrId;
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
var createConfigValueProvider2 = (configKey, canonicalEndpointParamKey, config) => {
  const configProvider = async () => {
    const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  };
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint = await configProvider();
      if (endpoint && typeof endpoint === "object") {
        if ("url" in endpoint) {
          return endpoint.url.href;
        }
        if ("hostname" in endpoint) {
          const { protocol, hostname, port, path } = endpoint;
          return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
        }
      }
      return endpoint;
    };
  }
  return configProvider;
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions2 = async (commandInput, instructionsSupplier, clientConfig, context) => {
  const endpointParams = await resolveParams2(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint = clientConfig.endpointProvider(endpointParams, context);
  return endpoint;
};
var resolveParams2 = async (commandInput, instructionsSupplier, clientConfig) => {
  const endpointParams = {};
  const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
  for (const [name, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name] = await createConfigValueProvider2(instruction.name, name, clientConfig)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS32(endpointParams);
  }
  return endpointParams;
};

// ../../node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString2(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}

// ../../node_modules/@smithy/url-parser/dist-es/index.js
var parseUrl2 = (url) => {
  if (typeof url === "string") {
    return parseUrl2(new URL(url));
  }
  const { hostname, pathname, port, protocol, search } = url;
  let query;
  if (search) {
    query = parseQueryString2(search);
  }
  return {
    hostname,
    port: port ? parseInt(port) : void 0,
    protocol,
    path: pathname,
    query
  };
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV12 = (endpoint) => {
  if (typeof endpoint === "object") {
    if ("url" in endpoint) {
      return parseUrl2(endpoint.url);
    }
    return endpoint;
  }
  return parseUrl2(endpoint);
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js
var endpointMiddleware2 = ({ config, instructions }) => {
  return (next, context) => async (args) => {
    const endpoint = await getEndpointFromInstructions2(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config }, context);
    context.endpointV2 = endpoint;
    context.authSchemes = endpoint.properties?.authSchemes;
    const authScheme = context.authSchemes?.[0];
    if (authScheme) {
      context["signing_region"] = authScheme.signingRegion;
      context["signing_service"] = authScheme.signingName;
    }
    return next({
      ...args
    });
  };
};

// ../../node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
var deserializerMiddleware2 = (options, deserializer) => (next, context) => async (args) => {
  const { response } = await next(args);
  try {
    const parsed = await deserializer(response, options);
    return {
      response,
      output: parsed
    };
  } catch (error) {
    Object.defineProperty(error, "$response", {
      value: response
    });
    if (!("$metadata" in error)) {
      const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
      error.message += "\n  " + hint;
    }
    throw error;
  }
};

// ../../node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
var serializerMiddleware2 = (options, serializer) => (next, context) => async (args) => {
  const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
  if (!endpoint) {
    throw new Error("No valid endpoint provider available.");
  }
  const request3 = await serializer(args.input, { ...options, endpoint });
  return next({
    ...args,
    request: request3
  });
};

// ../../node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
var deserializerMiddlewareOption2 = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
var serializerMiddlewareOption2 = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function getSerdePlugin2(config, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware2(config, deserializer), deserializerMiddlewareOption2);
      commandStack.add(serializerMiddleware2(config, serializer), serializerMiddlewareOption2);
    }
  };
}

// ../../node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions2 = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption2.name
};
var getEndpointPlugin2 = (config, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware2({
      config,
      instructions
    }), endpointMiddlewareOptions2);
  }
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js
var resolveEndpointConfig2 = (input) => {
  const tls = input.tls ?? true;
  const { endpoint } = input;
  const customEndpointProvider = endpoint != null ? async () => toEndpointV12(await normalizeProvider2(endpoint)()) : void 0;
  const isCustomEndpoint = !!endpoint;
  return {
    ...input,
    endpoint: customEndpointProvider,
    tls,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider2(input.useDualstackEndpoint ?? false),
    useFipsEndpoint: normalizeProvider2(input.useFipsEndpoint ?? false)
  };
};

// ../../node_modules/@smithy/util-retry/dist-es/config.js
var RETRY_MODES2;
(function(RETRY_MODES3) {
  RETRY_MODES3["STANDARD"] = "standard";
  RETRY_MODES3["ADAPTIVE"] = "adaptive";
})(RETRY_MODES2 || (RETRY_MODES2 = {}));
var DEFAULT_MAX_ATTEMPTS2 = 3;
var DEFAULT_RETRY_MODE2 = RETRY_MODES2.STANDARD;

// ../../node_modules/@smithy/service-error-classification/dist-es/constants.js
var THROTTLING_ERROR_CODES2 = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
var TRANSIENT_ERROR_CODES2 = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
var TRANSIENT_ERROR_STATUS_CODES2 = [500, 502, 503, 504];
var NODEJS_TIMEOUT_ERROR_CODES3 = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

// ../../node_modules/@smithy/service-error-classification/dist-es/index.js
var isThrottlingError2 = (error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES2.includes(error.name) || error.$retryable?.throttling == true;
var isTransientError2 = (error) => TRANSIENT_ERROR_CODES2.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES3.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES2.includes(error.$metadata?.httpStatusCode || 0);
var isServerError2 = (error) => {
  if (error.$metadata?.httpStatusCode !== void 0) {
    const statusCode = error.$metadata.httpStatusCode;
    if (500 <= statusCode && statusCode <= 599 && !isTransientError2(error)) {
      return true;
    }
    return false;
  }
  return false;
};

// ../../node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
var DefaultRateLimiter2 = class {
  constructor(options) {
    this.currentCapacity = 0;
    this.enabled = false;
    this.lastMaxRate = 0;
    this.measuredTxRate = 0;
    this.requestCount = 0;
    this.lastTimestamp = 0;
    this.timeWindow = 0;
    this.beta = options?.beta ?? 0.7;
    this.minCapacity = options?.minCapacity ?? 1;
    this.minFillRate = options?.minFillRate ?? 0.5;
    this.scaleConstant = options?.scaleConstant ?? 0.4;
    this.smooth = options?.smooth ?? 0.8;
    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = currentTimeInSeconds;
    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
    this.fillRate = this.minFillRate;
    this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(amount) {
    if (!this.enabled) {
      return;
    }
    this.refillTokenBucket();
    if (amount > this.currentCapacity) {
      const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
    this.currentCapacity = this.currentCapacity - amount;
  }
  refillTokenBucket() {
    const timestamp = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = timestamp;
      return;
    }
    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
    this.lastTimestamp = timestamp;
  }
  updateClientSendingRate(response) {
    let calculatedRate;
    this.updateMeasuredRate();
    if (isThrottlingError2(response)) {
      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
      this.lastMaxRate = rateToUse;
      this.calculateTimeWindow();
      this.lastThrottleTime = this.getCurrentTimeInSeconds();
      calculatedRate = this.cubicThrottle(rateToUse);
      this.enableTokenBucket();
    } else {
      this.calculateTimeWindow();
      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
    }
    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(newRate);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(rateToUse) {
    return this.getPrecise(rateToUse * this.beta);
  }
  cubicSuccess(timestamp) {
    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(newRate) {
    this.refillTokenBucket();
    this.fillRate = Math.max(newRate, this.minFillRate);
    this.maxCapacity = Math.max(newRate, this.minCapacity);
    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t5 = this.getCurrentTimeInSeconds();
    const timeBucket = Math.floor(t5 * 2) / 2;
    this.requestCount++;
    if (timeBucket > this.lastTxRateBucket) {
      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
      this.requestCount = 0;
      this.lastTxRateBucket = timeBucket;
    }
  }
  getPrecise(num) {
    return parseFloat(num.toFixed(8));
  }
};

// ../../node_modules/@smithy/util-retry/dist-es/constants.js
var DEFAULT_RETRY_DELAY_BASE2 = 100;
var MAXIMUM_RETRY_DELAY2 = 20 * 1e3;
var THROTTLING_RETRY_DELAY_BASE2 = 500;
var INITIAL_RETRY_TOKENS2 = 500;
var RETRY_COST2 = 5;
var TIMEOUT_RETRY_COST2 = 10;
var NO_RETRY_INCREMENT2 = 1;
var INVOCATION_ID_HEADER2 = "amz-sdk-invocation-id";
var REQUEST_HEADER2 = "amz-sdk-request";

// ../../node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js
var getDefaultRetryBackoffStrategy2 = () => {
  let delayBase = DEFAULT_RETRY_DELAY_BASE2;
  const computeNextBackoffDelay = (attempts) => {
    return Math.floor(Math.min(MAXIMUM_RETRY_DELAY2, Math.random() * 2 ** attempts * delayBase));
  };
  const setDelayBase = (delay) => {
    delayBase = delay;
  };
  return {
    computeNextBackoffDelay,
    setDelayBase
  };
};

// ../../node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js
var createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
  const getRetryCount = () => retryCount;
  const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY2, retryDelay);
  const getRetryCost = () => retryCost;
  return {
    getRetryCount,
    getRetryDelay,
    getRetryCost
  };
};

// ../../node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
var StandardRetryStrategy3 = class {
  constructor(maxAttempts) {
    this.maxAttempts = maxAttempts;
    this.mode = RETRY_MODES2.STANDARD;
    this.capacity = INITIAL_RETRY_TOKENS2;
    this.retryBackoffStrategy = getDefaultRetryBackoffStrategy2();
    this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
  }
  async acquireInitialRetryToken(retryTokenScope) {
    return createDefaultRetryToken({
      retryDelay: DEFAULT_RETRY_DELAY_BASE2,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(token, errorInfo) {
    const maxAttempts = await this.getMaxAttempts();
    if (this.shouldRetry(token, errorInfo, maxAttempts)) {
      const errorType = errorInfo.errorType;
      this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE2 : DEFAULT_RETRY_DELAY_BASE2);
      const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
      const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
      const capacityCost = this.getCapacityCost(errorType);
      this.capacity -= capacityCost;
      return createDefaultRetryToken({
        retryDelay,
        retryCount: token.getRetryCount() + 1,
        retryCost: capacityCost
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(token) {
    this.capacity = Math.max(INITIAL_RETRY_TOKENS2, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT2));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch (error) {
      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS2}`);
      return DEFAULT_MAX_ATTEMPTS2;
    }
  }
  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
    const attempts = tokenToRenew.getRetryCount() + 1;
    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
  }
  getCapacityCost(errorType) {
    return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST2 : RETRY_COST2;
  }
  isRetryableError(errorType) {
    return errorType === "THROTTLING" || errorType === "TRANSIENT";
  }
};

// ../../node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
var AdaptiveRetryStrategy2 = class {
  constructor(maxAttemptsProvider, options) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES2.ADAPTIVE;
    const { rateLimiter } = options ?? {};
    this.rateLimiter = rateLimiter ?? new DefaultRateLimiter2();
    this.standardRetryStrategy = new StandardRetryStrategy3(maxAttemptsProvider);
  }
  async acquireInitialRetryToken(retryTokenScope) {
    await this.rateLimiter.getSendToken();
    return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    this.rateLimiter.updateClientSendingRate(errorInfo);
    return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
  }
  recordSuccess(token) {
    this.rateLimiter.updateClientSendingRate({});
    this.standardRetryStrategy.recordSuccess(token);
  }
};

// ../../node_modules/@smithy/middleware-retry/dist-es/util.js
var asSdkError2 = (error) => {
  if (error instanceof Error)
    return error;
  if (error instanceof Object)
    return Object.assign(new Error(), error);
  if (typeof error === "string")
    return new Error(error);
  return new Error(`AWS SDK error wrapper for ${error}`);
};

// ../../node_modules/@smithy/middleware-retry/dist-es/configurations.js
var ENV_MAX_ATTEMPTS2 = "AWS_MAX_ATTEMPTS";
var CONFIG_MAX_ATTEMPTS2 = "max_attempts";
var NODE_MAX_ATTEMPT_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => {
    const value = env3[ENV_MAX_ATTEMPTS2];
    if (!value)
      return void 0;
    const maxAttempt = parseInt(value);
    if (Number.isNaN(maxAttempt)) {
      throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS2} mast be a number, got "${value}"`);
    }
    return maxAttempt;
  },
  configFileSelector: (profile) => {
    const value = profile[CONFIG_MAX_ATTEMPTS2];
    if (!value)
      return void 0;
    const maxAttempt = parseInt(value);
    if (Number.isNaN(maxAttempt)) {
      throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS2} mast be a number, got "${value}"`);
    }
    return maxAttempt;
  },
  default: DEFAULT_MAX_ATTEMPTS2
};
var resolveRetryConfig2 = (input) => {
  const { retryStrategy } = input;
  const maxAttempts = normalizeProvider2(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS2);
  return {
    ...input,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider2(input.retryMode)();
      if (retryMode === RETRY_MODES2.ADAPTIVE) {
        return new AdaptiveRetryStrategy2(maxAttempts);
      }
      return new StandardRetryStrategy3(maxAttempts);
    }
  };
};
var ENV_RETRY_MODE2 = "AWS_RETRY_MODE";
var CONFIG_RETRY_MODE2 = "retry_mode";
var NODE_RETRY_MODE_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => env3[ENV_RETRY_MODE2],
  configFileSelector: (profile) => profile[CONFIG_RETRY_MODE2],
  default: DEFAULT_RETRY_MODE2
};

// ../../node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
init_esm_node();
var retryMiddleware2 = (options) => (next, context) => async (args) => {
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV22(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
    let lastError = new Error();
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request: request3 } = args;
    if (HttpRequest2.isInstance(request3)) {
      request3.headers[INVOCATION_ID_HEADER2] = v4_default();
    }
    while (true) {
      try {
        if (HttpRequest2.isInstance(request3)) {
          request3.headers[REQUEST_HEADER2] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response, output } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output.$metadata.attempts = attempts + 1;
        output.$metadata.totalRetryDelay = totalRetryDelay;
        return { response, output };
      } catch (e10) {
        const retryErrorInfo = getRetryErrorInfo(e10);
        lastError = asSdkError2(e10);
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay = retryToken.getRetryDelay();
        totalRetryDelay += delay;
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy?.mode)
      context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
};
var isRetryStrategyV22 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
var getRetryErrorInfo = (error) => {
  const errorInfo = {
    errorType: getRetryErrorType2(error)
  };
  const retryAfterHint = getRetryAfterHint2(error.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
};
var getRetryErrorType2 = (error) => {
  if (isThrottlingError2(error))
    return "THROTTLING";
  if (isTransientError2(error))
    return "TRANSIENT";
  if (isServerError2(error))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
};
var retryMiddlewareOptions2 = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
var getRetryPlugin2 = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware2(options), retryMiddlewareOptions2);
  }
});
var getRetryAfterHint2 = (response) => {
  if (!HttpResponse2.isInstance(response))
    return;
  const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1e3);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
};

// ../../node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
var NoOpLogger2 = class {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
};

// ../../node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
var constructStack2 = () => {
  let absoluteEntries = [];
  let relativeEntries = [];
  const entriesNameSet = /* @__PURE__ */ new Set();
  const sort = (entries) => entries.sort((a10, b10) => stepWeights2[b10.step] - stepWeights2[a10.step] || priorityWeights2[b10.priority || "normal"] - priorityWeights2[a10.priority || "normal"]);
  const removeByName = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.name && entry.name === toRemove) {
        isRemoved = true;
        entriesNameSet.delete(toRemove);
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const removeByReference = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        if (entry.name)
          entriesNameSet.delete(entry.name);
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const cloneTo = (toStack) => {
    absoluteEntries.forEach((entry) => {
      toStack.add(entry.middleware, { ...entry });
    });
    relativeEntries.forEach((entry) => {
      toStack.addRelativeTo(entry.middleware, { ...entry });
    });
    return toStack;
  };
  const expandRelativeMiddlewareList = (from) => {
    const expandedMiddlewareList = [];
    from.before.forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    expandedMiddlewareList.push(from);
    from.after.reverse().forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    return expandedMiddlewareList;
  };
  const getMiddlewareList = (debug = false) => {
    const normalizedAbsoluteEntries = [];
    const normalizedRelativeEntries = [];
    const normalizedEntriesNameMap = {};
    absoluteEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      if (normalizedEntry.name)
        normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      if (normalizedEntry.name)
        normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach((entry) => {
      if (entry.toMiddleware) {
        const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === void 0) {
          if (debug) {
            return;
          }
          throw new Error(`${entry.toMiddleware} is not found when adding ${entry.name || "anonymous"} middleware ${entry.relation} ${entry.toMiddleware}`);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
      wholeList.push(...expandedMiddlewareList);
      return wholeList;
    }, []);
    return mainChain;
  };
  const stack = {
    add: (middleware, options = {}) => {
      const { name, override } = options;
      const entry = {
        step: "initialize",
        priority: "normal",
        middleware,
        ...options
      };
      if (name) {
        if (entriesNameSet.has(name)) {
          if (!override)
            throw new Error(`Duplicate middleware name '${name}'`);
          const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === name);
          const toOverride = absoluteEntries[toOverrideIndex];
          if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
            throw new Error(`"${name}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by same-name middleware with ${entry.priority} priority in ${entry.step} step.`);
          }
          absoluteEntries.splice(toOverrideIndex, 1);
        }
        entriesNameSet.add(name);
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: (middleware, options) => {
      const { name, override } = options;
      const entry = {
        middleware,
        ...options
      };
      if (name) {
        if (entriesNameSet.has(name)) {
          if (!override)
            throw new Error(`Duplicate middleware name '${name}'`);
          const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === name);
          const toOverride = relativeEntries[toOverrideIndex];
          if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
            throw new Error(`"${name}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by same-name middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
          }
          relativeEntries.splice(toOverrideIndex, 1);
        }
        entriesNameSet.add(name);
      }
      relativeEntries.push(entry);
    },
    clone: () => cloneTo(constructStack2()),
    use: (plugin) => {
      plugin.applyToStack(stack);
    },
    remove: (toRemove) => {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const { tags, name } = entry;
        if (tags && tags.includes(toRemove)) {
          if (name)
            entriesNameSet.delete(name);
          isRemoved = true;
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: (from) => {
      const cloned = cloneTo(constructStack2());
      cloned.use(from);
      return cloned;
    },
    applyToStack: cloneTo,
    identify: () => {
      return getMiddlewareList(true).map((mw) => {
        return mw.name + ": " + (mw.tags || []).join(",");
      });
    },
    resolve: (handler, context) => {
      for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
        handler = middleware(handler, context);
      }
      return handler;
    }
  };
  return stack;
};
var stepWeights2 = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
var priorityWeights2 = {
  high: 3,
  normal: 2,
  low: 1
};

// ../../node_modules/@smithy/smithy-client/dist-es/client.js
var Client2 = class {
  constructor(config) {
    this.middlewareStack = constructStack2();
    this.config = config;
  }
  send(command, optionsOrCb, cb) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
    const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
    if (callback) {
      handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
      });
    } else {
      return handler(command).then((result) => result.output);
    }
  }
  destroy() {
    if (this.config.requestHandler.destroy)
      this.config.requestHandler.destroy();
  }
};

// ../../node_modules/@smithy/util-base64/dist-es/fromBase64.js
var BASE64_REGEX2 = /^[A-Za-z0-9+/]*={0,2}$/;
var fromBase642 = (input) => {
  if (input.length * 3 % 4 !== 0) {
    throw new TypeError(`Incorrect padding on base64 string.`);
  }
  if (!BASE64_REGEX2.exec(input)) {
    throw new TypeError(`Invalid base64 string.`);
  }
  const buffer = fromString2(input, "base64");
  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};

// ../../node_modules/@smithy/util-base64/dist-es/toBase64.js
var toBase642 = (input) => fromArrayBuffer2(input.buffer, input.byteOffset, input.byteLength).toString("base64");

// ../../node_modules/@smithy/util-stream/dist-es/blob/transforms.js
function transformToString(payload, encoding = "utf-8") {
  if (encoding === "base64") {
    return toBase642(payload);
  }
  return toUtf85(payload);
}
function transformFromString(str, encoding) {
  if (encoding === "base64") {
    return Uint8ArrayBlobAdapter.mutate(fromBase642(str));
  }
  return Uint8ArrayBlobAdapter.mutate(fromUtf85(str));
}

// ../../node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
var Uint8ArrayBlobAdapter = class _Uint8ArrayBlobAdapter extends Uint8Array {
  static fromString(source, encoding = "utf-8") {
    switch (typeof source) {
      case "string":
        return transformFromString(source, encoding);
      default:
        throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(source) {
    Object.setPrototypeOf(source, _Uint8ArrayBlobAdapter.prototype);
    return source;
  }
  transformToString(encoding = "utf-8") {
    return transformToString(this, encoding);
  }
};

// ../../node_modules/@smithy/querystring-builder/dist-es/index.js
function buildQueryString2(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = escapeUri2(key);
    if (Array.isArray(value)) {
      for (let i10 = 0, iLen = value.length; i10 < iLen; i10++) {
        parts.push(`${key}=${escapeUri2(value[i10])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri2(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}

// ../../node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js
var import_http3 = require("http");
var import_https2 = require("https");

// ../../node_modules/@smithy/node-http-handler/dist-es/constants.js
var NODEJS_TIMEOUT_ERROR_CODES4 = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

// ../../node_modules/@smithy/node-http-handler/dist-es/get-transformed-headers.js
var getTransformedHeaders2 = (headers) => {
  const transformedHeaders = {};
  for (const name of Object.keys(headers)) {
    const headerValues = headers[name];
    transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
  }
  return transformedHeaders;
};

// ../../node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js
var setConnectionTimeout2 = (request3, reject, timeoutInMs = 0) => {
  if (!timeoutInMs) {
    return;
  }
  const timeoutId = setTimeout(() => {
    request3.destroy();
    reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
      name: "TimeoutError"
    }));
  }, timeoutInMs);
  request3.on("socket", (socket) => {
    if (socket.connecting) {
      socket.on("connect", () => {
        clearTimeout(timeoutId);
      });
    } else {
      clearTimeout(timeoutId);
    }
  });
};

// ../../node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js
var setSocketKeepAlive = (request3, { keepAlive, keepAliveMsecs }) => {
  if (keepAlive !== true) {
    return;
  }
  request3.on("socket", (socket) => {
    socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
  });
};

// ../../node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js
var setSocketTimeout2 = (request3, reject, timeoutInMs = 0) => {
  request3.setTimeout(timeoutInMs, () => {
    request3.destroy();
    reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
  });
};

// ../../node_modules/@smithy/node-http-handler/dist-es/write-request-body.js
var import_stream3 = require("stream");
var MIN_WAIT_TIME = 1e3;
async function writeRequestBody2(httpRequest3, request3, maxContinueTimeoutMs = MIN_WAIT_TIME) {
  const headers = request3.headers ?? {};
  const expect = headers["Expect"] || headers["expect"];
  let timeoutId = -1;
  let hasError = false;
  if (expect === "100-continue") {
    await Promise.race([
      new Promise((resolve) => {
        timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
      }),
      new Promise((resolve) => {
        httpRequest3.on("continue", () => {
          clearTimeout(timeoutId);
          resolve();
        });
        httpRequest3.on("error", () => {
          hasError = true;
          clearTimeout(timeoutId);
          resolve();
        });
      })
    ]);
  }
  if (!hasError) {
    writeBody2(httpRequest3, request3.body);
  }
}
function writeBody2(httpRequest3, body) {
  if (body instanceof import_stream3.Readable) {
    body.pipe(httpRequest3);
  } else if (body) {
    httpRequest3.end(Buffer.from(body));
  } else {
    httpRequest3.end();
  }
}

// ../../node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js
var NodeHttpHandler2 = class {
  constructor(options) {
    this.metadata = { handlerProtocol: "http/1.1" };
    this.configProvider = new Promise((resolve, reject) => {
      if (typeof options === "function") {
        options().then((_options) => {
          resolve(this.resolveDefaultConfig(_options));
        }).catch(reject);
      } else {
        resolve(this.resolveDefaultConfig(options));
      }
    });
  }
  resolveDefaultConfig(options) {
    const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
    const keepAlive = true;
    const maxSockets = 50;
    return {
      connectionTimeout,
      requestTimeout: requestTimeout ?? socketTimeout,
      httpAgent: httpAgent || new import_http3.Agent({ keepAlive, maxSockets }),
      httpsAgent: httpsAgent || new import_https2.Agent({ keepAlive, maxSockets })
    };
  }
  destroy() {
    this.config?.httpAgent?.destroy();
    this.config?.httpsAgent?.destroy();
  }
  async handle(request3, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    return new Promise((_resolve, _reject) => {
      let writeRequestBodyPromise = void 0;
      const resolve = async (arg) => {
        await writeRequestBodyPromise;
        _resolve(arg);
      };
      const reject = async (arg) => {
        await writeRequestBodyPromise;
        _reject(arg);
      };
      if (!this.config) {
        throw new Error("Node HTTP request handler config is not resolved");
      }
      if (abortSignal?.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        reject(abortError);
        return;
      }
      const isSSL = request3.protocol === "https:";
      const queryString = buildQueryString2(request3.query || {});
      let auth = void 0;
      if (request3.username != null || request3.password != null) {
        const username = request3.username ?? "";
        const password = request3.password ?? "";
        auth = `${username}:${password}`;
      }
      let path = request3.path;
      if (queryString) {
        path += `?${queryString}`;
      }
      if (request3.fragment) {
        path += `#${request3.fragment}`;
      }
      const nodeHttpsOptions = {
        headers: request3.headers,
        host: request3.hostname,
        method: request3.method,
        path,
        port: request3.port,
        agent: isSSL ? this.config.httpsAgent : this.config.httpAgent,
        auth
      };
      const requestFunc = isSSL ? import_https2.request : import_http3.request;
      const req = requestFunc(nodeHttpsOptions, (res) => {
        const httpResponse = new HttpResponse2({
          statusCode: res.statusCode || -1,
          reason: res.statusMessage,
          headers: getTransformedHeaders2(res.headers),
          body: res
        });
        resolve({ response: httpResponse });
      });
      req.on("error", (err) => {
        if (NODEJS_TIMEOUT_ERROR_CODES4.includes(err.code)) {
          reject(Object.assign(err, { name: "TimeoutError" }));
        } else {
          reject(err);
        }
      });
      setConnectionTimeout2(req, reject, this.config.connectionTimeout);
      setSocketTimeout2(req, reject, this.config.requestTimeout);
      if (abortSignal) {
        abortSignal.onabort = () => {
          req.abort();
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
      }
      const httpAgent = nodeHttpsOptions.agent;
      if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
        setSocketKeepAlive(req, {
          keepAlive: httpAgent.keepAlive,
          keepAliveMsecs: httpAgent.keepAliveMsecs
        });
      }
      writeRequestBodyPromise = writeRequestBody2(req, request3, this.config.requestTimeout).catch(_reject);
    });
  }
};

// ../../node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
var NodeHttp2ConnectionPool = class {
  constructor(sessions) {
    this.sessions = [];
    this.sessions = sessions ?? [];
  }
  poll() {
    if (this.sessions.length > 0) {
      return this.sessions.shift();
    }
  }
  offerLast(session) {
    this.sessions.push(session);
  }
  contains(session) {
    return this.sessions.includes(session);
  }
  remove(session) {
    this.sessions = this.sessions.filter((s10) => s10 !== session);
  }
  [Symbol.iterator]() {
    return this.sessions[Symbol.iterator]();
  }
  destroy(connection) {
    for (const session of this.sessions) {
      if (session === connection) {
        if (!session.destroyed) {
          session.destroy();
        }
      }
    }
  }
};

// ../../node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js
var import_stream4 = require("stream");
var Collector2 = class extends import_stream4.Writable {
  constructor() {
    super(...arguments);
    this.bufferedBytes = [];
  }
  _write(chunk2, encoding, callback) {
    this.bufferedBytes.push(chunk2);
    callback();
  }
};

// ../../node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js
var streamCollector2 = (stream) => new Promise((resolve, reject) => {
  const collector = new Collector2();
  stream.pipe(collector);
  stream.on("error", (err) => {
    collector.end();
    reject(err);
  });
  collector.on("error", reject);
  collector.on("finish", function() {
    const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
    resolve(bytes);
  });
});

// ../../node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
var collectBody6 = async (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Uint8ArrayBlobAdapter.mutate(streamBody);
  }
  if (!streamBody) {
    return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
  }
  const fromContext = context.streamCollector(streamBody);
  return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

// ../../node_modules/@smithy/smithy-client/dist-es/command.js
var Command2 = class {
  constructor() {
    this.middlewareStack = constructStack2();
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/constants.js
var SENSITIVE_STRING2 = "***SensitiveInformation***";

// ../../node_modules/@smithy/smithy-client/dist-es/parse-utils.js
var expectBoolean2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "number") {
    if (value === 0 || value === 1) {
      logger2.warn(stackTraceWarning2(`Expected boolean, got ${typeof value}: ${value}`));
    }
    if (value === 0) {
      return false;
    }
    if (value === 1) {
      return true;
    }
  }
  if (typeof value === "string") {
    const lower = value.toLowerCase();
    if (lower === "false" || lower === "true") {
      logger2.warn(stackTraceWarning2(`Expected boolean, got ${typeof value}: ${value}`));
    }
    if (lower === "false") {
      return false;
    }
    if (lower === "true") {
      return true;
    }
  }
  if (typeof value === "boolean") {
    return value;
  }
  throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
var expectNumber2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    if (!Number.isNaN(parsed)) {
      if (String(parsed) !== String(value)) {
        logger2.warn(stackTraceWarning2(`Expected number but observed string: ${value}`));
      }
      return parsed;
    }
  }
  if (typeof value === "number") {
    return value;
  }
  throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
var MAX_FLOAT2 = Math.ceil(2 ** 127 * (2 - 2 ** -23));
var expectFloat322 = (value) => {
  const expected = expectNumber2(value);
  if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
    if (Math.abs(expected) > MAX_FLOAT2) {
      throw new TypeError(`Expected 32-bit float, got ${value}`);
    }
  }
  return expected;
};
var expectLong2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (Number.isInteger(value) && !Number.isNaN(value)) {
    return value;
  }
  throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
var expectInt322 = (value) => expectSizedInt2(value, 32);
var expectShort2 = (value) => expectSizedInt2(value, 16);
var expectByte2 = (value) => expectSizedInt2(value, 8);
var expectSizedInt2 = (value, size) => {
  const expected = expectLong2(value);
  if (expected !== void 0 && castInt2(expected, size) !== expected) {
    throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
  }
  return expected;
};
var castInt2 = (value, size) => {
  switch (size) {
    case 32:
      return Int32Array.of(value)[0];
    case 16:
      return Int16Array.of(value)[0];
    case 8:
      return Int8Array.of(value)[0];
  }
};
var expectNonNull2 = (value, location) => {
  if (value === null || value === void 0) {
    if (location) {
      throw new TypeError(`Expected a non-null value for ${location}`);
    }
    throw new TypeError("Expected a non-null value");
  }
  return value;
};
var expectObject2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "object" && !Array.isArray(value)) {
    return value;
  }
  const receivedType = Array.isArray(value) ? "array" : typeof value;
  throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
var expectString2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    return value;
  }
  if (["boolean", "number", "bigint"].includes(typeof value)) {
    logger2.warn(stackTraceWarning2(`Expected string, got ${typeof value}: ${value}`));
    return String(value);
  }
  throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
var expectUnion = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  const asObject = expectObject2(value);
  const setKeys = Object.entries(asObject).filter(([, v6]) => v6 != null).map(([k10]) => k10);
  if (setKeys.length === 0) {
    throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
  }
  if (setKeys.length > 1) {
    throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
  }
  return asObject;
};
var strictParseFloat322 = (value) => {
  if (typeof value == "string") {
    return expectFloat322(parseNumber2(value));
  }
  return expectFloat322(value);
};
var NUMBER_REGEX2 = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
var parseNumber2 = (value) => {
  const matches = value.match(NUMBER_REGEX2);
  if (matches === null || matches[0].length !== value.length) {
    throw new TypeError(`Expected real number, got implicit NaN`);
  }
  return parseFloat(value);
};
var limitedParseDouble = (value) => {
  if (typeof value == "string") {
    return parseFloatString(value);
  }
  return expectNumber2(value);
};
var parseFloatString = (value) => {
  switch (value) {
    case "NaN":
      return NaN;
    case "Infinity":
      return Infinity;
    case "-Infinity":
      return -Infinity;
    default:
      throw new Error(`Unable to parse float value: ${value}`);
  }
};
var strictParseInt322 = (value) => {
  if (typeof value === "string") {
    return expectInt322(parseNumber2(value));
  }
  return expectInt322(value);
};
var strictParseShort2 = (value) => {
  if (typeof value === "string") {
    return expectShort2(parseNumber2(value));
  }
  return expectShort2(value);
};
var strictParseByte2 = (value) => {
  if (typeof value === "string") {
    return expectByte2(parseNumber2(value));
  }
  return expectByte2(value);
};
var stackTraceWarning2 = (message) => {
  return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s10) => !s10.includes("stackTraceWarning")).join("\n");
};
var logger2 = {
  warn: console.warn
};

// ../../node_modules/@smithy/smithy-client/dist-es/date-utils.js
var MONTHS2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var RFC33392 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
var RFC3339_WITH_OFFSET2 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
var parseRfc3339DateTimeWithOffset2 = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value !== "string") {
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  }
  const match = RFC3339_WITH_OFFSET2.exec(value);
  if (!match) {
    throw new TypeError("Invalid RFC-3339 date-time value");
  }
  const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
  const year = strictParseShort2(stripLeadingZeroes2(yearStr));
  const month = parseDateValue2(monthStr, "month", 1, 12);
  const day = parseDateValue2(dayStr, "day", 1, 31);
  const date2 = buildDate2(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  if (offsetStr.toUpperCase() != "Z") {
    date2.setTime(date2.getTime() - parseOffsetToMilliseconds2(offsetStr));
  }
  return date2;
};
var IMF_FIXDATE2 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var RFC_850_DATE2 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var ASC_TIME2 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
var buildDate2 = (year, month, day, time) => {
  const adjustedMonth = month - 1;
  validateDayOfMonth2(year, adjustedMonth, day);
  return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue2(time.hours, "hour", 0, 23), parseDateValue2(time.minutes, "minute", 0, 59), parseDateValue2(time.seconds, "seconds", 0, 60), parseMilliseconds2(time.fractionalMilliseconds)));
};
var FIFTY_YEARS_IN_MILLIS2 = 50 * 365 * 24 * 60 * 60 * 1e3;
var DAYS_IN_MONTH2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var validateDayOfMonth2 = (year, month, day) => {
  let maxDays = DAYS_IN_MONTH2[month];
  if (month === 1 && isLeapYear2(year)) {
    maxDays = 29;
  }
  if (day > maxDays) {
    throw new TypeError(`Invalid day for ${MONTHS2[month]} in ${year}: ${day}`);
  }
};
var isLeapYear2 = (year) => {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
var parseDateValue2 = (value, type, lower, upper) => {
  const dateVal = strictParseByte2(stripLeadingZeroes2(value));
  if (dateVal < lower || dateVal > upper) {
    throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
  }
  return dateVal;
};
var parseMilliseconds2 = (value) => {
  if (value === null || value === void 0) {
    return 0;
  }
  return strictParseFloat322("0." + value) * 1e3;
};
var parseOffsetToMilliseconds2 = (value) => {
  const directionStr = value[0];
  let direction = 1;
  if (directionStr == "+") {
    direction = 1;
  } else if (directionStr == "-") {
    direction = -1;
  } else {
    throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
  }
  const hour = Number(value.substring(1, 3));
  const minute = Number(value.substring(4, 6));
  return direction * (hour * 60 + minute) * 60 * 1e3;
};
var stripLeadingZeroes2 = (value) => {
  let idx = 0;
  while (idx < value.length - 1 && value.charAt(idx) === "0") {
    idx++;
  }
  if (idx === 0) {
    return value;
  }
  return value.slice(idx);
};

// ../../node_modules/@smithy/smithy-client/dist-es/exceptions.js
var ServiceException2 = class _ServiceException extends Error {
  constructor(options) {
    super(options.message);
    Object.setPrototypeOf(this, _ServiceException.prototype);
    this.name = options.name;
    this.$fault = options.$fault;
    this.$metadata = options.$metadata;
  }
};
var decorateServiceException2 = (exception, additions = {}) => {
  Object.entries(additions).filter(([, v6]) => v6 !== void 0).forEach(([k10, v6]) => {
    if (exception[k10] == void 0 || exception[k10] === "") {
      exception[k10] = v6;
    }
  });
  const message = exception.message || exception.Message || "UnknownError";
  exception.message = message;
  delete exception.Message;
  return exception;
};

// ../../node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
var throwDefaultError2 = ({ output, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata7(output);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
  const response = new exceptionCtor({
    name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException2(response, parsedBody);
};
var withBaseException = (ExceptionCtor) => {
  return ({ output, parsedBody, errorCode }) => {
    throwDefaultError2({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
  };
};
var deserializeMetadata7 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});

// ../../node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
var loadConfigsForDefaultMode2 = (mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
var warningEmitted2 = false;
var emitWarningIfUnsupportedVersion2 = (version) => {
  if (version && !warningEmitted2 && parseInt(version.substring(1, version.indexOf("."))) < 14) {
    warningEmitted2 = true;
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent2(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c10) {
    return "%" + c10.charCodeAt(0).toString(16).toUpperCase();
  });
}

// ../../node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js
var getValueFromTextNode2 = (obj) => {
  const textNodeName = "#text";
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
      obj[key] = obj[key][textNodeName];
    } else if (typeof obj[key] === "object" && obj[key] !== null) {
      obj[key] = getValueFromTextNode2(obj[key]);
    }
  }
  return obj;
};

// ../../node_modules/@smithy/smithy-client/dist-es/lazy-json.js
var StringWrapper2 = function() {
  const Class = Object.getPrototypeOf(this).constructor;
  const Constructor = Function.bind.apply(String, [null, ...arguments]);
  const instance = new Constructor();
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
};
StringWrapper2.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper2,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(StringWrapper2, String);

// ../../node_modules/@smithy/smithy-client/dist-es/object-mapping.js
function map5(arg0, arg1, arg2) {
  let target;
  let filter;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter = arg1;
      instructions = arg2;
      return mapWithFilter2(target, filter, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    applyInstruction(target, null, instructions, key);
  }
  return target;
}
var take = (source, instructions) => {
  const out = {};
  for (const key in instructions) {
    applyInstruction(out, source, instructions, key);
  }
  return out;
};
var mapWithFilter2 = (target, filter, instructions) => {
  return map5(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
    if (Array.isArray(value)) {
      _instructions[key] = value;
    } else {
      if (typeof value === "function") {
        _instructions[key] = [filter, value()];
      } else {
        _instructions[key] = [filter, value];
      }
    }
    return _instructions;
  }, {}));
};
var applyInstruction = (target, source, instructions, targetKey) => {
  if (source !== null) {
    let instruction = instructions[targetKey];
    if (typeof instruction === "function") {
      instruction = [, instruction];
    }
    const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
    if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
      target[targetKey] = valueFn(source[sourceKey]);
    }
    return;
  }
  let [filter, value] = instructions[targetKey];
  if (typeof value === "function") {
    let _value;
    const defaultFilterPassed = filter === void 0 && (_value = value()) != null;
    const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
    if (defaultFilterPassed) {
      target[targetKey] = _value;
    } else if (customFilterPassed) {
      target[targetKey] = value();
    }
  } else {
    const defaultFilterPassed = filter === void 0 && value != null;
    const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
    if (defaultFilterPassed || customFilterPassed) {
      target[targetKey] = value;
    }
  }
};
var nonNullish = (_) => _ != null;
var pass = (_) => _;

// ../../node_modules/@smithy/smithy-client/dist-es/serde-json.js
var _json = (obj) => {
  if (obj == null) {
    return {};
  }
  if (Array.isArray(obj)) {
    return obj.filter((_) => _ != null);
  }
  if (typeof obj === "object") {
    const target = {};
    for (const key of Object.keys(obj)) {
      if (obj[key] == null) {
        continue;
      }
      target[key] = _json(obj[key]);
    }
    return target;
  }
  return obj;
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/models/DynamoDBServiceException.js
var DynamoDBServiceException = class _DynamoDBServiceException extends ServiceException2 {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _DynamoDBServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/models/models_0.js
var InternalServerError = class _InternalServerError extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "InternalServerError",
      $fault: "server",
      ...opts
    });
    this.name = "InternalServerError";
    this.$fault = "server";
    Object.setPrototypeOf(this, _InternalServerError.prototype);
  }
};
var RequestLimitExceeded = class _RequestLimitExceeded extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "RequestLimitExceeded",
      $fault: "client",
      ...opts
    });
    this.name = "RequestLimitExceeded";
    this.$fault = "client";
    Object.setPrototypeOf(this, _RequestLimitExceeded.prototype);
  }
};
var InvalidEndpointException = class _InvalidEndpointException extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "InvalidEndpointException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidEndpointException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidEndpointException.prototype);
    this.Message = opts.Message;
  }
};
var ProvisionedThroughputExceededException = class _ProvisionedThroughputExceededException extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "ProvisionedThroughputExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "ProvisionedThroughputExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ProvisionedThroughputExceededException.prototype);
  }
};
var ResourceNotFoundException3 = class _ResourceNotFoundException extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
  }
};
var ItemCollectionSizeLimitExceededException = class _ItemCollectionSizeLimitExceededException extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "ItemCollectionSizeLimitExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "ItemCollectionSizeLimitExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ItemCollectionSizeLimitExceededException.prototype);
  }
};
var TransactionConflictException = class _TransactionConflictException extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "TransactionConflictException",
      $fault: "client",
      ...opts
    });
    this.name = "TransactionConflictException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _TransactionConflictException.prototype);
  }
};
var AttributeValue;
(function(AttributeValue2) {
  AttributeValue2.visit = (value, visitor) => {
    if (value.S !== void 0)
      return visitor.S(value.S);
    if (value.N !== void 0)
      return visitor.N(value.N);
    if (value.B !== void 0)
      return visitor.B(value.B);
    if (value.SS !== void 0)
      return visitor.SS(value.SS);
    if (value.NS !== void 0)
      return visitor.NS(value.NS);
    if (value.BS !== void 0)
      return visitor.BS(value.BS);
    if (value.M !== void 0)
      return visitor.M(value.M);
    if (value.L !== void 0)
      return visitor.L(value.L);
    if (value.NULL !== void 0)
      return visitor.NULL(value.NULL);
    if (value.BOOL !== void 0)
      return visitor.BOOL(value.BOOL);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(AttributeValue || (AttributeValue = {}));
var ConditionalCheckFailedException = class _ConditionalCheckFailedException extends DynamoDBServiceException {
  constructor(opts) {
    super({
      name: "ConditionalCheckFailedException",
      $fault: "client",
      ...opts
    });
    this.name = "ConditionalCheckFailedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ConditionalCheckFailedException.prototype);
    this.Item = opts.Item;
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/protocols/Aws_json1_0.js
var se_BatchGetItemCommand = async (input, context) => {
  const headers = sharedHeaders("BatchGetItem");
  let body;
  body = JSON.stringify(se_BatchGetItemInput(input, context));
  return buildHttpRpcRequest4(context, headers, "/", void 0, body);
};
var se_BatchWriteItemCommand = async (input, context) => {
  const headers = sharedHeaders("BatchWriteItem");
  let body;
  body = JSON.stringify(se_BatchWriteItemInput(input, context));
  return buildHttpRpcRequest4(context, headers, "/", void 0, body);
};
var se_DeleteItemCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteItem");
  let body;
  body = JSON.stringify(se_DeleteItemInput(input, context));
  return buildHttpRpcRequest4(context, headers, "/", void 0, body);
};
var se_DescribeEndpointsCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeEndpoints");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest4(context, headers, "/", void 0, body);
};
var se_PutItemCommand = async (input, context) => {
  const headers = sharedHeaders("PutItem");
  let body;
  body = JSON.stringify(se_PutItemInput(input, context));
  return buildHttpRpcRequest4(context, headers, "/", void 0, body);
};
var se_QueryCommand = async (input, context) => {
  const headers = sharedHeaders("Query");
  let body;
  body = JSON.stringify(se_QueryInput(input, context));
  return buildHttpRpcRequest4(context, headers, "/", void 0, body);
};
var se_UpdateItemCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateItem");
  let body;
  body = JSON.stringify(se_UpdateItemInput(input, context));
  return buildHttpRpcRequest4(context, headers, "/", void 0, body);
};
var de_BatchGetItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_BatchGetItemCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = de_BatchGetItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return response;
};
var de_BatchGetItemCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode4(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await de_RequestLimitExceededRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError3({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_BatchWriteItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_BatchWriteItemCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = de_BatchWriteItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return response;
};
var de_BatchWriteItemCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode4(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
    case "ItemCollectionSizeLimitExceededException":
    case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
      throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await de_RequestLimitExceededRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError3({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DeleteItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DeleteItemCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = de_DeleteItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return response;
};
var de_DeleteItemCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode4(output, parsedOutput.body);
  switch (errorCode) {
    case "ConditionalCheckFailedException":
    case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
      throw await de_ConditionalCheckFailedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
    case "ItemCollectionSizeLimitExceededException":
    case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
      throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await de_RequestLimitExceededRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "TransactionConflictException":
    case "com.amazonaws.dynamodb#TransactionConflictException":
      throw await de_TransactionConflictExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError3({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_DescribeEndpointsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_DescribeEndpointsCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return response;
};
var de_DescribeEndpointsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode4(output, parsedOutput.body);
  const parsedBody = parsedOutput.body;
  return throwDefaultError3({
    output,
    parsedBody,
    errorCode
  });
};
var de_PutItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_PutItemCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = de_PutItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return response;
};
var de_PutItemCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode4(output, parsedOutput.body);
  switch (errorCode) {
    case "ConditionalCheckFailedException":
    case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
      throw await de_ConditionalCheckFailedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
    case "ItemCollectionSizeLimitExceededException":
    case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
      throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await de_RequestLimitExceededRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "TransactionConflictException":
    case "com.amazonaws.dynamodb#TransactionConflictException":
      throw await de_TransactionConflictExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError3({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_QueryCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_QueryCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = de_QueryOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return response;
};
var de_QueryCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode4(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await de_RequestLimitExceededRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError3({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_UpdateItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_UpdateItemCommandError(output, context);
  }
  const data = await parseBody6(output.body, context);
  let contents = {};
  contents = de_UpdateItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata8(output),
    ...contents
  };
  return response;
};
var de_UpdateItemCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode4(output, parsedOutput.body);
  switch (errorCode) {
    case "ConditionalCheckFailedException":
    case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
      throw await de_ConditionalCheckFailedExceptionRes(parsedOutput, context);
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
    case "ItemCollectionSizeLimitExceededException":
    case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
      throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await de_RequestLimitExceededRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "TransactionConflictException":
    case "com.amazonaws.dynamodb#TransactionConflictException":
      throw await de_TransactionConflictExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError3({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_ConditionalCheckFailedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_ConditionalCheckFailedException(body, context);
  const exception = new ConditionalCheckFailedException({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_InternalServerErrorRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InternalServerError({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_InvalidEndpointExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidEndpointException({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_ItemCollectionSizeLimitExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ItemCollectionSizeLimitExceededException({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_ProvisionedThroughputExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ProvisionedThroughputExceededException({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_RequestLimitExceededRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new RequestLimitExceeded({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ResourceNotFoundException3({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_TransactionConflictExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new TransactionConflictException({
    $metadata: deserializeMetadata8(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var se_AttributeUpdates = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_AttributeValueUpdate(value, context);
    return acc;
  }, {});
};
var se_AttributeValue = (input, context) => {
  return AttributeValue.visit(input, {
    B: (value) => ({ B: context.base64Encoder(value) }),
    BOOL: (value) => ({ BOOL: value }),
    BS: (value) => ({ BS: se_BinarySetAttributeValue(value, context) }),
    L: (value) => ({ L: se_ListAttributeValue(value, context) }),
    M: (value) => ({ M: se_MapAttributeValue(value, context) }),
    N: (value) => ({ N: value }),
    NS: (value) => ({ NS: _json(value) }),
    NULL: (value) => ({ NULL: value }),
    S: (value) => ({ S: value }),
    SS: (value) => ({ SS: _json(value) }),
    _: (name, value) => ({ name: value })
  });
};
var se_AttributeValueList = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return se_AttributeValue(entry, context);
  });
};
var se_AttributeValueUpdate = (input, context) => {
  return take(input, {
    Action: [],
    Value: (_) => se_AttributeValue(_, context)
  });
};
var se_BatchGetItemInput = (input, context) => {
  return take(input, {
    RequestItems: (_) => se_BatchGetRequestMap(_, context),
    ReturnConsumedCapacity: []
  });
};
var se_BatchGetRequestMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_KeysAndAttributes(value, context);
    return acc;
  }, {});
};
var se_BatchWriteItemInput = (input, context) => {
  return take(input, {
    RequestItems: (_) => se_BatchWriteItemRequestMap(_, context),
    ReturnConsumedCapacity: [],
    ReturnItemCollectionMetrics: []
  });
};
var se_BatchWriteItemRequestMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_WriteRequests(value, context);
    return acc;
  }, {});
};
var se_BinarySetAttributeValue = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return context.base64Encoder(entry);
  });
};
var se_Condition = (input, context) => {
  return take(input, {
    AttributeValueList: (_) => se_AttributeValueList(_, context),
    ComparisonOperator: []
  });
};
var se_DeleteItemInput = (input, context) => {
  return take(input, {
    ConditionExpression: [],
    ConditionalOperator: [],
    Expected: (_) => se_ExpectedAttributeMap(_, context),
    ExpressionAttributeNames: _json,
    ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
    Key: (_) => se_Key(_, context),
    ReturnConsumedCapacity: [],
    ReturnItemCollectionMetrics: [],
    ReturnValues: [],
    ReturnValuesOnConditionCheckFailure: [],
    TableName: []
  });
};
var se_DeleteRequest = (input, context) => {
  return take(input, {
    Key: (_) => se_Key(_, context)
  });
};
var se_ExpectedAttributeMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_ExpectedAttributeValue(value, context);
    return acc;
  }, {});
};
var se_ExpectedAttributeValue = (input, context) => {
  return take(input, {
    AttributeValueList: (_) => se_AttributeValueList(_, context),
    ComparisonOperator: [],
    Exists: [],
    Value: (_) => se_AttributeValue(_, context)
  });
};
var se_ExpressionAttributeValueMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_AttributeValue(value, context);
    return acc;
  }, {});
};
var se_FilterConditionMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_Condition(value, context);
    return acc;
  }, {});
};
var se_Key = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_AttributeValue(value, context);
    return acc;
  }, {});
};
var se_KeyConditions = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_Condition(value, context);
    return acc;
  }, {});
};
var se_KeyList = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return se_Key(entry, context);
  });
};
var se_KeysAndAttributes = (input, context) => {
  return take(input, {
    AttributesToGet: _json,
    ConsistentRead: [],
    ExpressionAttributeNames: _json,
    Keys: (_) => se_KeyList(_, context),
    ProjectionExpression: []
  });
};
var se_ListAttributeValue = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return se_AttributeValue(entry, context);
  });
};
var se_MapAttributeValue = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_AttributeValue(value, context);
    return acc;
  }, {});
};
var se_PutItemInput = (input, context) => {
  return take(input, {
    ConditionExpression: [],
    ConditionalOperator: [],
    Expected: (_) => se_ExpectedAttributeMap(_, context),
    ExpressionAttributeNames: _json,
    ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
    Item: (_) => se_PutItemInputAttributeMap(_, context),
    ReturnConsumedCapacity: [],
    ReturnItemCollectionMetrics: [],
    ReturnValues: [],
    ReturnValuesOnConditionCheckFailure: [],
    TableName: []
  });
};
var se_PutItemInputAttributeMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_AttributeValue(value, context);
    return acc;
  }, {});
};
var se_PutRequest = (input, context) => {
  return take(input, {
    Item: (_) => se_PutItemInputAttributeMap(_, context)
  });
};
var se_QueryInput = (input, context) => {
  return take(input, {
    AttributesToGet: _json,
    ConditionalOperator: [],
    ConsistentRead: [],
    ExclusiveStartKey: (_) => se_Key(_, context),
    ExpressionAttributeNames: _json,
    ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
    FilterExpression: [],
    IndexName: [],
    KeyConditionExpression: [],
    KeyConditions: (_) => se_KeyConditions(_, context),
    Limit: [],
    ProjectionExpression: [],
    QueryFilter: (_) => se_FilterConditionMap(_, context),
    ReturnConsumedCapacity: [],
    ScanIndexForward: [],
    Select: [],
    TableName: []
  });
};
var se_UpdateItemInput = (input, context) => {
  return take(input, {
    AttributeUpdates: (_) => se_AttributeUpdates(_, context),
    ConditionExpression: [],
    ConditionalOperator: [],
    Expected: (_) => se_ExpectedAttributeMap(_, context),
    ExpressionAttributeNames: _json,
    ExpressionAttributeValues: (_) => se_ExpressionAttributeValueMap(_, context),
    Key: (_) => se_Key(_, context),
    ReturnConsumedCapacity: [],
    ReturnItemCollectionMetrics: [],
    ReturnValues: [],
    ReturnValuesOnConditionCheckFailure: [],
    TableName: [],
    UpdateExpression: []
  });
};
var se_WriteRequest = (input, context) => {
  return take(input, {
    DeleteRequest: (_) => se_DeleteRequest(_, context),
    PutRequest: (_) => se_PutRequest(_, context)
  });
};
var se_WriteRequests = (input, context) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return se_WriteRequest(entry, context);
  });
};
var de_AttributeMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_AttributeValue(expectUnion(value), context);
    return acc;
  }, {});
};
var de_AttributeValue = (output, context) => {
  if (output.B != null) {
    return {
      B: context.base64Decoder(output.B)
    };
  }
  if (expectBoolean2(output.BOOL) !== void 0) {
    return { BOOL: expectBoolean2(output.BOOL) };
  }
  if (output.BS != null) {
    return {
      BS: de_BinarySetAttributeValue(output.BS, context)
    };
  }
  if (output.L != null) {
    return {
      L: de_ListAttributeValue(output.L, context)
    };
  }
  if (output.M != null) {
    return {
      M: de_MapAttributeValue(output.M, context)
    };
  }
  if (expectString2(output.N) !== void 0) {
    return { N: expectString2(output.N) };
  }
  if (output.NS != null) {
    return {
      NS: _json(output.NS)
    };
  }
  if (expectBoolean2(output.NULL) !== void 0) {
    return { NULL: expectBoolean2(output.NULL) };
  }
  if (expectString2(output.S) !== void 0) {
    return { S: expectString2(output.S) };
  }
  if (output.SS != null) {
    return {
      SS: _json(output.SS)
    };
  }
  return { $unknown: Object.entries(output)[0] };
};
var de_BatchGetItemOutput = (output, context) => {
  return take(output, {
    ConsumedCapacity: (_) => de_ConsumedCapacityMultiple(_, context),
    Responses: (_) => de_BatchGetResponseMap(_, context),
    UnprocessedKeys: (_) => de_BatchGetRequestMap(_, context)
  });
};
var de_BatchGetRequestMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_KeysAndAttributes(value, context);
    return acc;
  }, {});
};
var de_BatchGetResponseMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_ItemList(value, context);
    return acc;
  }, {});
};
var de_BatchWriteItemOutput = (output, context) => {
  return take(output, {
    ConsumedCapacity: (_) => de_ConsumedCapacityMultiple(_, context),
    ItemCollectionMetrics: (_) => de_ItemCollectionMetricsPerTable(_, context),
    UnprocessedItems: (_) => de_BatchWriteItemRequestMap(_, context)
  });
};
var de_BatchWriteItemRequestMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_WriteRequests(value, context);
    return acc;
  }, {});
};
var de_BinarySetAttributeValue = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    return context.base64Decoder(entry);
  });
  return retVal;
};
var de_Capacity = (output, context) => {
  return take(output, {
    CapacityUnits: limitedParseDouble,
    ReadCapacityUnits: limitedParseDouble,
    WriteCapacityUnits: limitedParseDouble
  });
};
var de_ConditionalCheckFailedException = (output, context) => {
  return take(output, {
    Item: (_) => de_AttributeMap(_, context),
    message: expectString2
  });
};
var de_ConsumedCapacity = (output, context) => {
  return take(output, {
    CapacityUnits: limitedParseDouble,
    GlobalSecondaryIndexes: (_) => de_SecondaryIndexesCapacityMap(_, context),
    LocalSecondaryIndexes: (_) => de_SecondaryIndexesCapacityMap(_, context),
    ReadCapacityUnits: limitedParseDouble,
    Table: (_) => de_Capacity(_, context),
    TableName: expectString2,
    WriteCapacityUnits: limitedParseDouble
  });
};
var de_ConsumedCapacityMultiple = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    return de_ConsumedCapacity(entry, context);
  });
  return retVal;
};
var de_DeleteItemOutput = (output, context) => {
  return take(output, {
    Attributes: (_) => de_AttributeMap(_, context),
    ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
    ItemCollectionMetrics: (_) => de_ItemCollectionMetrics(_, context)
  });
};
var de_DeleteRequest = (output, context) => {
  return take(output, {
    Key: (_) => de_Key(_, context)
  });
};
var de_ItemCollectionKeyAttributeMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_AttributeValue(expectUnion(value), context);
    return acc;
  }, {});
};
var de_ItemCollectionMetrics = (output, context) => {
  return take(output, {
    ItemCollectionKey: (_) => de_ItemCollectionKeyAttributeMap(_, context),
    SizeEstimateRangeGB: (_) => de_ItemCollectionSizeEstimateRange(_, context)
  });
};
var de_ItemCollectionMetricsMultiple = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    return de_ItemCollectionMetrics(entry, context);
  });
  return retVal;
};
var de_ItemCollectionMetricsPerTable = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_ItemCollectionMetricsMultiple(value, context);
    return acc;
  }, {});
};
var de_ItemCollectionSizeEstimateRange = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    return limitedParseDouble(entry);
  });
  return retVal;
};
var de_ItemList = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    return de_AttributeMap(entry, context);
  });
  return retVal;
};
var de_Key = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_AttributeValue(expectUnion(value), context);
    return acc;
  }, {});
};
var de_KeyList = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    return de_Key(entry, context);
  });
  return retVal;
};
var de_KeysAndAttributes = (output, context) => {
  return take(output, {
    AttributesToGet: _json,
    ConsistentRead: expectBoolean2,
    ExpressionAttributeNames: _json,
    Keys: (_) => de_KeyList(_, context),
    ProjectionExpression: expectString2
  });
};
var de_ListAttributeValue = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    return de_AttributeValue(expectUnion(entry), context);
  });
  return retVal;
};
var de_MapAttributeValue = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_AttributeValue(expectUnion(value), context);
    return acc;
  }, {});
};
var de_PutItemInputAttributeMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_AttributeValue(expectUnion(value), context);
    return acc;
  }, {});
};
var de_PutItemOutput = (output, context) => {
  return take(output, {
    Attributes: (_) => de_AttributeMap(_, context),
    ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
    ItemCollectionMetrics: (_) => de_ItemCollectionMetrics(_, context)
  });
};
var de_PutRequest = (output, context) => {
  return take(output, {
    Item: (_) => de_PutItemInputAttributeMap(_, context)
  });
};
var de_QueryOutput = (output, context) => {
  return take(output, {
    ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
    Count: expectInt322,
    Items: (_) => de_ItemList(_, context),
    LastEvaluatedKey: (_) => de_Key(_, context),
    ScannedCount: expectInt322
  });
};
var de_SecondaryIndexesCapacityMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_Capacity(value, context);
    return acc;
  }, {});
};
var de_UpdateItemOutput = (output, context) => {
  return take(output, {
    Attributes: (_) => de_AttributeMap(_, context),
    ConsumedCapacity: (_) => de_ConsumedCapacity(_, context),
    ItemCollectionMetrics: (_) => de_ItemCollectionMetrics(_, context)
  });
};
var de_WriteRequest = (output, context) => {
  return take(output, {
    DeleteRequest: (_) => de_DeleteRequest(_, context),
    PutRequest: (_) => de_PutRequest(_, context)
  });
};
var de_WriteRequests = (output, context) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    return de_WriteRequest(entry, context);
  });
  return retVal;
};
var deserializeMetadata8 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBodyString6 = (streamBody, context) => collectBody6(streamBody, context).then((body) => context.utf8Encoder(body));
var throwDefaultError3 = withBaseException(DynamoDBServiceException);
var buildHttpRpcRequest4 = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest2(contents);
};
function sharedHeaders(operation) {
  return {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": `DynamoDB_20120810.${operation}`
  };
}
var parseBody6 = (streamBody, context) => collectBodyString6(streamBody, context).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
var parseErrorBody6 = async (errorBody, context) => {
  const value = await parseBody6(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};
var loadRestJsonErrorCode4 = (output, data) => {
  const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeEndpointsCommand.js
var DescribeEndpointsCommand = class _DescribeEndpointsCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _DescribeEndpointsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "DescribeEndpointsCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DescribeEndpointsCommand(input, context);
  }
  deserialize(output, context) {
    return de_DescribeEndpointsCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters6 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "dynamodb"
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/package.json
var package_default6 = {
  name: "@aws-sdk/client-dynamodb",
  description: "AWS SDK for JavaScript Dynamodb Client for Node.js, Browser and React Native",
  version: "3.363.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo dynamodb"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.363.0",
    "@aws-sdk/credential-provider-node": "3.363.0",
    "@aws-sdk/middleware-endpoint-discovery": "3.363.0",
    "@aws-sdk/middleware-host-header": "3.363.0",
    "@aws-sdk/middleware-logger": "3.363.0",
    "@aws-sdk/middleware-recursion-detection": "3.363.0",
    "@aws-sdk/middleware-signing": "3.363.0",
    "@aws-sdk/middleware-user-agent": "3.363.0",
    "@aws-sdk/types": "3.357.0",
    "@aws-sdk/util-endpoints": "3.357.0",
    "@aws-sdk/util-user-agent-browser": "3.363.0",
    "@aws-sdk/util-user-agent-node": "3.363.0",
    "@smithy/config-resolver": "^1.0.1",
    "@smithy/fetch-http-handler": "^1.0.1",
    "@smithy/hash-node": "^1.0.1",
    "@smithy/invalid-dependency": "^1.0.1",
    "@smithy/middleware-content-length": "^1.0.1",
    "@smithy/middleware-endpoint": "^1.0.1",
    "@smithy/middleware-retry": "^1.0.2",
    "@smithy/middleware-serde": "^1.0.1",
    "@smithy/middleware-stack": "^1.0.1",
    "@smithy/node-config-provider": "^1.0.1",
    "@smithy/node-http-handler": "^1.0.2",
    "@smithy/protocol-http": "^1.0.1",
    "@smithy/smithy-client": "^1.0.3",
    "@smithy/types": "^1.0.0",
    "@smithy/url-parser": "^1.0.1",
    "@smithy/util-base64": "^1.0.1",
    "@smithy/util-body-length-browser": "^1.0.1",
    "@smithy/util-body-length-node": "^1.0.1",
    "@smithy/util-defaults-mode-browser": "^1.0.1",
    "@smithy/util-defaults-mode-node": "^1.0.1",
    "@smithy/util-retry": "^1.0.2",
    "@smithy/util-utf8": "^1.0.1",
    "@smithy/util-waiter": "^1.0.1",
    tslib: "^2.5.0",
    uuid: "^8.3.2"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.310.0",
    "@smithy/service-client-documentation-generator": "^1.0.1",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    "@types/uuid": "^8.3.0",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-dynamodb",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-dynamodb"
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/middleware-sdk-sts/dist-es/index.js
var resolveStsAuthConfig2 = (input, { stsClientCtor }) => resolveAwsAuthConfig2({
  ...input,
  stsClientCtor
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters7 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    defaultSigningName: "sts"
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/package.json
var package_default7 = {
  name: "@aws-sdk/client-sts",
  description: "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
  version: "3.363.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sts",
    test: "yarn test:unit",
    "test:unit": "jest"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/credential-provider-node": "3.363.0",
    "@aws-sdk/middleware-host-header": "3.363.0",
    "@aws-sdk/middleware-logger": "3.363.0",
    "@aws-sdk/middleware-recursion-detection": "3.363.0",
    "@aws-sdk/middleware-sdk-sts": "3.363.0",
    "@aws-sdk/middleware-signing": "3.363.0",
    "@aws-sdk/middleware-user-agent": "3.363.0",
    "@aws-sdk/types": "3.357.0",
    "@aws-sdk/util-endpoints": "3.357.0",
    "@aws-sdk/util-user-agent-browser": "3.363.0",
    "@aws-sdk/util-user-agent-node": "3.363.0",
    "@smithy/config-resolver": "^1.0.1",
    "@smithy/fetch-http-handler": "^1.0.1",
    "@smithy/hash-node": "^1.0.1",
    "@smithy/invalid-dependency": "^1.0.1",
    "@smithy/middleware-content-length": "^1.0.1",
    "@smithy/middleware-endpoint": "^1.0.1",
    "@smithy/middleware-retry": "^1.0.1",
    "@smithy/middleware-serde": "^1.0.1",
    "@smithy/middleware-stack": "^1.0.1",
    "@smithy/node-config-provider": "^1.0.1",
    "@smithy/node-http-handler": "^1.0.1",
    "@smithy/protocol-http": "^1.1.0",
    "@smithy/smithy-client": "^1.0.2",
    "@smithy/types": "^1.1.0",
    "@smithy/url-parser": "^1.0.1",
    "@smithy/util-base64": "^1.0.1",
    "@smithy/util-body-length-browser": "^1.0.1",
    "@smithy/util-body-length-node": "^1.0.1",
    "@smithy/util-defaults-mode-browser": "^1.0.1",
    "@smithy/util-defaults-mode-node": "^1.0.1",
    "@smithy/util-retry": "^1.0.1",
    "@smithy/util-utf8": "^1.0.1",
    "fast-xml-parser": "4.2.5",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.310.0",
    "@smithy/service-client-documentation-generator": "^1.0.1",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sts"
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/models/STSServiceException.js
var STSServiceException2 = class _STSServiceException extends ServiceException2 {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _STSServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/models/models_0.js
var ExpiredTokenException3 = class _ExpiredTokenException extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
  }
};
var MalformedPolicyDocumentException2 = class _MalformedPolicyDocumentException extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "MalformedPolicyDocumentException",
      $fault: "client",
      ...opts
    });
    this.name = "MalformedPolicyDocumentException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _MalformedPolicyDocumentException.prototype);
  }
};
var PackedPolicyTooLargeException2 = class _PackedPolicyTooLargeException extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "PackedPolicyTooLargeException",
      $fault: "client",
      ...opts
    });
    this.name = "PackedPolicyTooLargeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _PackedPolicyTooLargeException.prototype);
  }
};
var RegionDisabledException2 = class _RegionDisabledException extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "RegionDisabledException",
      $fault: "client",
      ...opts
    });
    this.name = "RegionDisabledException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _RegionDisabledException.prototype);
  }
};
var IDPRejectedClaimException2 = class _IDPRejectedClaimException extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "IDPRejectedClaimException",
      $fault: "client",
      ...opts
    });
    this.name = "IDPRejectedClaimException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _IDPRejectedClaimException.prototype);
  }
};
var InvalidIdentityTokenException2 = class _InvalidIdentityTokenException extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidIdentityTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidIdentityTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidIdentityTokenException.prototype);
  }
};
var IDPCommunicationErrorException2 = class _IDPCommunicationErrorException extends STSServiceException2 {
  constructor(opts) {
    super({
      name: "IDPCommunicationErrorException",
      $fault: "client",
      ...opts
    });
    this.name = "IDPCommunicationErrorException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _IDPCommunicationErrorException.prototype);
  }
};
var CredentialsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING2 }
});
var AssumeRoleResponseFilterSensitiveLog2 = (obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
});
var AssumeRoleWithWebIdentityRequestFilterSensitiveLog2 = (obj) => ({
  ...obj,
  ...obj.WebIdentityToken && { WebIdentityToken: SENSITIVE_STRING2 }
});
var AssumeRoleWithWebIdentityResponseFilterSensitiveLog2 = (obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/protocols/Aws_query.js
var import_fast_xml_parser3 = __toESM(require_fxp2());
var se_AssumeRoleCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString3({
    ...se_AssumeRoleRequest(input, context),
    Action: "AssumeRole",
    Version: "2011-06-15"
  });
  return buildHttpRpcRequest5(context, headers, "/", void 0, body);
};
var se_AssumeRoleWithWebIdentityCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString3({
    ...se_AssumeRoleWithWebIdentityRequest(input, context),
    Action: "AssumeRoleWithWebIdentity",
    Version: "2011-06-15"
  });
  return buildHttpRpcRequest5(context, headers, "/", void 0, body);
};
var de_AssumeRoleCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_AssumeRoleCommandError(output, context);
  }
  const data = await parseBody7(output.body, context);
  let contents = {};
  contents = de_AssumeRoleResponse(data.AssumeRoleResult, context);
  const response = {
    $metadata: deserializeMetadata9(output),
    ...contents
  };
  return response;
};
var de_AssumeRoleCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody7(output.body, context)
  };
  const errorCode = loadQueryErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await de_RegionDisabledExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError4({
        output,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
};
var de_AssumeRoleWithWebIdentityCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_AssumeRoleWithWebIdentityCommandError(output, context);
  }
  const data = await parseBody7(output.body, context);
  let contents = {};
  contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
  const response = {
    $metadata: deserializeMetadata9(output),
    ...contents
  };
  return response;
};
var de_AssumeRoleWithWebIdentityCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody7(output.body, context)
  };
  const errorCode = loadQueryErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
    case "IDPCommunicationError":
    case "com.amazonaws.sts#IDPCommunicationErrorException":
      throw await de_IDPCommunicationErrorExceptionRes(parsedOutput, context);
    case "IDPRejectedClaim":
    case "com.amazonaws.sts#IDPRejectedClaimException":
      throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
    case "InvalidIdentityToken":
    case "com.amazonaws.sts#InvalidIdentityTokenException":
      throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await de_RegionDisabledExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError4({
        output,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
};
var de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_ExpiredTokenException(body.Error, context);
  const exception = new ExpiredTokenException3({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_IDPCommunicationErrorExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_IDPCommunicationErrorException(body.Error, context);
  const exception = new IDPCommunicationErrorException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_IDPRejectedClaimExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_IDPRejectedClaimException(body.Error, context);
  const exception = new IDPRejectedClaimException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_InvalidIdentityTokenExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidIdentityTokenException(body.Error, context);
  const exception = new InvalidIdentityTokenException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
  const exception = new MalformedPolicyDocumentException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_PackedPolicyTooLargeExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_PackedPolicyTooLargeException(body.Error, context);
  const exception = new PackedPolicyTooLargeException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var de_RegionDisabledExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_RegionDisabledException(body.Error, context);
  const exception = new RegionDisabledException2({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException2(exception, body);
};
var se_AssumeRoleRequest = (input, context) => {
  const entries = {};
  if (input.RoleArn != null) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.RoleSessionName != null) {
    entries["RoleSessionName"] = input.RoleSessionName;
  }
  if (input.PolicyArns != null) {
    const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
    if (input.PolicyArns?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Policy != null) {
    entries["Policy"] = input.Policy;
  }
  if (input.DurationSeconds != null) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  if (input.Tags != null) {
    const memberEntries = se_tagListType(input.Tags, context);
    if (input.Tags?.length === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TransitiveTagKeys != null) {
    const memberEntries = se_tagKeyListType(input.TransitiveTagKeys, context);
    if (input.TransitiveTagKeys?.length === 0) {
      entries.TransitiveTagKeys = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitiveTagKeys.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ExternalId != null) {
    entries["ExternalId"] = input.ExternalId;
  }
  if (input.SerialNumber != null) {
    entries["SerialNumber"] = input.SerialNumber;
  }
  if (input.TokenCode != null) {
    entries["TokenCode"] = input.TokenCode;
  }
  if (input.SourceIdentity != null) {
    entries["SourceIdentity"] = input.SourceIdentity;
  }
  return entries;
};
var se_AssumeRoleWithWebIdentityRequest = (input, context) => {
  const entries = {};
  if (input.RoleArn != null) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.RoleSessionName != null) {
    entries["RoleSessionName"] = input.RoleSessionName;
  }
  if (input.WebIdentityToken != null) {
    entries["WebIdentityToken"] = input.WebIdentityToken;
  }
  if (input.ProviderId != null) {
    entries["ProviderId"] = input.ProviderId;
  }
  if (input.PolicyArns != null) {
    const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
    if (input.PolicyArns?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Policy != null) {
    entries["Policy"] = input.Policy;
  }
  if (input.DurationSeconds != null) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  return entries;
};
var se_policyDescriptorListType = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_PolicyDescriptorType(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_PolicyDescriptorType = (input, context) => {
  const entries = {};
  if (input.arn != null) {
    entries["arn"] = input.arn;
  }
  return entries;
};
var se_Tag = (input, context) => {
  const entries = {};
  if (input.Key != null) {
    entries["Key"] = input.Key;
  }
  if (input.Value != null) {
    entries["Value"] = input.Value;
  }
  return entries;
};
var se_tagKeyListType = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_tagListType = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_Tag(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var de_AssumedRoleUser = (output, context) => {
  const contents = {};
  if (output["AssumedRoleId"] !== void 0) {
    contents.AssumedRoleId = expectString2(output["AssumedRoleId"]);
  }
  if (output["Arn"] !== void 0) {
    contents.Arn = expectString2(output["Arn"]);
  }
  return contents;
};
var de_AssumeRoleResponse = (output, context) => {
  const contents = {};
  if (output["Credentials"] !== void 0) {
    contents.Credentials = de_Credentials(output["Credentials"], context);
  }
  if (output["AssumedRoleUser"] !== void 0) {
    contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
  }
  if (output["PackedPolicySize"] !== void 0) {
    contents.PackedPolicySize = strictParseInt322(output["PackedPolicySize"]);
  }
  if (output["SourceIdentity"] !== void 0) {
    contents.SourceIdentity = expectString2(output["SourceIdentity"]);
  }
  return contents;
};
var de_AssumeRoleWithWebIdentityResponse = (output, context) => {
  const contents = {};
  if (output["Credentials"] !== void 0) {
    contents.Credentials = de_Credentials(output["Credentials"], context);
  }
  if (output["SubjectFromWebIdentityToken"] !== void 0) {
    contents.SubjectFromWebIdentityToken = expectString2(output["SubjectFromWebIdentityToken"]);
  }
  if (output["AssumedRoleUser"] !== void 0) {
    contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
  }
  if (output["PackedPolicySize"] !== void 0) {
    contents.PackedPolicySize = strictParseInt322(output["PackedPolicySize"]);
  }
  if (output["Provider"] !== void 0) {
    contents.Provider = expectString2(output["Provider"]);
  }
  if (output["Audience"] !== void 0) {
    contents.Audience = expectString2(output["Audience"]);
  }
  if (output["SourceIdentity"] !== void 0) {
    contents.SourceIdentity = expectString2(output["SourceIdentity"]);
  }
  return contents;
};
var de_Credentials = (output, context) => {
  const contents = {};
  if (output["AccessKeyId"] !== void 0) {
    contents.AccessKeyId = expectString2(output["AccessKeyId"]);
  }
  if (output["SecretAccessKey"] !== void 0) {
    contents.SecretAccessKey = expectString2(output["SecretAccessKey"]);
  }
  if (output["SessionToken"] !== void 0) {
    contents.SessionToken = expectString2(output["SessionToken"]);
  }
  if (output["Expiration"] !== void 0) {
    contents.Expiration = expectNonNull2(parseRfc3339DateTimeWithOffset2(output["Expiration"]));
  }
  return contents;
};
var de_ExpiredTokenException = (output, context) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var de_IDPCommunicationErrorException = (output, context) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var de_IDPRejectedClaimException = (output, context) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var de_InvalidIdentityTokenException = (output, context) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var de_MalformedPolicyDocumentException = (output, context) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var de_PackedPolicyTooLargeException = (output, context) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var de_RegionDisabledException = (output, context) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString2(output["message"]);
  }
  return contents;
};
var deserializeMetadata9 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBodyString7 = (streamBody, context) => collectBody6(streamBody, context).then((body) => context.utf8Encoder(body));
var throwDefaultError4 = withBaseException(STSServiceException2);
var buildHttpRpcRequest5 = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest2(contents);
};
var SHARED_HEADERS = {
  "content-type": "application/x-www-form-urlencoded"
};
var parseBody7 = (streamBody, context) => collectBodyString7(streamBody, context).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser3.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    const parsedObj = parser.parse(encoded);
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode2(parsedObjToReturn);
  }
  return {};
});
var parseErrorBody7 = async (errorBody, context) => {
  const value = await parseBody7(errorBody, context);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
};
var buildFormUrlencodedString3 = (formEntries) => Object.entries(formEntries).map(([key, value]) => extendedEncodeURIComponent2(key) + "=" + extendedEncodeURIComponent2(value)).join("&");
var loadQueryErrorCode3 = (output, data) => {
  if (data.Error?.Code !== void 0) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleCommand.js
var AssumeRoleCommand2 = class _AssumeRoleCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _AssumeRoleCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getAwsAuthPlugin2(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "STSClient";
    const commandName = "AssumeRoleCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: AssumeRoleResponseFilterSensitiveLog2
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_AssumeRoleCommand(input, context);
  }
  deserialize(output, context) {
    return de_AssumeRoleCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithWebIdentityCommand.js
var AssumeRoleWithWebIdentityCommand2 = class _AssumeRoleWithWebIdentityCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _AssumeRoleWithWebIdentityCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "STSClient";
    const commandName = "AssumeRoleWithWebIdentityCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: AssumeRoleWithWebIdentityRequestFilterSensitiveLog2,
      outputFilterSensitiveLog: AssumeRoleWithWebIdentityResponseFilterSensitiveLog2
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_AssumeRoleWithWebIdentityCommand(input, context);
  }
  deserialize(output, context) {
    return de_AssumeRoleWithWebIdentityCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/defaultStsRoleAssumers.js
var ASSUME_ROLE_DEFAULT_REGION2 = "us-east-1";
var decorateDefaultRegion2 = (region) => {
  if (typeof region !== "function") {
    return region === void 0 ? ASSUME_ROLE_DEFAULT_REGION2 : region;
  }
  return async () => {
    try {
      return await region();
    } catch (e10) {
      return ASSUME_ROLE_DEFAULT_REGION2;
    }
  };
};
var getDefaultRoleAssumer3 = (stsOptions, stsClientCtor) => {
  let stsClient;
  let closureSourceCreds;
  return async (sourceCreds, params) => {
    closureSourceCreds = sourceCreds;
    if (!stsClient) {
      const { logger: logger3, region, requestHandler } = stsOptions;
      stsClient = new stsClientCtor({
        logger: logger3,
        credentialDefaultProvider: () => async () => closureSourceCreds,
        region: decorateDefaultRegion2(region || stsOptions.region),
        ...requestHandler ? { requestHandler } : {}
      });
    }
    const { Credentials } = await stsClient.send(new AssumeRoleCommand2(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
};
var getDefaultRoleAssumerWithWebIdentity3 = (stsOptions, stsClientCtor) => {
  let stsClient;
  return async (params) => {
    if (!stsClient) {
      const { logger: logger3, region, requestHandler } = stsOptions;
      stsClient = new stsClientCtor({
        logger: logger3,
        region: decorateDefaultRegion2(region || stsOptions.region),
        ...requestHandler ? { requestHandler } : {}
      });
    }
    const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand2(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
};
var decorateDefaultCredentialProvider3 = (provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer3(input, input.stsClientCtor),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity3(input, input.stsClientCtor),
  ...input
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-env/dist-es/fromEnv.js
var ENV_KEY2 = "AWS_ACCESS_KEY_ID";
var ENV_SECRET2 = "AWS_SECRET_ACCESS_KEY";
var ENV_SESSION2 = "AWS_SESSION_TOKEN";
var ENV_EXPIRATION2 = "AWS_CREDENTIAL_EXPIRATION";
var fromEnv4 = () => async () => {
  const accessKeyId = process.env[ENV_KEY2];
  const secretAccessKey = process.env[ENV_SECRET2];
  const sessionToken = process.env[ENV_SESSION2];
  const expiry = process.env[ENV_EXPIRATION2];
  if (accessKeyId && secretAccessKey) {
    return {
      accessKeyId,
      secretAccessKey,
      ...sessionToken && { sessionToken },
      ...expiry && { expiration: new Date(expiry) }
    };
  }
  throw new CredentialsProviderError2("Unable to find environment variable credentials.");
};

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js
var import_os3 = require("os");
var import_path5 = require("path");
var getHomeDir2 = () => {
  const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${import_path5.sep}` } = process.env;
  if (HOME)
    return HOME;
  if (USERPROFILE)
    return USERPROFILE;
  if (HOMEPATH)
    return `${HOMEDRIVE}${HOMEPATH}`;
  return (0, import_os3.homedir)();
};

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
var ENV_PROFILE2 = "AWS_PROFILE";
var DEFAULT_PROFILE2 = "default";
var getProfileName2 = (init) => init.profile || process.env[ENV_PROFILE2] || DEFAULT_PROFILE2;

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js
var import_crypto4 = require("crypto");
var import_path6 = require("path");
var getSSOTokenFilepath2 = (id) => {
  const hasher = (0, import_crypto4.createHash)("sha1");
  const cacheName = hasher.update(id).digest("hex");
  return (0, import_path6.join)(getHomeDir2(), ".aws", "sso", "cache", `${cacheName}.json`);
};

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js
var import_fs6 = require("fs");
var { readFile: readFile3 } = import_fs6.promises;
var getSSOTokenFromFile2 = async (id) => {
  const ssoTokenFilepath = getSSOTokenFilepath2(id);
  const ssoTokenText = await readFile3(ssoTokenFilepath, "utf8");
  return JSON.parse(ssoTokenText);
};

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js
var import_path7 = require("path");
var ENV_CONFIG_PATH2 = "AWS_CONFIG_FILE";
var getConfigFilepath2 = () => process.env[ENV_CONFIG_PATH2] || (0, import_path7.join)(getHomeDir2(), ".aws", "config");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js
var import_path8 = require("path");
var ENV_CREDENTIALS_PATH2 = "AWS_SHARED_CREDENTIALS_FILE";
var getCredentialsFilepath2 = () => process.env[ENV_CREDENTIALS_PATH2] || (0, import_path8.join)(getHomeDir2(), ".aws", "credentials");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileData.js
var profileKeyRegex2 = /^profile\s(["'])?([^\1]+)\1$/;
var getProfileData2 = (data) => Object.entries(data).filter(([key]) => profileKeyRegex2.test(key)).reduce((acc, [key, value]) => ({ ...acc, [profileKeyRegex2.exec(key)[2]]: value }), {
  ...data.default && { default: data.default }
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js
var profileNameBlockList2 = ["__proto__", "profile __proto__"];
var parseIni2 = (iniData) => {
  const map6 = {};
  let currentSection;
  for (let line of iniData.split(/\r?\n/)) {
    line = line.split(/(^|\s)[;#]/)[0].trim();
    const isSection = line[0] === "[" && line[line.length - 1] === "]";
    if (isSection) {
      currentSection = line.substring(1, line.length - 1);
      if (profileNameBlockList2.includes(currentSection)) {
        throw new Error(`Found invalid profile name "${currentSection}"`);
      }
    } else if (currentSection) {
      const indexOfEqualsSign = line.indexOf("=");
      const start = 0;
      const end = line.length - 1;
      const isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
      if (isAssignment) {
        const [name, value] = [
          line.substring(0, indexOfEqualsSign).trim(),
          line.substring(indexOfEqualsSign + 1).trim()
        ];
        map6[currentSection] = map6[currentSection] || {};
        map6[currentSection][name] = value;
      }
    }
  }
  return map6;
};

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js
var import_fs7 = require("fs");
var { readFile: readFile4 } = import_fs7.promises;
var filePromisesHash2 = {};
var slurpFile2 = (path, options) => {
  if (!filePromisesHash2[path] || options?.ignoreCache) {
    filePromisesHash2[path] = readFile4(path, "utf8");
  }
  return filePromisesHash2[path];
};

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js
var swallowError3 = () => ({});
var loadSharedConfigFiles2 = async (init = {}) => {
  const { filepath = getCredentialsFilepath2(), configFilepath = getConfigFilepath2() } = init;
  const parsedFiles = await Promise.all([
    slurpFile2(configFilepath, {
      ignoreCache: init.ignoreCache
    }).then(parseIni2).then(getProfileData2).catch(swallowError3),
    slurpFile2(filepath, {
      ignoreCache: init.ignoreCache
    }).then(parseIni2).catch(swallowError3)
  ]);
  return {
    configFile: parsedFiles[0],
    credentialsFile: parsedFiles[1]
  };
};

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js
var ssoSessionKeyRegex2 = /^sso-session\s(["'])?([^\1]+)\1$/;
var getSsoSessionData2 = (data) => Object.entries(data).filter(([key]) => ssoSessionKeyRegex2.test(key)).reduce((acc, [key, value]) => ({ ...acc, [ssoSessionKeyRegex2.exec(key)[2]]: value }), {});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js
var swallowError4 = () => ({});
var loadSsoSessionData2 = async (init = {}) => slurpFile2(init.configFilepath ?? getConfigFilepath2()).then(parseIni2).then(getSsoSessionData2).catch(swallowError4);

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js
var mergeConfigFiles = (...files) => {
  const merged = {};
  for (const file of files) {
    for (const [key, values] of Object.entries(file)) {
      if (merged[key] !== void 0) {
        Object.assign(merged[key], values);
      } else {
        merged[key] = values;
      }
    }
  }
  return merged;
};

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js
var parseKnownFiles2 = async (init) => {
  const parsedFiles = await loadSharedConfigFiles2(init);
  return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/fromContainerMetadata.js
var import_url2 = require("url");

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/httpRequest.js
var import_buffer5 = require("buffer");
var import_http4 = require("http");
function httpRequest2(options) {
  return new Promise((resolve, reject) => {
    const req = (0, import_http4.request)({
      method: "GET",
      ...options,
      hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
    });
    req.on("error", (err) => {
      reject(Object.assign(new ProviderError2("Unable to connect to instance metadata service"), err));
      req.destroy();
    });
    req.on("timeout", () => {
      reject(new ProviderError2("TimeoutError from instance metadata service"));
      req.destroy();
    });
    req.on("response", (res) => {
      const { statusCode = 400 } = res;
      if (statusCode < 200 || 300 <= statusCode) {
        reject(Object.assign(new ProviderError2("Error response received from instance metadata service"), { statusCode }));
        req.destroy();
      }
      const chunks = [];
      res.on("data", (chunk2) => {
        chunks.push(chunk2);
      });
      res.on("end", () => {
        resolve(import_buffer5.Buffer.concat(chunks));
        req.destroy();
      });
    });
    req.end();
  });
}

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/ImdsCredentials.js
var isImdsCredentials2 = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string";
var fromImdsCredentials2 = (creds) => ({
  accessKeyId: creds.AccessKeyId,
  secretAccessKey: creds.SecretAccessKey,
  sessionToken: creds.Token,
  expiration: new Date(creds.Expiration)
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/RemoteProviderInit.js
var DEFAULT_TIMEOUT2 = 1e3;
var DEFAULT_MAX_RETRIES2 = 0;
var providerConfigFromInit2 = ({ maxRetries = DEFAULT_MAX_RETRIES2, timeout = DEFAULT_TIMEOUT2 }) => ({ maxRetries, timeout });

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/retry.js
var retry2 = (toRetry, maxRetries) => {
  let promise = toRetry();
  for (let i10 = 0; i10 < maxRetries; i10++) {
    promise = promise.catch(toRetry);
  }
  return promise;
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/fromContainerMetadata.js
var ENV_CMDS_FULL_URI2 = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
var ENV_CMDS_RELATIVE_URI2 = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
var ENV_CMDS_AUTH_TOKEN2 = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
var fromContainerMetadata3 = (init = {}) => {
  const { timeout, maxRetries } = providerConfigFromInit2(init);
  return () => retry2(async () => {
    const requestOptions = await getCmdsUri2();
    const credsResponse = JSON.parse(await requestFromEcsImds2(timeout, requestOptions));
    if (!isImdsCredentials2(credsResponse)) {
      throw new CredentialsProviderError2("Invalid response received from instance metadata service.");
    }
    return fromImdsCredentials2(credsResponse);
  }, maxRetries);
};
var requestFromEcsImds2 = async (timeout, options) => {
  if (process.env[ENV_CMDS_AUTH_TOKEN2]) {
    options.headers = {
      ...options.headers,
      Authorization: process.env[ENV_CMDS_AUTH_TOKEN2]
    };
  }
  const buffer = await httpRequest2({
    ...options,
    timeout
  });
  return buffer.toString();
};
var CMDS_IP2 = "169.254.170.2";
var GREENGRASS_HOSTS2 = {
  localhost: true,
  "127.0.0.1": true
};
var GREENGRASS_PROTOCOLS2 = {
  "http:": true,
  "https:": true
};
var getCmdsUri2 = async () => {
  if (process.env[ENV_CMDS_RELATIVE_URI2]) {
    return {
      hostname: CMDS_IP2,
      path: process.env[ENV_CMDS_RELATIVE_URI2]
    };
  }
  if (process.env[ENV_CMDS_FULL_URI2]) {
    const parsed = (0, import_url2.parse)(process.env[ENV_CMDS_FULL_URI2]);
    if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS2)) {
      throw new CredentialsProviderError2(`${parsed.hostname} is not a valid container metadata service hostname`, false);
    }
    if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS2)) {
      throw new CredentialsProviderError2(`${parsed.protocol} is not a valid container metadata service protocol`, false);
    }
    return {
      ...parsed,
      port: parsed.port ? parseInt(parsed.port, 10) : void 0
    };
  }
  throw new CredentialsProviderError2(`The container metadata credential provider cannot be used unless the ${ENV_CMDS_RELATIVE_URI2} or ${ENV_CMDS_FULL_URI2} environment variable is set`, false);
};

// ../../node_modules/@smithy/node-config-provider/dist-es/fromEnv.js
var fromEnv5 = (envVarSelector) => async () => {
  try {
    const config = envVarSelector(process.env);
    if (config === void 0) {
      throw new Error();
    }
    return config;
  } catch (e10) {
    throw new CredentialsProviderError2(e10.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
  }
};

// ../../node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js
var fromSharedConfigFiles2 = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
  const profile = getProfileName2(init);
  const { configFile, credentialsFile } = await loadSharedConfigFiles2(init);
  const profileFromCredentials = credentialsFile[profile] || {};
  const profileFromConfig = configFile[profile] || {};
  const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
  try {
    const configValue = configSelector(mergedProfile);
    if (configValue === void 0) {
      throw new Error();
    }
    return configValue;
  } catch (e10) {
    throw new CredentialsProviderError2(e10.message || `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
  }
};

// ../../node_modules/@smithy/node-config-provider/dist-es/fromStatic.js
var isFunction2 = (func) => typeof func === "function";
var fromStatic4 = (defaultValue) => isFunction2(defaultValue) ? async () => await defaultValue() : fromStatic3(defaultValue);

// ../../node_modules/@smithy/node-config-provider/dist-es/configLoader.js
var loadConfig2 = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize2(chain2(fromEnv5(environmentVariableSelector), fromSharedConfigFiles2(configFileSelector, configuration), fromStatic4(defaultValue)));

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/Endpoint.js
var Endpoint2;
(function(Endpoint3) {
  Endpoint3["IPv4"] = "http://169.254.169.254";
  Endpoint3["IPv6"] = "http://[fd00:ec2::254]";
})(Endpoint2 || (Endpoint2 = {}));

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointConfigOptions.js
var ENV_ENDPOINT_NAME2 = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
var CONFIG_ENDPOINT_NAME2 = "ec2_metadata_service_endpoint";
var ENDPOINT_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => env3[ENV_ENDPOINT_NAME2],
  configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME2],
  default: void 0
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointMode.js
var EndpointMode2;
(function(EndpointMode3) {
  EndpointMode3["IPv4"] = "IPv4";
  EndpointMode3["IPv6"] = "IPv6";
})(EndpointMode2 || (EndpointMode2 = {}));

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointModeConfigOptions.js
var ENV_ENDPOINT_MODE_NAME2 = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
var CONFIG_ENDPOINT_MODE_NAME2 = "ec2_metadata_service_endpoint_mode";
var ENDPOINT_MODE_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => env3[ENV_ENDPOINT_MODE_NAME2],
  configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME2],
  default: EndpointMode2.IPv4
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/utils/getInstanceMetadataEndpoint.js
var getInstanceMetadataEndpoint2 = async () => parseUrl2(await getFromEndpointConfig2() || await getFromEndpointModeConfig2());
var getFromEndpointConfig2 = async () => loadConfig2(ENDPOINT_CONFIG_OPTIONS2)();
var getFromEndpointModeConfig2 = async () => {
  const endpointMode = await loadConfig2(ENDPOINT_MODE_CONFIG_OPTIONS2)();
  switch (endpointMode) {
    case EndpointMode2.IPv4:
      return Endpoint2.IPv4;
    case EndpointMode2.IPv6:
      return Endpoint2.IPv6;
    default:
      throw new Error(`Unsupported endpoint mode: ${endpointMode}. Select from ${Object.values(EndpointMode2)}`);
  }
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/utils/getExtendedInstanceMetadataCredentials.js
var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS2 = 5 * 60;
var STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS2 = 5 * 60;
var STATIC_STABILITY_DOC_URL2 = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
var getExtendedInstanceMetadataCredentials2 = (credentials, logger3) => {
  const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS2 + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS2);
  const newExpiration = new Date(Date.now() + refreshInterval * 1e3);
  logger3.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: " + STATIC_STABILITY_DOC_URL2);
  const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
  return {
    ...credentials,
    ...originalExpiration ? { originalExpiration } : {},
    expiration: newExpiration
  };
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/utils/staticStabilityProvider.js
var staticStabilityProvider2 = (provider, options = {}) => {
  const logger3 = options?.logger || console;
  let pastCredentials;
  return async () => {
    let credentials;
    try {
      credentials = await provider();
      if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
        credentials = getExtendedInstanceMetadataCredentials2(credentials, logger3);
      }
    } catch (e10) {
      if (pastCredentials) {
        logger3.warn("Credential renew failed: ", e10);
        credentials = getExtendedInstanceMetadataCredentials2(pastCredentials, logger3);
      } else {
        throw e10;
      }
    }
    pastCredentials = credentials;
    return credentials;
  };
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/fromInstanceMetadata.js
var IMDS_PATH2 = "/latest/meta-data/iam/security-credentials/";
var IMDS_TOKEN_PATH2 = "/latest/api/token";
var fromInstanceMetadata3 = (init = {}) => staticStabilityProvider2(getInstanceImdsProvider2(init), { logger: init.logger });
var getInstanceImdsProvider2 = (init) => {
  let disableFetchToken = false;
  const { timeout, maxRetries } = providerConfigFromInit2(init);
  const getCredentials = async (maxRetries2, options) => {
    const profile = (await retry2(async () => {
      let profile2;
      try {
        profile2 = await getProfile2(options);
      } catch (err) {
        if (err.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err;
      }
      return profile2;
    }, maxRetries2)).trim();
    return retry2(async () => {
      let creds;
      try {
        creds = await getCredentialsFromProfile2(profile, options);
      } catch (err) {
        if (err.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err;
      }
      return creds;
    }, maxRetries2);
  };
  return async () => {
    const endpoint = await getInstanceMetadataEndpoint2();
    if (disableFetchToken) {
      return getCredentials(maxRetries, { ...endpoint, timeout });
    } else {
      let token;
      try {
        token = (await getMetadataToken2({ ...endpoint, timeout })).toString();
      } catch (error) {
        if (error?.statusCode === 400) {
          throw Object.assign(error, {
            message: "EC2 Metadata token request returned error"
          });
        } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
          disableFetchToken = true;
        }
        return getCredentials(maxRetries, { ...endpoint, timeout });
      }
      return getCredentials(maxRetries, {
        ...endpoint,
        headers: {
          "x-aws-ec2-metadata-token": token
        },
        timeout
      });
    }
  };
};
var getMetadataToken2 = async (options) => httpRequest2({
  ...options,
  path: IMDS_TOKEN_PATH2,
  method: "PUT",
  headers: {
    "x-aws-ec2-metadata-token-ttl-seconds": "21600"
  }
});
var getProfile2 = async (options) => (await httpRequest2({ ...options, path: IMDS_PATH2 })).toString();
var getCredentialsFromProfile2 = async (profile, options) => {
  const credsResponse = JSON.parse((await httpRequest2({
    ...options,
    path: IMDS_PATH2 + profile
  })).toString());
  if (!isImdsCredentials2(credsResponse)) {
    throw new CredentialsProviderError2("Invalid response received from instance metadata service.");
  }
  return fromImdsCredentials2(credsResponse);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js
var resolveCredentialSource2 = (credentialSource, profileName) => {
  const sourceProvidersMap = {
    EcsContainer: fromContainerMetadata3,
    Ec2InstanceMetadata: fromInstanceMetadata3,
    Environment: fromEnv4
  };
  if (credentialSource in sourceProvidersMap) {
    return sourceProvidersMap[credentialSource]();
  } else {
    throw new CredentialsProviderError2(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js
var isAssumeRoleProfile2 = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile2(arg) || isAssumeRoleWithProviderProfile2(arg));
var isAssumeRoleWithSourceProfile2 = (arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
var isAssumeRoleWithProviderProfile2 = (arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
var resolveAssumeRoleCredentials2 = async (profileName, profiles, options, visitedProfiles = {}) => {
  const data = profiles[profileName];
  if (!options.roleAssumer) {
    throw new CredentialsProviderError2(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
  }
  const { source_profile } = data;
  if (source_profile && source_profile in visitedProfiles) {
    throw new CredentialsProviderError2(`Detected a cycle attempting to resolve credentials for profile ${getProfileName2(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), false);
  }
  const sourceCredsProvider = source_profile ? resolveProfileData2(source_profile, profiles, options, {
    ...visitedProfiles,
    [source_profile]: true
  }) : resolveCredentialSource2(data.credential_source, profileName)();
  const params = {
    RoleArn: data.role_arn,
    RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
    ExternalId: data.external_id
  };
  const { mfa_serial } = data;
  if (mfa_serial) {
    if (!options.mfaCodeProvider) {
      throw new CredentialsProviderError2(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
    }
    params.SerialNumber = mfa_serial;
    params.TokenCode = await options.mfaCodeProvider(mfa_serial);
  }
  const sourceCreds = await sourceCredsProvider;
  return options.roleAssumer(sourceCreds, params);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
var import_child_process2 = require("child_process");
var import_util6 = require("util");

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-process/dist-es/getValidatedProcessCredentials.js
var getValidatedProcessCredentials2 = (profileName, data) => {
  if (data.Version !== 1) {
    throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
  }
  if (data.AccessKeyId === void 0 || data.SecretAccessKey === void 0) {
    throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
  }
  if (data.Expiration) {
    const currentTime = /* @__PURE__ */ new Date();
    const expireTime = new Date(data.Expiration);
    if (expireTime < currentTime) {
      throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
    }
  }
  return {
    accessKeyId: data.AccessKeyId,
    secretAccessKey: data.SecretAccessKey,
    ...data.SessionToken && { sessionToken: data.SessionToken },
    ...data.Expiration && { expiration: new Date(data.Expiration) }
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
var resolveProcessCredentials3 = async (profileName, profiles) => {
  const profile = profiles[profileName];
  if (profiles[profileName]) {
    const credentialProcess = profile["credential_process"];
    if (credentialProcess !== void 0) {
      const execPromise = (0, import_util6.promisify)(import_child_process2.exec);
      try {
        const { stdout } = await execPromise(credentialProcess);
        let data;
        try {
          data = JSON.parse(stdout.trim());
        } catch {
          throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
        }
        return getValidatedProcessCredentials2(profileName, data);
      } catch (error) {
        throw new CredentialsProviderError2(error.message);
      }
    } else {
      throw new CredentialsProviderError2(`Profile ${profileName} did not contain credential_process.`);
    }
  } else {
    throw new CredentialsProviderError2(`Profile ${profileName} could not be found in shared credentials file.`);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-process/dist-es/fromProcess.js
var fromProcess3 = (init = {}) => async () => {
  const profiles = await parseKnownFiles2(init);
  return resolveProcessCredentials3(getProfileName2(init), profiles);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js
var isProcessProfile2 = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
var resolveProcessCredentials4 = async (options, profile) => fromProcess3({
  ...options,
  profile
})();

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js
var isSsoProfile2 = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters8 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssoportal"
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/package.json
var package_default8 = {
  name: "@aws-sdk/client-sso",
  description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
  version: "3.363.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/middleware-host-header": "3.363.0",
    "@aws-sdk/middleware-logger": "3.363.0",
    "@aws-sdk/middleware-recursion-detection": "3.363.0",
    "@aws-sdk/middleware-user-agent": "3.363.0",
    "@aws-sdk/types": "3.357.0",
    "@aws-sdk/util-endpoints": "3.357.0",
    "@aws-sdk/util-user-agent-browser": "3.363.0",
    "@aws-sdk/util-user-agent-node": "3.363.0",
    "@smithy/config-resolver": "^1.0.1",
    "@smithy/fetch-http-handler": "^1.0.1",
    "@smithy/hash-node": "^1.0.1",
    "@smithy/invalid-dependency": "^1.0.1",
    "@smithy/middleware-content-length": "^1.0.1",
    "@smithy/middleware-endpoint": "^1.0.1",
    "@smithy/middleware-retry": "^1.0.2",
    "@smithy/middleware-serde": "^1.0.1",
    "@smithy/middleware-stack": "^1.0.1",
    "@smithy/node-config-provider": "^1.0.1",
    "@smithy/node-http-handler": "^1.0.2",
    "@smithy/protocol-http": "^1.0.1",
    "@smithy/smithy-client": "^1.0.3",
    "@smithy/types": "^1.0.0",
    "@smithy/url-parser": "^1.0.1",
    "@smithy/util-base64": "^1.0.1",
    "@smithy/util-body-length-browser": "^1.0.1",
    "@smithy/util-body-length-node": "^1.0.1",
    "@smithy/util-defaults-mode-browser": "^1.0.1",
    "@smithy/util-defaults-mode-node": "^1.0.1",
    "@smithy/util-retry": "^1.0.2",
    "@smithy/util-utf8": "^1.0.1",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.310.0",
    "@smithy/service-client-documentation-generator": "^1.0.1",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sso"
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var import_os4 = require("os");
var import_process2 = require("process");

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js
var isCrtAvailable2 = () => {
  try {
    if (typeof require === "function" && typeof module !== "undefined" && require("aws-crt")) {
      return ["md/crt-avail"];
    }
    return null;
  } catch (e10) {
    return null;
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var UA_APP_ID_ENV_NAME2 = "AWS_SDK_UA_APP_ID";
var UA_APP_ID_INI_NAME2 = "sdk-ua-app-id";
var defaultUserAgent2 = ({ serviceId, clientVersion }) => {
  const sections = [
    ["aws-sdk-js", clientVersion],
    ["ua", "2.0"],
    [`os/${(0, import_os4.platform)()}`, (0, import_os4.release)()],
    ["lang/js"],
    ["md/nodejs", `${import_process2.versions.node}`]
  ];
  const crtAvailable = isCrtAvailable2();
  if (crtAvailable) {
    sections.push(crtAvailable);
  }
  if (serviceId) {
    sections.push([`api/${serviceId}`, clientVersion]);
  }
  if (import_process2.env.AWS_EXECUTION_ENV) {
    sections.push([`exec-env/${import_process2.env.AWS_EXECUTION_ENV}`]);
  }
  const appIdPromise = loadConfig2({
    environmentVariableSelector: (env3) => env3[UA_APP_ID_ENV_NAME2],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME2],
    default: void 0
  })();
  let resolvedUserAgent = void 0;
  return async () => {
    if (!resolvedUserAgent) {
      const appId = await appIdPromise;
      resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
    }
    return resolvedUserAgent;
  };
};

// ../../node_modules/@smithy/hash-node/dist-es/index.js
var import_buffer6 = require("buffer");
var import_crypto5 = require("crypto");
var Hash2 = class {
  constructor(algorithmIdentifier, secret) {
    this.algorithmIdentifier = algorithmIdentifier;
    this.secret = secret;
    this.reset();
  }
  update(toHash, encoding) {
    this.hash.update(toUint8Array2(castSourceData2(toHash, encoding)));
  }
  digest() {
    return Promise.resolve(this.hash.digest());
  }
  reset() {
    this.hash = this.secret ? (0, import_crypto5.createHmac)(this.algorithmIdentifier, castSourceData2(this.secret)) : (0, import_crypto5.createHash)(this.algorithmIdentifier);
  }
};
function castSourceData2(toCast, encoding) {
  if (import_buffer6.Buffer.isBuffer(toCast)) {
    return toCast;
  }
  if (typeof toCast === "string") {
    return fromString2(toCast, encoding);
  }
  if (ArrayBuffer.isView(toCast)) {
    return fromArrayBuffer2(toCast.buffer, toCast.byteOffset, toCast.byteLength);
  }
  return fromArrayBuffer2(toCast);
}

// ../../node_modules/@smithy/util-body-length-node/dist-es/calculateBodyLength.js
var import_fs8 = require("fs");
var calculateBodyLength2 = (body) => {
  if (!body) {
    return 0;
  }
  if (typeof body === "string") {
    return Buffer.from(body).length;
  } else if (typeof body.byteLength === "number") {
    return body.byteLength;
  } else if (typeof body.size === "number") {
    return body.size;
  } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
    return (0, import_fs8.lstatSync)(body.path).size;
  } else if (typeof body.fd === "number") {
    return (0, import_fs8.fstatSync)(body.fd).size;
  }
  throw new Error(`Body Length computation failed for ${body}`);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
var p6 = "required";
var q6 = "fn";
var r6 = "argv";
var s6 = "ref";
var a6 = "PartitionResult";
var b6 = "tree";
var c6 = "error";
var d6 = "endpoint";
var e6 = { [p6]: false, "type": "String" };
var f6 = { [p6]: true, "default": false, "type": "Boolean" };
var g6 = { [s6]: "Endpoint" };
var h6 = { [q6]: "booleanEquals", [r6]: [{ [s6]: "UseFIPS" }, true] };
var i6 = { [q6]: "booleanEquals", [r6]: [{ [s6]: "UseDualStack" }, true] };
var j6 = {};
var k6 = { [q6]: "booleanEquals", [r6]: [true, { [q6]: "getAttr", [r6]: [{ [s6]: a6 }, "supportsFIPS"] }] };
var l6 = { [q6]: "booleanEquals", [r6]: [true, { [q6]: "getAttr", [r6]: [{ [s6]: a6 }, "supportsDualStack"] }] };
var m6 = [g6];
var n6 = [h6];
var o6 = [i6];
var _data6 = { version: "1.0", parameters: { Region: e6, UseDualStack: f6, UseFIPS: f6, Endpoint: e6 }, rules: [{ conditions: [{ [q6]: "aws.partition", [r6]: [{ [s6]: "Region" }], assign: a6 }], type: b6, rules: [{ conditions: [{ [q6]: "isSet", [r6]: m6 }, { [q6]: "parseURL", [r6]: m6, assign: "url" }], type: b6, rules: [{ conditions: n6, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c6 }, { type: b6, rules: [{ conditions: o6, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c6 }, { endpoint: { url: g6, properties: j6, headers: j6 }, type: d6 }] }] }, { conditions: [h6, i6], type: b6, rules: [{ conditions: [k6, l6], type: b6, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c6 }] }, { conditions: n6, type: b6, rules: [{ conditions: [k6], type: b6, rules: [{ type: b6, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c6 }] }, { conditions: o6, type: b6, rules: [{ conditions: [l6], type: b6, rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c6 }] }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }] };
var ruleSet6 = _data6;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver6 = (endpointParams, context = {}) => {
  return resolveEndpoint2(ruleSet6, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
var getRuntimeConfig11 = (config) => ({
  apiVersion: "2019-06-10",
  base64Decoder: config?.base64Decoder ?? fromBase642,
  base64Encoder: config?.base64Encoder ?? toBase642,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver6,
  logger: config?.logger ?? new NoOpLogger2(),
  serviceId: config?.serviceId ?? "SSO",
  urlParser: config?.urlParser ?? parseUrl2,
  utf8Decoder: config?.utf8Decoder ?? fromUtf85,
  utf8Encoder: config?.utf8Encoder ?? toUtf85
});

// ../../node_modules/@smithy/util-defaults-mode-node/dist-es/constants.js
var AWS_EXECUTION_ENV2 = "AWS_EXECUTION_ENV";
var AWS_REGION_ENV2 = "AWS_REGION";
var AWS_DEFAULT_REGION_ENV2 = "AWS_DEFAULT_REGION";
var ENV_IMDS_DISABLED3 = "AWS_EC2_METADATA_DISABLED";
var DEFAULTS_MODE_OPTIONS2 = ["in-region", "cross-region", "mobile", "standard", "legacy"];
var IMDS_REGION_PATH2 = "/latest/meta-data/placement/region";

// ../../node_modules/@smithy/util-defaults-mode-node/dist-es/defaultsModeConfig.js
var AWS_DEFAULTS_MODE_ENV2 = "AWS_DEFAULTS_MODE";
var AWS_DEFAULTS_MODE_CONFIG2 = "defaults_mode";
var NODE_DEFAULTS_MODE_CONFIG_OPTIONS2 = {
  environmentVariableSelector: (env3) => {
    return env3[AWS_DEFAULTS_MODE_ENV2];
  },
  configFileSelector: (profile) => {
    return profile[AWS_DEFAULTS_MODE_CONFIG2];
  },
  default: "legacy"
};

// ../../node_modules/@smithy/util-defaults-mode-node/dist-es/resolveDefaultsModeConfig.js
var resolveDefaultsModeConfig2 = ({ region = loadConfig2(NODE_REGION_CONFIG_OPTIONS2), defaultsMode = loadConfig2(NODE_DEFAULTS_MODE_CONFIG_OPTIONS2) } = {}) => memoize2(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode?.toLowerCase()) {
    case "auto":
      return resolveNodeDefaultsModeAuto2(region);
    case "in-region":
    case "cross-region":
    case "mobile":
    case "standard":
    case "legacy":
      return Promise.resolve(mode?.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS2.join(", ")}, got ${mode}`);
  }
});
var resolveNodeDefaultsModeAuto2 = async (clientRegion) => {
  if (clientRegion) {
    const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
    const inferredRegion = await inferPhysicalRegion2();
    if (!inferredRegion) {
      return "standard";
    }
    if (resolvedRegion === inferredRegion) {
      return "in-region";
    } else {
      return "cross-region";
    }
  }
  return "standard";
};
var inferPhysicalRegion2 = async () => {
  if (process.env[AWS_EXECUTION_ENV2] && (process.env[AWS_REGION_ENV2] || process.env[AWS_DEFAULT_REGION_ENV2])) {
    return process.env[AWS_REGION_ENV2] ?? process.env[AWS_DEFAULT_REGION_ENV2];
  }
  if (!process.env[ENV_IMDS_DISABLED3]) {
    try {
      const endpoint = await getInstanceMetadataEndpoint2();
      return (await httpRequest2({ ...endpoint, path: IMDS_REGION_PATH2 })).toString();
    } catch (e10) {
    }
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js
var getRuntimeConfig12 = (config) => {
  emitWarningIfUnsupportedVersion2(process.version);
  const defaultsMode = resolveDefaultsModeConfig2(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode2);
  const clientSharedValues = getRuntimeConfig11(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength2,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default8.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig2(NODE_MAX_ATTEMPT_CONFIG_OPTIONS2),
    region: config?.region ?? loadConfig2(NODE_REGION_CONFIG_OPTIONS2, NODE_REGION_CONFIG_FILE_OPTIONS2),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler2(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig2({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS2,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE2
    }),
    sha256: config?.sha256 ?? Hash2.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector2,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig2(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig2(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2)
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js
var SSOClient2 = class extends Client2 {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig12(configuration);
    const _config_1 = resolveClientEndpointParameters8(_config_0);
    const _config_2 = resolveRegionConfig2(_config_1);
    const _config_3 = resolveEndpointConfig2(_config_2);
    const _config_4 = resolveRetryConfig2(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveUserAgentConfig2(_config_5);
    super(_config_6);
    this.config = _config_6;
    this.middlewareStack.use(getRetryPlugin2(this.config));
    this.middlewareStack.use(getContentLengthPlugin2(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin2(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js
var SSOServiceException2 = class _SSOServiceException extends ServiceException2 {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _SSOServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js
var InvalidRequestException3 = class _InvalidRequestException extends SSOServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidRequestException.prototype);
  }
};
var ResourceNotFoundException4 = class _ResourceNotFoundException extends SSOServiceException2 {
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
  }
};
var TooManyRequestsException3 = class _TooManyRequestsException extends SSOServiceException2 {
  constructor(opts) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyRequestsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _TooManyRequestsException.prototype);
  }
};
var UnauthorizedException2 = class _UnauthorizedException extends SSOServiceException2 {
  constructor(opts) {
    super({
      name: "UnauthorizedException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnauthorizedException.prototype);
  }
};
var GetRoleCredentialsRequestFilterSensitiveLog2 = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING2 }
});
var RoleCredentialsFilterSensitiveLog2 = (obj) => ({
  ...obj,
  ...obj.secretAccessKey && { secretAccessKey: SENSITIVE_STRING2 },
  ...obj.sessionToken && { sessionToken: SENSITIVE_STRING2 }
});
var GetRoleCredentialsResponseFilterSensitiveLog2 = (obj) => ({
  ...obj,
  ...obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog2(obj.roleCredentials) }
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js
var se_GetRoleCredentialsCommand = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = map5({}, isSerializableHeaderValue2, {
    "x-amz-sso_bearer_token": input.accessToken
  });
  const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/federation/credentials`;
  const query = map5({
    role_name: [, expectNonNull2(input.roleName, `roleName`)],
    account_id: [, expectNonNull2(input.accountId, `accountId`)]
  });
  let body;
  return new HttpRequest2({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};
var de_GetRoleCredentialsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_GetRoleCredentialsCommandError(output, context);
  }
  const contents = map5({
    $metadata: deserializeMetadata10(output)
  });
  const data = expectNonNull2(expectObject2(await parseBody8(output.body, context)), "body");
  const doc = take(data, {
    roleCredentials: _json
  });
  Object.assign(contents, doc);
  return contents;
};
var de_GetRoleCredentialsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody8(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode5(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes2(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError5({
        output,
        parsedBody,
        errorCode
      });
  }
};
var throwDefaultError5 = withBaseException(SSOServiceException2);
var de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString2
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestException3({
    $metadata: deserializeMetadata10(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_ResourceNotFoundExceptionRes2 = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString2
  });
  Object.assign(contents, doc);
  const exception = new ResourceNotFoundException4({
    $metadata: deserializeMetadata10(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString2
  });
  Object.assign(contents, doc);
  const exception = new TooManyRequestsException3({
    $metadata: deserializeMetadata10(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString2
  });
  Object.assign(contents, doc);
  const exception = new UnauthorizedException2({
    $metadata: deserializeMetadata10(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeMetadata10 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBodyString8 = (streamBody, context) => collectBody6(streamBody, context).then((body) => context.utf8Encoder(body));
var isSerializableHeaderValue2 = (value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
var parseBody8 = (streamBody, context) => collectBodyString8(streamBody, context).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
var parseErrorBody8 = async (errorBody, context) => {
  const value = await parseBody8(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};
var loadRestJsonErrorCode5 = (output, data) => {
  const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js
var GetRoleCredentialsCommand2 = class _GetRoleCredentialsCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _GetRoleCredentialsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SSOClient";
    const commandName = "GetRoleCredentialsCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetRoleCredentialsRequestFilterSensitiveLog2,
      outputFilterSensitiveLog: GetRoleCredentialsResponseFilterSensitiveLog2
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_GetRoleCredentialsCommand(input, context);
  }
  deserialize(output, context) {
    return de_GetRoleCredentialsCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/constants.js
var EXPIRE_WINDOW_MS3 = 5 * 60 * 1e3;
var REFRESH_MESSAGE2 = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters9 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssooidc"
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/package.json
var package_default9 = {
  name: "@aws-sdk/client-sso-oidc",
  description: "AWS SDK for JavaScript Sso Oidc Client for Node.js, Browser and React Native",
  version: "3.363.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sso-oidc"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/middleware-host-header": "3.363.0",
    "@aws-sdk/middleware-logger": "3.363.0",
    "@aws-sdk/middleware-recursion-detection": "3.363.0",
    "@aws-sdk/middleware-user-agent": "3.363.0",
    "@aws-sdk/types": "3.357.0",
    "@aws-sdk/util-endpoints": "3.357.0",
    "@aws-sdk/util-user-agent-browser": "3.363.0",
    "@aws-sdk/util-user-agent-node": "3.363.0",
    "@smithy/config-resolver": "^1.0.1",
    "@smithy/fetch-http-handler": "^1.0.1",
    "@smithy/hash-node": "^1.0.1",
    "@smithy/invalid-dependency": "^1.0.1",
    "@smithy/middleware-content-length": "^1.0.1",
    "@smithy/middleware-endpoint": "^1.0.1",
    "@smithy/middleware-retry": "^1.0.2",
    "@smithy/middleware-serde": "^1.0.1",
    "@smithy/middleware-stack": "^1.0.1",
    "@smithy/node-config-provider": "^1.0.1",
    "@smithy/node-http-handler": "^1.0.2",
    "@smithy/protocol-http": "^1.0.1",
    "@smithy/smithy-client": "^1.0.3",
    "@smithy/types": "^1.0.0",
    "@smithy/url-parser": "^1.0.1",
    "@smithy/util-base64": "^1.0.1",
    "@smithy/util-body-length-browser": "^1.0.1",
    "@smithy/util-body-length-node": "^1.0.1",
    "@smithy/util-defaults-mode-browser": "^1.0.1",
    "@smithy/util-defaults-mode-node": "^1.0.1",
    "@smithy/util-retry": "^1.0.2",
    "@smithy/util-utf8": "^1.0.1",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@aws-sdk/service-client-documentation-generator": "3.310.0",
    "@smithy/service-client-documentation-generator": "^1.0.1",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso-oidc",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sso-oidc"
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/ruleset.js
var p7 = "required";
var q7 = "fn";
var r7 = "argv";
var s7 = "ref";
var a7 = "PartitionResult";
var b7 = "tree";
var c7 = "error";
var d7 = "endpoint";
var e7 = { [p7]: false, "type": "String" };
var f7 = { [p7]: true, "default": false, "type": "Boolean" };
var g7 = { [s7]: "Endpoint" };
var h7 = { [q7]: "booleanEquals", [r7]: [{ [s7]: "UseFIPS" }, true] };
var i7 = { [q7]: "booleanEquals", [r7]: [{ [s7]: "UseDualStack" }, true] };
var j7 = {};
var k7 = { [q7]: "booleanEquals", [r7]: [true, { [q7]: "getAttr", [r7]: [{ [s7]: a7 }, "supportsFIPS"] }] };
var l7 = { [q7]: "booleanEquals", [r7]: [true, { [q7]: "getAttr", [r7]: [{ [s7]: a7 }, "supportsDualStack"] }] };
var m7 = [g7];
var n7 = [h7];
var o7 = [i7];
var _data7 = { version: "1.0", parameters: { Region: e7, UseDualStack: f7, UseFIPS: f7, Endpoint: e7 }, rules: [{ conditions: [{ [q7]: "aws.partition", [r7]: [{ [s7]: "Region" }], assign: a7 }], type: b7, rules: [{ conditions: [{ [q7]: "isSet", [r7]: m7 }, { [q7]: "parseURL", [r7]: m7, assign: "url" }], type: b7, rules: [{ conditions: n7, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c7 }, { type: b7, rules: [{ conditions: o7, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c7 }, { endpoint: { url: g7, properties: j7, headers: j7 }, type: d7 }] }] }, { conditions: [h7, i7], type: b7, rules: [{ conditions: [k7, l7], type: b7, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j7, headers: j7 }, type: d7 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c7 }] }, { conditions: n7, type: b7, rules: [{ conditions: [k7], type: b7, rules: [{ type: b7, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j7, headers: j7 }, type: d7 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c7 }] }, { conditions: o7, type: b7, rules: [{ conditions: [l7], type: b7, rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j7, headers: j7 }, type: d7 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c7 }] }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: j7, headers: j7 }, type: d7 }] }] };
var ruleSet7 = _data7;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver7 = (endpointParams, context = {}) => {
  return resolveEndpoint2(ruleSet7, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.shared.js
var getRuntimeConfig13 = (config) => ({
  apiVersion: "2019-06-10",
  base64Decoder: config?.base64Decoder ?? fromBase642,
  base64Encoder: config?.base64Encoder ?? toBase642,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver7,
  logger: config?.logger ?? new NoOpLogger2(),
  serviceId: config?.serviceId ?? "SSO OIDC",
  urlParser: config?.urlParser ?? parseUrl2,
  utf8Decoder: config?.utf8Decoder ?? fromUtf85,
  utf8Encoder: config?.utf8Encoder ?? toUtf85
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.js
var getRuntimeConfig14 = (config) => {
  emitWarningIfUnsupportedVersion2(process.version);
  const defaultsMode = resolveDefaultsModeConfig2(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode2);
  const clientSharedValues = getRuntimeConfig13(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength2,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default9.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig2(NODE_MAX_ATTEMPT_CONFIG_OPTIONS2),
    region: config?.region ?? loadConfig2(NODE_REGION_CONFIG_OPTIONS2, NODE_REGION_CONFIG_FILE_OPTIONS2),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler2(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig2({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS2,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE2
    }),
    sha256: config?.sha256 ?? Hash2.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector2,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig2(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig2(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2)
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDCClient.js
var SSOOIDCClient2 = class extends Client2 {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig14(configuration);
    const _config_1 = resolveClientEndpointParameters9(_config_0);
    const _config_2 = resolveRegionConfig2(_config_1);
    const _config_3 = resolveEndpointConfig2(_config_2);
    const _config_4 = resolveRetryConfig2(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveUserAgentConfig2(_config_5);
    super(_config_6);
    this.config = _config_6;
    this.middlewareStack.use(getRetryPlugin2(this.config));
    this.middlewareStack.use(getContentLengthPlugin2(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin2(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/models/SSOOIDCServiceException.js
var SSOOIDCServiceException2 = class _SSOOIDCServiceException extends ServiceException2 {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _SSOOIDCServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/models/models_0.js
var AccessDeniedException2 = class _AccessDeniedException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "AccessDeniedException",
      $fault: "client",
      ...opts
    });
    this.name = "AccessDeniedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _AccessDeniedException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var AuthorizationPendingException2 = class _AuthorizationPendingException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "AuthorizationPendingException",
      $fault: "client",
      ...opts
    });
    this.name = "AuthorizationPendingException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _AuthorizationPendingException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var ExpiredTokenException4 = class _ExpiredTokenException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InternalServerException2 = class _InternalServerException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "InternalServerException",
      $fault: "server",
      ...opts
    });
    this.name = "InternalServerException";
    this.$fault = "server";
    Object.setPrototypeOf(this, _InternalServerException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidClientException2 = class _InvalidClientException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidClientException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidClientException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidClientException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidGrantException2 = class _InvalidGrantException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidGrantException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidGrantException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidGrantException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidRequestException4 = class _InvalidRequestException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidRequestException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidScopeException2 = class _InvalidScopeException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "InvalidScopeException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidScopeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidScopeException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var SlowDownException2 = class _SlowDownException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "SlowDownException",
      $fault: "client",
      ...opts
    });
    this.name = "SlowDownException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _SlowDownException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var UnauthorizedClientException2 = class _UnauthorizedClientException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "UnauthorizedClientException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedClientException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnauthorizedClientException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var UnsupportedGrantTypeException2 = class _UnsupportedGrantTypeException extends SSOOIDCServiceException2 {
  constructor(opts) {
    super({
      name: "UnsupportedGrantTypeException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedGrantTypeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnsupportedGrantTypeException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/protocols/Aws_restJson1.js
var se_CreateTokenCommand = async (input, context) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers = {
    "content-type": "application/json"
  };
  const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}/token`;
  let body;
  body = JSON.stringify(take(input, {
    clientId: [],
    clientSecret: [],
    code: [],
    deviceCode: [],
    grantType: [],
    redirectUri: [],
    refreshToken: [],
    scope: (_) => _json(_)
  }));
  return new HttpRequest2({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};
var de_CreateTokenCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CreateTokenCommandError(output, context);
  }
  const contents = map5({
    $metadata: deserializeMetadata11(output)
  });
  const data = expectNonNull2(expectObject2(await parseBody9(output.body, context)), "body");
  const doc = take(data, {
    accessToken: expectString2,
    expiresIn: expectInt322,
    idToken: expectString2,
    refreshToken: expectString2,
    tokenType: expectString2
  });
  Object.assign(contents, doc);
  return contents;
};
var de_CreateTokenCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody9(output.body, context)
  };
  const errorCode = loadRestJsonErrorCode6(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ssooidc#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "AuthorizationPendingException":
    case "com.amazonaws.ssooidc#AuthorizationPendingException":
      throw await de_AuthorizationPendingExceptionRes(parsedOutput, context);
    case "ExpiredTokenException":
    case "com.amazonaws.ssooidc#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes2(parsedOutput, context);
    case "InternalServerException":
    case "com.amazonaws.ssooidc#InternalServerException":
      throw await de_InternalServerExceptionRes(parsedOutput, context);
    case "InvalidClientException":
    case "com.amazonaws.ssooidc#InvalidClientException":
      throw await de_InvalidClientExceptionRes(parsedOutput, context);
    case "InvalidGrantException":
    case "com.amazonaws.ssooidc#InvalidGrantException":
      throw await de_InvalidGrantExceptionRes(parsedOutput, context);
    case "InvalidRequestException":
    case "com.amazonaws.ssooidc#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes2(parsedOutput, context);
    case "InvalidScopeException":
    case "com.amazonaws.ssooidc#InvalidScopeException":
      throw await de_InvalidScopeExceptionRes(parsedOutput, context);
    case "SlowDownException":
    case "com.amazonaws.ssooidc#SlowDownException":
      throw await de_SlowDownExceptionRes(parsedOutput, context);
    case "UnauthorizedClientException":
    case "com.amazonaws.ssooidc#UnauthorizedClientException":
      throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
    case "UnsupportedGrantTypeException":
    case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
      throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError6({
        output,
        parsedBody,
        errorCode
      });
  }
};
var throwDefaultError6 = withBaseException(SSOOIDCServiceException2);
var de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new AccessDeniedException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_AuthorizationPendingExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new AuthorizationPendingException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_ExpiredTokenExceptionRes2 = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new ExpiredTokenException4({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_InternalServerExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new InternalServerException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_InvalidClientExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new InvalidClientException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_InvalidGrantExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new InvalidGrantException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_InvalidRequestExceptionRes2 = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestException4({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_InvalidScopeExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new InvalidScopeException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_SlowDownExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new SlowDownException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_UnauthorizedClientExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new UnauthorizedClientException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var de_UnsupportedGrantTypeExceptionRes = async (parsedOutput, context) => {
  const contents = map5({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString2,
    error_description: expectString2
  });
  Object.assign(contents, doc);
  const exception = new UnsupportedGrantTypeException2({
    $metadata: deserializeMetadata11(parsedOutput),
    ...contents
  });
  return decorateServiceException2(exception, parsedOutput.body);
};
var deserializeMetadata11 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var collectBodyString9 = (streamBody, context) => collectBody6(streamBody, context).then((body) => context.utf8Encoder(body));
var parseBody9 = (streamBody, context) => collectBodyString9(streamBody, context).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
});
var parseErrorBody9 = async (errorBody, context) => {
  const value = await parseBody9(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};
var loadRestJsonErrorCode6 = (output, data) => {
  const findKey = (object2, key) => Object.keys(object2).find((k10) => k10.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/CreateTokenCommand.js
var CreateTokenCommand2 = class _CreateTokenCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _CreateTokenCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "SSOOIDCClient";
    const commandName = "CreateTokenCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_CreateTokenCommand(input, context);
  }
  deserialize(output, context) {
    return de_CreateTokenCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js
var ssoOidcClientsHash2 = {};
var getSsoOidcClient2 = (ssoRegion) => {
  if (ssoOidcClientsHash2[ssoRegion]) {
    return ssoOidcClientsHash2[ssoRegion];
  }
  const ssoOidcClient = new SSOOIDCClient2({ region: ssoRegion });
  ssoOidcClientsHash2[ssoRegion] = ssoOidcClient;
  return ssoOidcClient;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js
var getNewSsoOidcToken2 = (ssoToken, ssoRegion) => {
  const ssoOidcClient = getSsoOidcClient2(ssoRegion);
  return ssoOidcClient.send(new CreateTokenCommand2({
    clientId: ssoToken.clientId,
    clientSecret: ssoToken.clientSecret,
    refreshToken: ssoToken.refreshToken,
    grantType: "refresh_token"
  }));
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js
var validateTokenExpiry2 = (token) => {
  if (token.expiration && token.expiration.getTime() < Date.now()) {
    throw new TokenProviderError2(`Token is expired. ${REFRESH_MESSAGE2}`, false);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js
var validateTokenKey2 = (key, value, forRefresh = false) => {
  if (typeof value === "undefined") {
    throw new TokenProviderError2(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE2}`, false);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js
var import_fs9 = require("fs");
var { writeFile: writeFile2 } = import_fs9.promises;
var writeSSOTokenToFile2 = (id, ssoToken) => {
  const tokenFilepath = getSSOTokenFilepath2(id);
  const tokenString = JSON.stringify(ssoToken, null, 2);
  return writeFile2(tokenFilepath, tokenString);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/token-providers/dist-es/fromSso.js
var lastRefreshAttemptTime2 = /* @__PURE__ */ new Date(0);
var fromSso2 = (init = {}) => async () => {
  const profiles = await parseKnownFiles2(init);
  const profileName = getProfileName2(init);
  const profile = profiles[profileName];
  if (!profile) {
    throw new TokenProviderError2(`Profile '${profileName}' could not be found in shared credentials file.`, false);
  } else if (!profile["sso_session"]) {
    throw new TokenProviderError2(`Profile '${profileName}' is missing required property 'sso_session'.`);
  }
  const ssoSessionName = profile["sso_session"];
  const ssoSessions = await loadSsoSessionData2(init);
  const ssoSession = ssoSessions[ssoSessionName];
  if (!ssoSession) {
    throw new TokenProviderError2(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
  }
  for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
    if (!ssoSession[ssoSessionRequiredKey]) {
      throw new TokenProviderError2(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
    }
  }
  const ssoStartUrl = ssoSession["sso_start_url"];
  const ssoRegion = ssoSession["sso_region"];
  let ssoToken;
  try {
    ssoToken = await getSSOTokenFromFile2(ssoSessionName);
  } catch (e10) {
    throw new TokenProviderError2(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE2}`, false);
  }
  validateTokenKey2("accessToken", ssoToken.accessToken);
  validateTokenKey2("expiresAt", ssoToken.expiresAt);
  const { accessToken, expiresAt } = ssoToken;
  const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
  if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS3) {
    return existingToken;
  }
  if (Date.now() - lastRefreshAttemptTime2.getTime() < 30 * 1e3) {
    validateTokenExpiry2(existingToken);
    return existingToken;
  }
  validateTokenKey2("clientId", ssoToken.clientId, true);
  validateTokenKey2("clientSecret", ssoToken.clientSecret, true);
  validateTokenKey2("refreshToken", ssoToken.refreshToken, true);
  try {
    lastRefreshAttemptTime2.setTime(Date.now());
    const newSsoOidcToken = await getNewSsoOidcToken2(ssoToken, ssoRegion);
    validateTokenKey2("accessToken", newSsoOidcToken.accessToken);
    validateTokenKey2("expiresIn", newSsoOidcToken.expiresIn);
    const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1e3);
    try {
      await writeSSOTokenToFile2(ssoSessionName, {
        ...ssoToken,
        accessToken: newSsoOidcToken.accessToken,
        expiresAt: newTokenExpiration.toISOString(),
        refreshToken: newSsoOidcToken.refreshToken
      });
    } catch (error) {
    }
    return {
      token: newSsoOidcToken.accessToken,
      expiration: newTokenExpiration
    };
  } catch (error) {
    validateTokenExpiry2(existingToken);
    return existingToken;
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js
var EXPIRE_WINDOW_MS4 = 15 * 60 * 1e3;
var SHOULD_FAIL_CREDENTIAL_CHAIN2 = false;
var resolveSSOCredentials2 = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile }) => {
  let token;
  const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
  if (ssoSession) {
    try {
      const _token = await fromSso2({ profile })();
      token = {
        accessToken: _token.token,
        expiresAt: new Date(_token.expiration).toISOString()
      };
    } catch (e10) {
      throw new CredentialsProviderError2(e10.message, SHOULD_FAIL_CREDENTIAL_CHAIN2);
    }
  } else {
    try {
      token = await getSSOTokenFromFile2(ssoStartUrl);
    } catch (e10) {
      throw new CredentialsProviderError2(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN2);
    }
  }
  if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS4) {
    throw new CredentialsProviderError2(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN2);
  }
  const { accessToken } = token;
  const sso = ssoClient || new SSOClient2({ region: ssoRegion });
  let ssoResp;
  try {
    ssoResp = await sso.send(new GetRoleCredentialsCommand2({
      accountId: ssoAccountId,
      roleName: ssoRoleName,
      accessToken
    }));
  } catch (e10) {
    throw CredentialsProviderError2.from(e10, SHOULD_FAIL_CREDENTIAL_CHAIN2);
  }
  const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
  if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
    throw new CredentialsProviderError2("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN2);
  }
  return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration) };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js
var validateSsoProfile2 = (profile) => {
  const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
  if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
    throw new CredentialsProviderError2(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
  }
  return profile;
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js
var fromSSO3 = (init = {}) => async () => {
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init;
  const profileName = getProfileName2(init);
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    const profiles = await parseKnownFiles2(init);
    const profile = profiles[profileName];
    if (!profile) {
      throw new CredentialsProviderError2(`Profile ${profileName} was not found.`);
    }
    if (!isSsoProfile2(profile)) {
      throw new CredentialsProviderError2(`Profile ${profileName} is not configured with SSO credentials.`);
    }
    if (profile?.sso_session) {
      const ssoSessions = await loadSsoSessionData2(init);
      const session = ssoSessions[profile.sso_session];
      const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
      if (ssoRegion && ssoRegion !== session.sso_region) {
        throw new CredentialsProviderError2(`Conflicting SSO region` + conflictMsg, false);
      }
      if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
        throw new CredentialsProviderError2(`Conflicting SSO start_url` + conflictMsg, false);
      }
      profile.sso_region = session.sso_region;
      profile.sso_start_url = session.sso_start_url;
    }
    const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile2(profile);
    return resolveSSOCredentials2({
      ssoStartUrl: sso_start_url,
      ssoSession: sso_session,
      ssoAccountId: sso_account_id,
      ssoRegion: sso_region,
      ssoRoleName: sso_role_name,
      ssoClient,
      profile: profileName
    });
  } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
    throw new CredentialsProviderError2('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
  } else {
    return resolveSSOCredentials2({
      ssoStartUrl,
      ssoSession,
      ssoAccountId,
      ssoRegion,
      ssoRoleName,
      ssoClient,
      profile: profileName
    });
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js
var resolveSsoCredentials2 = (data) => {
  const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = validateSsoProfile2(data);
  return fromSSO3({
    ssoStartUrl: sso_start_url,
    ssoAccountId: sso_account_id,
    ssoSession: sso_session,
    ssoRegion: sso_region,
    ssoRoleName: sso_role_name
  })();
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js
var isStaticCredsProfile2 = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1;
var resolveStaticCredentials2 = (profile) => Promise.resolve({
  accessKeyId: profile.aws_access_key_id,
  secretAccessKey: profile.aws_secret_access_key,
  sessionToken: profile.aws_session_token
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
var import_fs10 = require("fs");

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js
var fromWebToken3 = (init) => () => {
  const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds, roleAssumerWithWebIdentity } = init;
  if (!roleAssumerWithWebIdentity) {
    throw new CredentialsProviderError2(`Role Arn '${roleArn}' needs to be assumed with web identity, but no role assumption callback was provided.`, false);
  }
  return roleAssumerWithWebIdentity({
    RoleArn: roleArn,
    RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
    WebIdentityToken: webIdentityToken,
    ProviderId: providerId,
    PolicyArns: policyArns,
    Policy: policy,
    DurationSeconds: durationSeconds
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
var ENV_TOKEN_FILE2 = "AWS_WEB_IDENTITY_TOKEN_FILE";
var ENV_ROLE_ARN2 = "AWS_ROLE_ARN";
var ENV_ROLE_SESSION_NAME2 = "AWS_ROLE_SESSION_NAME";
var fromTokenFile3 = (init = {}) => async () => {
  const webIdentityTokenFile = init?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE2];
  const roleArn = init?.roleArn ?? process.env[ENV_ROLE_ARN2];
  const roleSessionName = init?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME2];
  if (!webIdentityTokenFile || !roleArn) {
    throw new CredentialsProviderError2("Web identity configuration not specified");
  }
  return fromWebToken3({
    ...init,
    webIdentityToken: (0, import_fs10.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
    roleArn,
    roleSessionName
  })();
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js
var isWebIdentityProfile2 = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
var resolveWebIdentityCredentials2 = async (profile, options) => fromTokenFile3({
  webIdentityTokenFile: profile.web_identity_token_file,
  roleArn: profile.role_arn,
  roleSessionName: profile.role_session_name,
  roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity
})();

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js
var resolveProfileData2 = async (profileName, profiles, options, visitedProfiles = {}) => {
  const data = profiles[profileName];
  if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile2(data)) {
    return resolveStaticCredentials2(data);
  }
  if (isAssumeRoleProfile2(data)) {
    return resolveAssumeRoleCredentials2(profileName, profiles, options, visitedProfiles);
  }
  if (isStaticCredsProfile2(data)) {
    return resolveStaticCredentials2(data);
  }
  if (isWebIdentityProfile2(data)) {
    return resolveWebIdentityCredentials2(data, options);
  }
  if (isProcessProfile2(data)) {
    return resolveProcessCredentials4(options, profileName);
  }
  if (isSsoProfile2(data)) {
    return resolveSsoCredentials2(data);
  }
  throw new CredentialsProviderError2(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js
var fromIni3 = (init = {}) => async () => {
  const profiles = await parseKnownFiles2(init);
  return resolveProfileData2(getProfileName2(init), profiles, init);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js
var ENV_IMDS_DISABLED4 = "AWS_EC2_METADATA_DISABLED";
var remoteProvider2 = (init) => {
  if (process.env[ENV_CMDS_RELATIVE_URI2] || process.env[ENV_CMDS_FULL_URI2]) {
    return fromContainerMetadata3(init);
  }
  if (process.env[ENV_IMDS_DISABLED4]) {
    return async () => {
      throw new CredentialsProviderError2("EC2 Instance Metadata Service access disabled");
    };
  }
  return fromInstanceMetadata3(init);
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var defaultProvider3 = (init = {}) => memoize2(chain2(...init.profile || process.env[ENV_PROFILE2] ? [] : [fromEnv4()], fromSSO3(init), fromIni3(init), fromProcess3(init), fromTokenFile3(init), remoteProvider2(init), async () => {
  throw new CredentialsProviderError2("Could not load credentials from any providers", false);
}), (credentials) => credentials.expiration !== void 0 && credentials.expiration.getTime() - Date.now() < 3e5, (credentials) => credentials.expiration !== void 0);

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/endpoint/ruleset.js
var F2 = "required";
var G2 = "type";
var H2 = "fn";
var I2 = "argv";
var J2 = "ref";
var a8 = false;
var b8 = true;
var c8 = "booleanEquals";
var d8 = "tree";
var e8 = "stringEquals";
var f8 = "sigv4";
var g8 = "sts";
var h8 = "us-east-1";
var i8 = "endpoint";
var j8 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
var k8 = "error";
var l8 = "getAttr";
var m8 = { [F2]: false, [G2]: "String" };
var n8 = { [F2]: true, "default": false, [G2]: "Boolean" };
var o8 = { [J2]: "Endpoint" };
var p8 = { [H2]: "isSet", [I2]: [{ [J2]: "Region" }] };
var q8 = { [J2]: "Region" };
var r8 = { [H2]: "aws.partition", [I2]: [q8], "assign": "PartitionResult" };
var s8 = { [J2]: "UseFIPS" };
var t3 = { [J2]: "UseDualStack" };
var u3 = { "url": "https://sts.amazonaws.com", "properties": { "authSchemes": [{ "name": f8, "signingName": g8, "signingRegion": h8 }] }, "headers": {} };
var v3 = {};
var w2 = { "conditions": [{ [H2]: e8, [I2]: [q8, "aws-global"] }], [i8]: u3, [G2]: i8 };
var x2 = { [H2]: c8, [I2]: [s8, true] };
var y2 = { [H2]: c8, [I2]: [t3, true] };
var z2 = { [H2]: c8, [I2]: [true, { [H2]: l8, [I2]: [{ [J2]: "PartitionResult" }, "supportsFIPS"] }] };
var A2 = { [J2]: "PartitionResult" };
var B2 = { [H2]: c8, [I2]: [true, { [H2]: l8, [I2]: [A2, "supportsDualStack"] }] };
var C2 = [{ [H2]: "isSet", [I2]: [o8] }];
var D2 = [x2];
var E2 = [y2];
var _data8 = { version: "1.0", parameters: { Region: m8, UseDualStack: n8, UseFIPS: n8, Endpoint: m8, UseGlobalEndpoint: n8 }, rules: [{ conditions: [{ [H2]: c8, [I2]: [{ [J2]: "UseGlobalEndpoint" }, b8] }, { [H2]: "not", [I2]: C2 }, p8, r8, { [H2]: c8, [I2]: [s8, a8] }, { [H2]: c8, [I2]: [t3, a8] }], [G2]: d8, rules: [{ conditions: [{ [H2]: e8, [I2]: [q8, "ap-northeast-1"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "ap-south-1"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "ap-southeast-1"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "ap-southeast-2"] }], endpoint: u3, [G2]: i8 }, w2, { conditions: [{ [H2]: e8, [I2]: [q8, "ca-central-1"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "eu-central-1"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "eu-north-1"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "eu-west-1"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "eu-west-2"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "eu-west-3"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "sa-east-1"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, h8] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "us-east-2"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "us-west-1"] }], endpoint: u3, [G2]: i8 }, { conditions: [{ [H2]: e8, [I2]: [q8, "us-west-2"] }], endpoint: u3, [G2]: i8 }, { endpoint: { url: j8, properties: { authSchemes: [{ name: f8, signingName: g8, signingRegion: "{Region}" }] }, headers: v3 }, [G2]: i8 }] }, { conditions: C2, [G2]: d8, rules: [{ conditions: D2, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G2]: k8 }, { [G2]: d8, rules: [{ conditions: E2, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G2]: k8 }, { endpoint: { url: o8, properties: v3, headers: v3 }, [G2]: i8 }] }] }, { [G2]: d8, rules: [{ conditions: [p8], [G2]: d8, rules: [{ conditions: [r8], [G2]: d8, rules: [{ conditions: [x2, y2], [G2]: d8, rules: [{ conditions: [z2, B2], [G2]: d8, rules: [{ [G2]: d8, rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v3, headers: v3 }, [G2]: i8 }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G2]: k8 }] }, { conditions: D2, [G2]: d8, rules: [{ conditions: [z2], [G2]: d8, rules: [{ [G2]: d8, rules: [{ conditions: [{ [H2]: e8, [I2]: ["aws-us-gov", { [H2]: l8, [I2]: [A2, "name"] }] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v3, headers: v3 }, [G2]: i8 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v3, headers: v3 }, [G2]: i8 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", [G2]: k8 }] }, { conditions: E2, [G2]: d8, rules: [{ conditions: [B2], [G2]: d8, rules: [{ [G2]: d8, rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v3, headers: v3 }, [G2]: i8 }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", [G2]: k8 }] }, { [G2]: d8, rules: [w2, { endpoint: { url: j8, properties: v3, headers: v3 }, [G2]: i8 }] }] }] }, { error: "Invalid Configuration: Missing Region", [G2]: k8 }] }] };
var ruleSet8 = _data8;

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver8 = (endpointParams, context = {}) => {
  return resolveEndpoint2(ruleSet8, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js
var getRuntimeConfig15 = (config) => ({
  apiVersion: "2011-06-15",
  base64Decoder: config?.base64Decoder ?? fromBase642,
  base64Encoder: config?.base64Encoder ?? toBase642,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver8,
  logger: config?.logger ?? new NoOpLogger2(),
  serviceId: config?.serviceId ?? "STS",
  urlParser: config?.urlParser ?? parseUrl2,
  utf8Decoder: config?.utf8Decoder ?? fromUtf85,
  utf8Encoder: config?.utf8Encoder ?? toUtf85
});

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.js
var getRuntimeConfig16 = (config) => {
  emitWarningIfUnsupportedVersion2(process.version);
  const defaultsMode = resolveDefaultsModeConfig2(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode2);
  const clientSharedValues = getRuntimeConfig15(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength2,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider3(defaultProvider3),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default7.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig2(NODE_MAX_ATTEMPT_CONFIG_OPTIONS2),
    region: config?.region ?? loadConfig2(NODE_REGION_CONFIG_OPTIONS2, NODE_REGION_CONFIG_FILE_OPTIONS2),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler2(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig2({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS2,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE2
    }),
    sha256: config?.sha256 ?? Hash2.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector2,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig2(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig2(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2)
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/STSClient.js
var STSClient2 = class _STSClient extends Client2 {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig16(configuration);
    const _config_1 = resolveClientEndpointParameters7(_config_0);
    const _config_2 = resolveRegionConfig2(_config_1);
    const _config_3 = resolveEndpointConfig2(_config_2);
    const _config_4 = resolveRetryConfig2(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveStsAuthConfig2(_config_5, { stsClientCtor: _STSClient });
    const _config_7 = resolveUserAgentConfig2(_config_6);
    super(_config_7);
    this.config = _config_7;
    this.middlewareStack.use(getRetryPlugin2(this.config));
    this.middlewareStack.use(getContentLengthPlugin2(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin2(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js
var getCustomizableStsClientCtor2 = (baseCtor, customizations) => {
  if (!customizations)
    return baseCtor;
  else
    return class CustomizableSTSClient extends baseCtor {
      constructor(config) {
        super(config);
        for (const customization of customizations) {
          this.middlewareStack.use(customization);
        }
      }
    };
};
var getDefaultRoleAssumer4 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer3(stsOptions, getCustomizableStsClientCtor2(STSClient2, stsPlugins));
var getDefaultRoleAssumerWithWebIdentity4 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity3(stsOptions, getCustomizableStsClientCtor2(STSClient2, stsPlugins));
var decorateDefaultCredentialProvider4 = (provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer4(input),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity4(input),
  ...input
});

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/ruleset.js
var u4 = "required";
var v5 = "fn";
var w3 = "argv";
var x3 = "ref";
var a9 = "isSet";
var b9 = "tree";
var c9 = "error";
var d9 = "endpoint";
var e9 = "PartitionResult";
var f9 = "getAttr";
var g9 = "stringEquals";
var h9 = { [u4]: false, "type": "String" };
var i9 = { [u4]: true, "default": false, "type": "Boolean" };
var j9 = { [x3]: "Endpoint" };
var k9 = { [v5]: "booleanEquals", [w3]: [{ [x3]: "UseFIPS" }, true] };
var l9 = { [v5]: "booleanEquals", [w3]: [{ [x3]: "UseDualStack" }, true] };
var m9 = {};
var n9 = { [x3]: "Region" };
var o9 = { [v5]: "booleanEquals", [w3]: [true, { [v5]: f9, [w3]: [{ [x3]: e9 }, "supportsFIPS"] }] };
var p9 = { [x3]: e9 };
var q9 = { [v5]: "booleanEquals", [w3]: [true, { [v5]: f9, [w3]: [p9, "supportsDualStack"] }] };
var r9 = [k9];
var s9 = [l9];
var t4 = [n9];
var _data9 = { version: "1.0", parameters: { Region: h9, UseDualStack: i9, UseFIPS: i9, Endpoint: h9 }, rules: [{ conditions: [{ [v5]: a9, [w3]: [j9] }], type: b9, rules: [{ conditions: r9, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c9 }, { type: b9, rules: [{ conditions: s9, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c9 }, { endpoint: { url: j9, properties: m9, headers: m9 }, type: d9 }] }] }, { type: b9, rules: [{ conditions: [{ [v5]: a9, [w3]: t4 }], type: b9, rules: [{ conditions: [{ [v5]: "aws.partition", [w3]: t4, assign: e9 }], type: b9, rules: [{ conditions: [k9, l9], type: b9, rules: [{ conditions: [o9, q9], type: b9, rules: [{ type: b9, rules: [{ endpoint: { url: "https://dynamodb-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m9, headers: m9 }, type: d9 }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c9 }] }, { conditions: r9, type: b9, rules: [{ conditions: [o9], type: b9, rules: [{ type: b9, rules: [{ conditions: [{ [v5]: g9, [w3]: ["aws-us-gov", { [v5]: f9, [w3]: [p9, "name"] }] }], endpoint: { url: "https://dynamodb.{Region}.amazonaws.com", properties: m9, headers: m9 }, type: d9 }, { endpoint: { url: "https://dynamodb-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m9, headers: m9 }, type: d9 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c9 }] }, { conditions: s9, type: b9, rules: [{ conditions: [q9], type: b9, rules: [{ type: b9, rules: [{ endpoint: { url: "https://dynamodb.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m9, headers: m9 }, type: d9 }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c9 }] }, { type: b9, rules: [{ conditions: [{ [v5]: g9, [w3]: [n9, "local"] }], endpoint: { url: "http://localhost:8000", properties: { authSchemes: [{ name: "sigv4", signingName: "dynamodb", signingRegion: "us-east-1" }] }, headers: m9 }, type: d9 }, { endpoint: { url: "https://dynamodb.{Region}.{PartitionResult#dnsSuffix}", properties: m9, headers: m9 }, type: d9 }] }] }] }, { error: "Invalid Configuration: Missing Region", type: c9 }] }] };
var ruleSet9 = _data9;

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver9 = (endpointParams, context = {}) => {
  return resolveEndpoint2(ruleSet9, {
    endpointParams,
    logger: context.logger
  });
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/runtimeConfig.shared.js
var getRuntimeConfig17 = (config) => ({
  apiVersion: "2012-08-10",
  base64Decoder: config?.base64Decoder ?? fromBase642,
  base64Encoder: config?.base64Encoder ?? toBase642,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver9,
  logger: config?.logger ?? new NoOpLogger2(),
  serviceId: config?.serviceId ?? "DynamoDB",
  urlParser: config?.urlParser ?? parseUrl2,
  utf8Decoder: config?.utf8Decoder ?? fromUtf85,
  utf8Encoder: config?.utf8Encoder ?? toUtf85
});

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/runtimeConfig.js
var getRuntimeConfig18 = (config) => {
  emitWarningIfUnsupportedVersion2(process.version);
  const defaultsMode = resolveDefaultsModeConfig2(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode2);
  const clientSharedValues = getRuntimeConfig17(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength2,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider4(defaultProvider3),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default6.version }),
    endpointDiscoveryEnabledProvider: config?.endpointDiscoveryEnabledProvider ?? loadConfig2(NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS),
    maxAttempts: config?.maxAttempts ?? loadConfig2(NODE_MAX_ATTEMPT_CONFIG_OPTIONS2),
    region: config?.region ?? loadConfig2(NODE_REGION_CONFIG_OPTIONS2, NODE_REGION_CONFIG_FILE_OPTIONS2),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler2(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig2({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS2,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE2
    }),
    sha256: config?.sha256 ?? Hash2.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector2,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig2(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig2(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2)
  };
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/DynamoDBClient.js
var DynamoDBClient = class extends Client2 {
  constructor(configuration) {
    const _config_0 = getRuntimeConfig18(configuration);
    const _config_1 = resolveClientEndpointParameters6(_config_0);
    const _config_2 = resolveRegionConfig2(_config_1);
    const _config_3 = resolveEndpointConfig2(_config_2);
    const _config_4 = resolveRetryConfig2(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveAwsAuthConfig2(_config_5);
    const _config_7 = resolveUserAgentConfig2(_config_6);
    const _config_8 = resolveEndpointDiscoveryConfig(_config_7, {
      endpointDiscoveryCommandCtor: DescribeEndpointsCommand
    });
    super(_config_8);
    this.config = _config_8;
    this.middlewareStack.use(getRetryPlugin2(this.config));
    this.middlewareStack.use(getContentLengthPlugin2(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin2(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getAwsAuthPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/BatchGetItemCommand.js
var BatchGetItemCommand = class _BatchGetItemCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _BatchGetItemCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "BatchGetItemCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_BatchGetItemCommand(input, context);
  }
  deserialize(output, context) {
    return de_BatchGetItemCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/BatchWriteItemCommand.js
var BatchWriteItemCommand = class _BatchWriteItemCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _BatchWriteItemCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "BatchWriteItemCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_BatchWriteItemCommand(input, context);
  }
  deserialize(output, context) {
    return de_BatchWriteItemCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DeleteItemCommand.js
var DeleteItemCommand = class _DeleteItemCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _DeleteItemCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "DeleteItemCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_DeleteItemCommand(input, context);
  }
  deserialize(output, context) {
    return de_DeleteItemCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/PutItemCommand.js
var PutItemCommand = class _PutItemCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _PutItemCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "PutItemCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_PutItemCommand(input, context);
  }
  deserialize(output, context) {
    return de_PutItemCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/QueryCommand.js
var QueryCommand = class _QueryCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _QueryCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "QueryCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_QueryCommand(input, context);
  }
  deserialize(output, context) {
    return de_QueryCommand(output, context);
  }
};

// ../../node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateItemCommand.js
var UpdateItemCommand = class _UpdateItemCommand extends Command2 {
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin2(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin2(configuration, _UpdateItemCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger3 } = configuration;
    const clientName = "DynamoDBClient";
    const commandName = "UpdateItemCommand";
    const handlerExecutionContext = {
      logger: logger3,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context) {
    return se_UpdateItemCommand(input, context);
  }
  deserialize(output, context) {
    return de_UpdateItemCommand(output, context);
  }
};

// ../../lib/data-core/src/index.ts
var import_chunk = __toESM(require_chunk(), 1);
var import_throat = __toESM(require_throat(), 1);

// ../../lib/telemetry/index.ts
function getAgent() {
  const store = getStore();
  if (store?.telemetry) {
    return store.telemetry;
  }
  return process.telemetry;
}
var count = (usage, value, embeddedNamespace) => {
  const agent = getAgent();
  if (!agent) {
    return;
  }
  agent.count(usage, value, embeddedNamespace);
};
function set2(name, value) {
  const agent = getAgent();
  if (!agent || !agent._metadata) {
    return;
  }
  agent._metadata[name] = value;
}
var telemetry_default = {
  withCounter(usage, embeddedNamespace) {
    return (fn) => {
      return (...args) => {
        count(usage, 1, embeddedNamespace);
        return fn(...args);
      };
    };
  },
  count,
  set: set2
};

// ../../lib/errors/index.ts
var ValidationError2 = class extends Error {
  statusCode = 400;
  name = "ValidationError";
};

// ../../lib/data-core/node_modules/@aws-sdk/util-dynamodb/dist-es/convertToAttr.js
var convertToAttr = (data, options) => {
  if (data === void 0) {
    throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);
  } else if (data === null && typeof data === "object") {
    return convertToNullAttr();
  } else if (Array.isArray(data)) {
    return convertToListAttr(data, options);
  } else if (data?.constructor?.name === "Set") {
    return convertToSetAttr(data, options);
  } else if (data?.constructor?.name === "Map") {
    return convertToMapAttrFromIterable(data, options);
  } else if (data?.constructor?.name === "Object" || !data.constructor && typeof data === "object") {
    return convertToMapAttrFromEnumerableProps(data, options);
  } else if (isBinary(data)) {
    if (data.length === 0 && options?.convertEmptyValues) {
      return convertToNullAttr();
    }
    return convertToBinaryAttr(data);
  } else if (typeof data === "boolean" || data?.constructor?.name === "Boolean") {
    return { BOOL: data.valueOf() };
  } else if (typeof data === "number" || data?.constructor?.name === "Number") {
    return convertToNumberAttr(data);
  } else if (typeof data === "bigint") {
    return convertToBigIntAttr(data);
  } else if (typeof data === "string" || data?.constructor?.name === "String") {
    if (data.length === 0 && options?.convertEmptyValues) {
      return convertToNullAttr();
    }
    return convertToStringAttr(data);
  } else if (options?.convertClassInstanceToMap && typeof data === "object") {
    return convertToMapAttrFromEnumerableProps(data, options);
  }
  throw new Error(`Unsupported type passed: ${data}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`);
};
var convertToListAttr = (data, options) => ({
  L: data.filter((item) => !options?.removeUndefinedValues || options?.removeUndefinedValues && item !== void 0).map((item) => convertToAttr(item, options))
});
var convertToSetAttr = (set5, options) => {
  const setToOperate = options?.removeUndefinedValues ? new Set([...set5].filter((value) => value !== void 0)) : set5;
  if (!options?.removeUndefinedValues && setToOperate.has(void 0)) {
    throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);
  }
  if (setToOperate.size === 0) {
    if (options?.convertEmptyValues) {
      return convertToNullAttr();
    }
    throw new Error(`Pass a non-empty set, or options.convertEmptyValues=true.`);
  }
  const item = setToOperate.values().next().value;
  if (typeof item === "number") {
    return {
      NS: Array.from(setToOperate).map(convertToNumberAttr).map((item2) => item2.N)
    };
  } else if (typeof item === "bigint") {
    return {
      NS: Array.from(setToOperate).map(convertToBigIntAttr).map((item2) => item2.N)
    };
  } else if (typeof item === "string") {
    return {
      SS: Array.from(setToOperate).map(convertToStringAttr).map((item2) => item2.S)
    };
  } else if (isBinary(item)) {
    return {
      BS: Array.from(setToOperate).map(convertToBinaryAttr).map((item2) => item2.B)
    };
  } else {
    throw new Error(`Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.`);
  }
};
var convertToMapAttrFromIterable = (data, options) => ({
  M: ((data2) => {
    const map6 = {};
    for (const [key, value] of data2) {
      if (typeof value !== "function" && (value !== void 0 || !options?.removeUndefinedValues)) {
        map6[key] = convertToAttr(value, options);
      }
    }
    return map6;
  })(data)
});
var convertToMapAttrFromEnumerableProps = (data, options) => ({
  M: ((data2) => {
    const map6 = {};
    for (const key in data2) {
      const value = data2[key];
      if (typeof value !== "function" && (value !== void 0 || !options?.removeUndefinedValues)) {
        map6[key] = convertToAttr(value, options);
      }
    }
    return map6;
  })(data)
});
var convertToNullAttr = () => ({ NULL: true });
var convertToBinaryAttr = (data) => ({ B: data });
var convertToStringAttr = (data) => ({ S: data.toString() });
var convertToBigIntAttr = (data) => ({ N: data.toString() });
var validateBigIntAndThrow = (errorPrefix) => {
  throw new Error(`${errorPrefix} ${typeof BigInt === "function" ? "Use BigInt." : "Pass string value instead."} `);
};
var convertToNumberAttr = (num) => {
  if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY].map((val2) => val2.toString()).includes(num.toString())) {
    throw new Error(`Special numeric value ${num.toString()} is not allowed`);
  } else if (num > Number.MAX_SAFE_INTEGER) {
    validateBigIntAndThrow(`Number ${num.toString()} is greater than Number.MAX_SAFE_INTEGER.`);
  } else if (num < Number.MIN_SAFE_INTEGER) {
    validateBigIntAndThrow(`Number ${num.toString()} is lesser than Number.MIN_SAFE_INTEGER.`);
  }
  return { N: num.toString() };
};
var isBinary = (data) => {
  const binaryTypes = [
    "ArrayBuffer",
    "Blob",
    "Buffer",
    "DataView",
    "File",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  if (data?.constructor) {
    return binaryTypes.includes(data.constructor.name);
  }
  return false;
};

// ../../lib/data-core/node_modules/@aws-sdk/util-dynamodb/dist-es/convertToNative.js
var convertToNative = (data, options) => {
  for (const [key, value] of Object.entries(data)) {
    if (value !== void 0) {
      switch (key) {
        case "NULL":
          return null;
        case "BOOL":
          return Boolean(value);
        case "N":
          return convertNumber(value, options);
        case "B":
          return convertBinary(value);
        case "S":
          return convertString(value);
        case "L":
          return convertList(value, options);
        case "M":
          return convertMap(value, options);
        case "NS":
          return new Set(value.map((item) => convertNumber(item, options)));
        case "BS":
          return new Set(value.map(convertBinary));
        case "SS":
          return new Set(value.map(convertString));
        default:
          throw new Error(`Unsupported type passed: ${key}`);
      }
    }
  }
  throw new Error(`No value defined: ${JSON.stringify(data)}`);
};
var convertNumber = (numString, options) => {
  if (options?.wrapNumbers) {
    return { value: numString };
  }
  const num = Number(numString);
  const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  if ((num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num)) {
    if (typeof BigInt === "function") {
      try {
        return BigInt(numString);
      } catch (error) {
        throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);
      }
    } else {
      throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);
    }
  }
  return num;
};
var convertString = (stringValue) => stringValue;
var convertBinary = (binaryValue) => binaryValue;
var convertList = (list, options) => list.map((item) => convertToNative(item, options));
var convertMap = (map6, options) => Object.entries(map6).reduce((acc, [key, value]) => (acc[key] = convertToNative(value, options), acc), {});

// ../../lib/data-core/node_modules/@aws-sdk/util-dynamodb/dist-es/marshall.js
function marshall(data, options) {
  const attributeValue = convertToAttr(data, options);
  const [key, value] = Object.entries(attributeValue)[0];
  switch (key) {
    case "M":
    case "L":
      return value;
    case "SS":
    case "NS":
    case "BS":
    case "S":
    case "N":
    case "B":
    case "NULL":
    case "BOOL":
    case "$unknown":
    default:
      return attributeValue;
  }
}

// ../../lib/data-core/node_modules/@aws-sdk/util-dynamodb/dist-es/unmarshall.js
var unmarshall = (data, options) => convertToNative({ M: data }, options);

// ../../lib/data-core/src/itemSize.ts
var BASE_LOGICAL_SIZE_OF_NESTED_TYPES = 1;
var LOGICAL_SIZE_OF_EMPTY_DOCUMENT = 3;
var calculateItemSizeInBytes = (item) => {
  if (!item) {
    return 0;
  }
  let size = 0;
  for (const name in item) {
    if (!item.hasOwnProperty(name)) {
      continue;
    }
    size += Buffer.byteLength(name);
    size += calculateAttributeSizeInBytes(item[name]);
  }
  return size;
};
var calculateAttributeSizeInBytes = (attr) => {
  if (!attr) {
    return 0;
  }
  if (attr.hasOwnProperty("B")) {
    return Buffer.from(attr.B, "base64").length;
  }
  if (attr.hasOwnProperty("S")) {
    return Buffer.byteLength(attr.S);
  }
  if (attr.hasOwnProperty("N")) {
    return calculateNumberSizeInBytes(attr.N);
  }
  if (attr.hasOwnProperty("BS")) {
    let size = 0;
    for (let i10 = 0; i10 < attr.BS.length; i10++) {
      size += Buffer.from(attr.BS[i10], "base64").length;
    }
    return size;
  }
  if (attr.hasOwnProperty("SS")) {
    let size = 0;
    for (let i10 = 0; i10 < attr.SS.length; i10++) {
      size += Buffer.byteLength(attr.SS[i10]);
    }
    return size;
  }
  if (attr.hasOwnProperty("NS")) {
    let size = 0;
    for (let i10 = 0; i10 < attr.NS.length; i10++) {
      size += calculateNumberSizeInBytes(attr.NS[i10]);
    }
    return size;
  }
  if (attr.hasOwnProperty("BOOL")) {
    return 1;
  }
  if (attr.hasOwnProperty("NULL")) {
    return 1;
  }
  if (attr.hasOwnProperty("M")) {
    let size = LOGICAL_SIZE_OF_EMPTY_DOCUMENT;
    for (const name in attr.M) {
      if (!attr.M.hasOwnProperty(name)) {
        continue;
      }
      size += Buffer.byteLength(name);
      size += calculateAttributeSizeInBytes(attr.M[name]);
      size += BASE_LOGICAL_SIZE_OF_NESTED_TYPES;
    }
    return size;
  }
  if (attr.hasOwnProperty("L")) {
    let size = LOGICAL_SIZE_OF_EMPTY_DOCUMENT;
    for (let i10 = 0; i10 < attr.L.length; i10++) {
      size += calculateAttributeSizeInBytes(attr.L[i10]);
      size += BASE_LOGICAL_SIZE_OF_NESTED_TYPES;
    }
    return size;
  }
  throw "unknown data type in " + JSON.stringify(attr);
};
var calculateNumberSizeInBytes = (n10) => {
  const number2 = new Number(n10);
  if (number2 == 0) {
    return 1;
  }
  const fixed = number2.toFixed();
  let size = measure(fixed.replace("-", "")) + 1;
  if (fixed.startsWith("-")) {
    size++;
  }
  if (size > 21) {
    size = 21;
  }
  return size;
};
var measure = (n10) => {
  if (n10.indexOf(".") !== -1) {
    const parts = n10.split(".");
    let p0 = parts[0];
    let p1 = parts[1];
    if (p0 === "0") {
      p0 = "";
      p1 = zeros(p1, true);
    }
    if (p0.length % 2 !== 0) {
      p0 = "Z" + p0;
    }
    if (p1.length % 2 !== 0) {
      p1 = p1 + "Z";
    }
    return measure(p0 + p1);
  }
  n10 = zeros(n10, true, true);
  return Math.ceil(n10.length / 2);
};
var zeros = (n10, left, right) => {
  while (left && true) {
    const t5 = n10.replace(/^(0{2})/, "");
    if (t5.length == n10.length) {
      break;
    }
    n10 = t5;
  }
  while (right && true) {
    const t5 = n10.replace(/(0{2})$/, "");
    if (t5.length == n10.length) {
      break;
    }
    n10 = t5;
  }
  return n10;
};

// ../../lib/data-core/src/params.ts
var import_deepmerge = __toESM(require_cjs(), 1);
var _marshall = (data) => marshall(data, { removeUndefinedValues: true });
var get = (table, key, options = {}) => {
  const { pk, sk, kv } = parseKey(key);
  const label = options.label ? getLabelIndex(options.label) : void 0;
  const reverse = options.reverse === true ? true : false;
  const start = options.start;
  let isQuery = true;
  let limit = 100;
  if (options.limit) {
    if (Number.isInteger(options.limit) && options.limit > 0 && options.limit <= 1e3) {
      limit = options.limit;
    } else {
      throw new ValidationError2(`'limit' must be between 1 and 1000`);
    }
  }
  if (sk.indexOf("*") > -1 && sk.indexOf("*") < sk.length - 1) {
    throw new ValidationError2(`Wildcards ('*') can only be used at the end of a key expression`);
  }
  let expression = "#pk = :pk";
  const names = { "#pk": label ? `pk${label}` : "pk" };
  const values = { ":pk": pk };
  if (kv) {
    expression += " AND #sk = :sk";
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = "0";
    isQuery = false;
  } else if (sk.startsWith("<=")) {
    expression += ` AND #sk <= :sk`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.slice(2).trim().replace("*", "");
    if (values[":sk"] === "") {
      throw new ValidationError2(`You must supply a key name after '<='`);
    }
  } else if (sk.startsWith("<")) {
    expression += ` AND #sk < :sk`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.slice(1).trim().replace("*", "");
    if (values[":sk"] === "") {
      throw new ValidationError2(`You must supply a key name after '<'`);
    }
  } else if (sk.startsWith(">=")) {
    expression += ` AND #sk >= :sk`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.slice(2).trim().replace("*", "");
    if (values[":sk"] === "") {
      throw new ValidationError2(`You must supply a key name after '>='`);
    }
  } else if (sk.startsWith(">")) {
    expression += ` AND #sk > :sk`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.slice(1).trim().replace("*", "");
    if (values[":sk"] === "") {
      throw new ValidationError2(`You must supply a key name after '>'`);
    }
  } else if (sk.includes("|")) {
    expression += ` AND #sk between :sk AND :sk0`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.split("|")[0].trim().replace("*", "");
    values[":sk0"] = sk.split("|")[1].trim().replace("*", "");
    if (values[":sk"] === "" || values[":sk0"] === "") {
      throw new ValidationError2(`You must supply a key name before and after '|'`);
    }
  } else if (sk !== "*" && sk.endsWith("*")) {
    expression += ` AND begins_with(#sk,:sk)`;
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk.slice(0, sk.length - 1);
  } else if (sk !== "" && sk !== "*") {
    expression += " AND #sk = :sk";
    names["#sk"] = label ? `sk${label}` : "sk";
    values[":sk"] = sk;
    isQuery = false;
  }
  names["#ttl"] = "ttl";
  values[":ttl"] = Date.now() / 1e3 | 0;
  return {
    isQuery,
    payload: Object.assign(
      {
        TableName: table,
        KeyConditionExpression: expression,
        ExpressionAttributeNames: names,
        ExpressionAttributeValues: _marshall(values),
        Limit: limit,
        ScanIndexForward: !reverse,
        FilterExpression: "#ttl >= :ttl OR attribute_not_exists(#ttl)",
        ReturnConsumedCapacity: "TOTAL"
      },
      label ? { IndexName: `gsi${label}` } : null,
      start ? { ExclusiveStartKey: _marshall(startKey(start, label)) } : null
    )
  };
};
var getBatch = (table, keys, options = {}) => {
  const { meta, ...opts } = options;
  if (Object.keys(opts).length > 0) {
    throw new ValidationError2(`Invalid options for batch get request: ${Object.keys(opts).join(", ")}`);
  }
  if (!Array.isArray(keys)) {
    throw new ValidationError2(`Please provide an array of keys`);
  }
  if (keys.length === 0) {
    throw new ValidationError2(`You must provide at least one key`);
  }
  if (keys.length > 25) {
    throw new ValidationError2(`You may only provide a maximum of 25 keys in one batch get request`);
  }
  const items = [];
  for (const key of keys) {
    const { pk, sk } = parseKey(key);
    items.push({ pk: { S: pk }, sk: { S: sk } });
  }
  return {
    RequestItems: {
      [table]: {
        Keys: items
      }
    },
    ReturnConsumedCapacity: "TOTAL"
  };
};
var scan = (table, options = {}) => {
  const label = options.label ? getLabelIndex(options.label) : null;
  const attributes = options.attributes ? [...Array.from(/* @__PURE__ */ new Set([...options.attributes, ...["pk", "sk"]]))] : [];
  let limit = 100;
  if (options.limit) {
    if (Number.isInteger(options.limit) && options.limit > 0 && options.limit <= 1e3) {
      limit = options.limit;
    } else {
      throw new ValidationError2(`'limit' must be between 1 and 1000`);
    }
  }
  return Object.assign(
    {
      TableName: table,
      Limit: limit,
      ReturnConsumedCapacity: "TOTAL"
    },
    label ? { IndexName: `gsi${label}` } : null,
    options.start ? { ExclusiveStartKey: _marshall(startKey(options.start)) } : null,
    options.segment && options.totalSegments ? {
      Segment: options.segment,
      TotalSegments: options.totalSegments
    } : null,
    attributes.length > 0 ? {
      ProjectionExpression: attributes.join(","),
      Select: "SPECIFIC_ATTRIBUTES"
    } : null
  );
};
var set3 = (table, key, value, options = {}) => {
  const { pk, sk, kv, Item, isObj, labels, ttl, created, now, size, mvalue } = formatItem(key, value, options);
  const meta = options.meta === true ? true : false;
  const overwrite = options.overwrite === true ? true : false;
  const removeNulls = options.removeNulls === false ? false : true;
  const exists = typeof options.exists === "boolean" ? options.exists : void 0;
  const ConditionExpression = [];
  if (created) {
    ConditionExpression.push("#ct = :created");
  }
  if (exists === false) {
    ConditionExpression.push("(attribute_not_exists(pk))");
  } else if (exists === true) {
    ConditionExpression.push("(attribute_exists(pk))");
  }
  if (overwrite) {
    const command = Object.assign(
      {
        TableName: table,
        Item,
        ReturnConsumedCapacity: "TOTAL"
      },
      ConditionExpression.length > 0 ? { ConditionExpression: ConditionExpression.join(" AND "), ReturnValuesOnConditionCheckFailure: "ALL_OLD" } : null,
      created ? {
        ExpressionAttributeNames: { "#ct": "ct" },
        ExpressionAttributeValues: _marshall({
          ":created": created
        })
      } : null
    );
    return {
      command,
      size
    };
  } else {
    const SET = ["#ct = if_not_exists(#ct,:ct), #md = :md"];
    const REMOVE = [];
    const ADD = [];
    const names = {};
    const values = {};
    if (isObj) {
      const attrs = Object.keys(mvalue);
      for (const i10 in attrs) {
        const val2 = mvalue[attrs[i10]];
        if (val2 === void 0 || val2 === null && removeNulls) {
          REMOVE.push(`#a${i10}`);
          names[`#a${i10}`] = `_${attrs[i10]}`;
        } else {
          const valObj = isObject2(val2);
          if (valObj && val2["$add"] !== void 0 && Object.keys(val2).length > 1) {
            throw new ValidationError2(`'$add' is a reserved keyword and must be in an object with a single key of $add`);
          }
          if (valObj && // is an object
          val2["$add"] !== void 0) {
            if (value[attrs[i10]] !== mvalue[attrs[i10]]) {
              throw new ValidationError2(`'$add' cannot be used as a default (${attrs[i10]})`);
            } else if (isNaN(val2["$add"])) {
              throw new ValidationError2(`'${attrs[i10]}' must be a number when using $add`);
            } else {
              ADD.push(`#a${i10} :a${i10}`);
              names[`#a${i10}`] = `_${attrs[i10]}`;
              values[`:a${i10}`] = Number(val2["$add"]);
            }
          } else {
            value = value ?? {};
            if (value[attrs[i10]] === void 0 && value[attrs[i10]] !== mvalue[attrs[i10]]) {
              SET.push(`#a${i10} = if_not_exists(#a${i10},:a${i10})`);
            } else {
              SET.push(`#a${i10} = :a${i10}`);
            }
            names[`#a${i10}`] = `_${attrs[i10]}`;
            values[`:a${i10}`] = val2;
          }
        }
      }
      REMOVE.push("#val");
      names["#val"] = "val";
    } else {
      if (isObject2(value) && value["$add"] !== void 0) {
        if (isNaN(value["$add"])) {
          throw new ValidationError2(`'value' must be a number when using $add`);
        } else {
          ADD.push("#val :val");
          names["#val"] = "val";
          values[":val"] = Number(value["$add"]);
        }
      } else {
        if ((value ?? void 0) === void 0) {
          SET.push(`#val = if_not_exists(#val,:val)`);
        } else {
          SET.push("#val = :val");
        }
        names["#val"] = "val";
        values[":val"] = mvalue;
      }
    }
    if (kv) {
      SET.push("#kv = :kv");
      names["#kv"] = "kv";
      values[":kv"] = true;
    } else {
      REMOVE.push("#kv");
      names["#kv"] = "kv";
    }
    for (const i10 in labels) {
      if ((labels[i10] ?? void 0) === void 0) {
        REMOVE.push(`#pk${i10}`);
        REMOVE.push(`#sk${i10}`);
        REMOVE.push(`#kv${i10}`);
        names[`#pk${i10}`] = `pk${i10}`;
        names[`#sk${i10}`] = `sk${i10}`;
        names[`#kv${i10}`] = `kv${i10}`;
      } else {
        if (labels[i10]?.default) {
          SET.push(`#pk${i10} = if_not_exists(#pk${i10},:pk${i10}),#sk${i10} = if_not_exists(#sk${i10},:sk${i10})`);
        } else {
          SET.push(`#pk${i10} = :pk${i10}, #sk${i10} = :sk${i10}`);
        }
        names[`#pk${i10}`] = `pk${i10}`;
        names[`#sk${i10}`] = `sk${i10}`;
        values[`:pk${i10}`] = labels[i10].pk;
        values[`:sk${i10}`] = labels[i10].sk;
        if (labels[i10].kv || labels[i10]?.default) {
          if (labels[i10]?.default) {
            SET.push(`#kv${i10} = if_not_exists(#kv${i10},:kv${i10})`);
          } else {
            SET.push(`#kv${i10} = :kv${i10}`);
          }
          names[`#kv${i10}`] = `kv${i10}`;
          values[`:kv${i10}`] = labels[i10].kv;
        } else {
          REMOVE.push(`#kv${i10}`);
          names[`#kv${i10}`] = `kv${i10}`;
        }
      }
    }
    if (ttl !== void 0) {
      if (ttl === null) {
        REMOVE.push("#ttl");
        names["#ttl"] = "ttl";
      } else {
        SET.push("#ttl = :ttl");
        names["#ttl"] = "ttl";
        values[":ttl"] = ttl;
      }
    }
    const ConditionExpression2 = [];
    if (!isObj) {
      ConditionExpression2.push("((attribute_exists(pk) AND attribute_exists(val)) OR attribute_not_exists(pk))");
    }
    if (exists === false) {
      ConditionExpression2.push("(attribute_not_exists(pk))");
    } else if (exists === true) {
      ConditionExpression2.push("(attribute_exists(pk))");
    }
    return {
      command: Object.assign(
        {
          TableName: table,
          Key: _marshall({ pk, sk: sk === void 0 ? "0" : sk }),
          UpdateExpression: `SET ${SET.join(",")}` + (REMOVE.length > 0 ? ` REMOVE ${REMOVE.join(",")}` : "") + (ADD.length > 0 ? ` ADD ${ADD.join(",")}` : ""),
          ExpressionAttributeNames: Object.assign({ "#ct": "ct", "#md": "md" }, names),
          ExpressionAttributeValues: _marshall(Object.assign({ ":ct": now, ":md": now }, values)),
          ReturnValues: "ALL_NEW",
          ReturnConsumedCapacity: "TOTAL"
        },
        ConditionExpression2.length > 0 ? {
          ConditionExpression: ConditionExpression2.join(" AND "),
          ReturnValuesOnConditionCheckFailure: "ALL_OLD"
        } : null
      ),
      size
    };
  }
};
var setBatch = (table, items, options = {}) => {
  const removeNulls = options.removeNulls === false ? false : true;
  if (!Array.isArray(items)) {
    throw new ValidationError2(`Please provide an array of items`);
  }
  if (items.length === 0) {
    throw new ValidationError2(`You must provide at least one item`);
  }
  if (items.length > 25) {
    throw new ValidationError2(`You may only provide a maximum of 25 items in one batch set request`);
  }
  const requestItems = items.map((item) => {
    if (!item.key || typeof item.key !== "string" || item.key.length === 0) {
      throw new ValidationError2(`A string value of 'key' must be provided in each item`);
    }
    if (!item.hasOwnProperty("value")) {
      throw new ValidationError2(`A 'value' must be provided in each item`);
    }
    const { label1, label2, label3, label4, label5, ttl, default: _default } = item;
    const { Item, size } = formatItem(item.key, item.value, {
      label1,
      label2,
      label3,
      label4,
      label5,
      ttl,
      removeNulls,
      default: _default
    });
    return {
      command: {
        PutRequest: {
          Item
        }
      },
      size
    };
  });
  const totalSize = requestItems.reduce((acc, item) => acc + item.size, 0);
  return {
    command: {
      RequestItems: {
        [table]: requestItems.map((item) => item.command)
      },
      ReturnConsumedCapacity: "TOTAL"
    },
    size: totalSize
  };
};
var remove = (table, key) => {
  const { pk, sk } = parseKey(key);
  if (sk.endsWith("*") || sk.startsWith(">") || sk.startsWith(">") || sk.includes("|")) {
    throw new ValidationError2("You cannot delete items using conditionals. Please remove each item separately.");
  }
  return {
    TableName: table,
    Key: _marshall({ pk, sk }),
    ReturnConsumedCapacity: "TOTAL",
    ReturnValues: "ALL_OLD"
  };
};
var removeBatch = (table, keys) => {
  if (!Array.isArray(keys)) {
    throw new ValidationError2(`Please provide an array of keys`);
  }
  if (keys.length === 0) {
    throw new ValidationError2(`You must provide at least one key`);
  }
  if (keys.length > 25) {
    throw new ValidationError2(`You may only provide a maximum of 25 keys in one batch remove request`);
  }
  const items = [];
  for (const key of keys) {
    const { pk, sk } = parseKey(key);
    items.push({
      DeleteRequest: {
        Key: {
          pk: { S: pk },
          sk: { S: sk }
        }
      }
    });
  }
  return {
    RequestItems: {
      [table]: items
    },
    ReturnConsumedCapacity: "TOTAL",
    ReturnValues: "ALL_OLD"
  };
};
var getLabelIndex = (label) => {
  const results = label.match(/^(label){0,1}(\d{1})$/);
  if (results && results[2] && [1, 2, 3, 4, 5].includes(Number(results[2]))) {
    return Number(results[2]);
  } else {
    throw new ValidationError2(`Labels must be specified as 'label1' through 'label5'.`);
  }
};
var assignLabel = (index, key) => {
  return Object.assign(
    {
      [`pk${index}`]: key.pk,
      [`sk${index}`]: key.sk
    },
    key.kv ? { [`kv${index}`]: true } : null
  );
};
var startKey = (key, label) => {
  if (label) {
    const [primary, gsi] = key.split("|");
    const { pk, sk } = parseKey(primary);
    const { pk: lpk, sk: lsk } = parseKey(gsi);
    return {
      pk,
      sk,
      [`pk${label}`]: lpk,
      [`sk${label}`]: lsk
    };
  } else {
    const { pk, sk } = parseKey(key);
    return { pk, sk };
  }
};
var parseKey = (key, label) => {
  let _default = false;
  if (typeof label === "number" && Array.isArray(key)) {
    key = key[0];
    _default = true;
  }
  const parsedKey = typeof key === "string" ? key.split(":").map((x4) => x4.trim()) : [""];
  if (parsedKey[0] === "" || parsedKey.length > 1 && parsedKey[1] === "") {
    throw new ValidationError2("Invalid key");
  }
  const pk = parsedKey.shift();
  const sk = parsedKey.length > 0 ? parsedKey.join(":") : "0";
  const pkSize = Buffer.byteLength(pk);
  const skSize = Buffer.byteLength(sk);
  if (parsedKey.length === 0 && pkSize > 256 || parsedKey.length > 0 && skSize > 256) {
    throw new ValidationError2("Invalid key: Maximum Key size is 256 bytes");
  }
  if (parsedKey.length > 0 && pkSize > 256) {
    throw new ValidationError2("Invalid key: Maximum collection name size is 256 bytes");
  }
  return {
    pk,
    sk,
    kv: parsedKey.length === 0,
    ..._default ? { default: true } : {}
    // Only include if true
  };
};
var parseResults = (data, meta = false, multi = false) => {
  const {
    pk,
    sk,
    val: val2,
    ct,
    md,
    // standard meta data
    pk1,
    sk1,
    pk2,
    sk2,
    pk3,
    sk3,
    pk4,
    sk4,
    pk5,
    sk5,
    // labels/GSIs
    kv,
    kv1,
    kv2,
    kv3,
    kv4,
    kv5,
    // simple kv flags
    ttl,
    ...attrs
    // ttl and user specified attributes
  } = unmarshall(data);
  if (meta || multi) {
    return Object.assign(
      {
        key: pk + (kv ? "" : `:${sk}`),
        value: val2 !== void 0 ? val2 : formatAttrs(attrs)
      },
      meta ? Object.assign(
        {},
        ct ? { created: new Date(ct * 1e3) } : null,
        md ? { modified: new Date(md * 1e3) } : null,
        pk1 !== void 0 ? { label1: pk1 + (kv1 ? "" : `:${sk1}`) } : null,
        pk2 !== void 0 ? { label2: pk2 + (kv2 ? "" : `:${sk2}`) } : null,
        pk3 !== void 0 ? { label3: pk3 + (kv3 ? "" : `:${sk3}`) } : null,
        pk4 !== void 0 ? { label4: pk4 + (kv4 ? "" : `:${sk4}`) } : null,
        pk5 !== void 0 ? { label5: pk5 + (kv5 ? "" : `:${sk5}`) } : null,
        ttl !== void 0 ? { ttl: new Date(ttl * 1e3) } : null
      ) : null
    );
  } else {
    return val2 !== void 0 ? val2 : formatAttrs(attrs);
  }
};
var formatAttrs = (data) => {
  return Object.keys(data).reduce((acc, x4) => {
    return Object.assign(acc, { [x4.substring(1)]: data[x4] });
  }, {});
};
var isObject2 = (value) => (value ?? void 0) !== void 0 && typeof value === "object" && !Array.isArray(value);
var formatItem = (key, value, options) => {
  const removeNulls = options.removeNulls === false ? false : true;
  const { pk, sk, kv } = parseKey(key);
  if (sk.includes("|") || sk.includes("*")) {
    throw new ValidationError2(`Invalid key: Key names in collections cannot contain the '|' or the '*' characters.`);
  }
  if (sk.startsWith(">") || sk.startsWith("<")) {
    throw new ValidationError2(`Invalid key: Key names in collections cannot start with the '>' or '<' characters.`);
  }
  const now = Date.now() / 1e3 | 0;
  if ((value ?? void 0) !== void 0 && isObject2(value) && Object.keys(value).includes("$add")) {
    if (Object.keys(value).length > 1) {
      throw new ValidationError2(`'$add' is a reserved keyword and must be in an object with a single key of $add`);
    } else if (isNaN(value["$add"])) {
      throw new ValidationError2(`'value' must be a number when using $add`);
    } else {
      value = Number(value["$add"]);
    }
  }
  let isObj = isObject2(value);
  if ((options.default ?? void 0) !== void 0) {
    if (isObject2(options.default) && options.default["$add"] !== void 0) {
      throw new ValidationError2(`'default' cannot use the $add keyword`);
    } else if (isObj && isObject2(options.default)) {
      value = (0, import_deepmerge.default)(options.default, value, {
        arrayMerge: (destinationArray, sourceArray, options2) => sourceArray
      });
    } else if ((value ?? void 0) === void 0) {
      value = options.default;
      isObj = isObject2(value);
    } else if ((Array.isArray(value) ? "array" : typeof value) !== (Array.isArray(options.default) ? "array" : typeof options.default)) {
      throw new ValidationError2(`'default' must be of the same type as the value`);
    }
  } else if (value === void 0 || value === null && removeNulls) {
    throw new ValidationError2(`Value can not be undefined without setting a 'default'`);
  }
  const labels = Object.assign(
    options.hasOwnProperty("label1") ? { 1: (options.label1 ?? void 0) !== void 0 ? parseKey(options.label1, 1) : void 0 } : {},
    options.hasOwnProperty("label2") ? { 2: (options.label2 ?? void 0) !== void 0 ? parseKey(options.label2, 2) : void 0 } : {},
    options.hasOwnProperty("label3") ? { 3: (options.label3 ?? void 0) !== void 0 ? parseKey(options.label3, 3) : void 0 } : {},
    options.hasOwnProperty("label4") ? { 4: (options.label4 ?? void 0) !== void 0 ? parseKey(options.label4, 4) : void 0 } : {},
    options.hasOwnProperty("label5") ? { 5: (options.label5 ?? void 0) !== void 0 ? parseKey(options.label5, 5) : void 0 } : {}
  );
  let created;
  if (options.created !== void 0) {
    if (typeof options.created === "number") {
      created = options.created;
    } else {
      throw new ValidationError2(`'created' value must be a number`);
    }
  }
  let ttl;
  if (options.ttl !== void 0) {
    if (typeof options.ttl === "number" && Number.isInteger(options.ttl)) {
      if (options.ttl < 60 * 60 * 24 * 365 * 10) {
        ttl = now + options.ttl;
      } else {
        ttl = options.ttl;
      }
    } else if (options.ttl === null) {
      ttl = null;
    } else if (!isNaN(Date.parse(String(options.ttl)))) {
      ttl = Date.parse(String(options.ttl)) / 1e3 | 0;
    } else {
      throw new ValidationError2("Invalid ttl value.");
    }
  }
  const Item = _marshall(
    Object.assign(
      {
        pk,
        sk,
        ct: created ? created : now,
        md: now
      },
      kv ? { kv: true } : null,
      labels[1] == null ? null : assignLabel(1, labels[1]),
      labels[2] == null ? null : assignLabel(2, labels[2]),
      labels[3] == null ? null : assignLabel(3, labels[3]),
      labels[4] == null ? null : assignLabel(4, labels[4]),
      labels[5] == null ? null : assignLabel(5, labels[5]),
      ttl == null ? null : { ttl },
      isObj ? Object.keys(value).reduce((acc, x4) => {
        let curVal = value[x4];
        if (value[x4] && value[x4]["$add"] !== void 0) {
          if (Object.keys(value[x4]).length > 1) {
            throw new ValidationError2(
              `'$add' is a reserved keyword and must be in an object with a single key of $add`
            );
          } else if (isNaN(value[x4]["$add"])) {
            throw new ValidationError2(`'value' must be a number when using $add`);
          } else {
            curVal = Number(value[x4]["$add"]);
          }
        }
        return Object.assign(acc, curVal === null && removeNulls === true ? {} : { [`_${x4}`]: curVal });
      }, {}) : { val: value }
    )
  );
  const size = calculateItemSizeInBytes(Item);
  if (size > 1024 * 400) {
    throw new ValidationError2(`Item size of ${(size / 1024).toFixed(2)} KB is greater than the maximum size of 400 KB.`);
  }
  return { pk, sk, kv, Item, isObj, labels, ttl, created, now, size, mvalue: value };
};
var params_default = { get, getBatch, set: set3, setBatch, remove, removeBatch, scan };

// ../../lib/data-core/src/index.ts
function getClient2() {
  return new DynamoDBClient({});
}
var reportConsumedCapacityUnits = (type, consumedCapacity) => {
  let unitsConsumed;
  const key = type === "write" ? "WriteCapacityUnits" : "ReadCapacityUnits";
  if (consumedCapacity) {
    if (Array.isArray(consumedCapacity)) {
      unitsConsumed = consumedCapacity.reduce((acc, curr) => acc + (curr[key] || 0), 0);
    } else {
      unitsConsumed = consumedCapacity[key] || 0;
    }
  }
  if (unitsConsumed) {
    const operation = type === "write" ? "ddbWriteUnits" : "ddbReadUnits";
    telemetry_default.count(operation, unitsConsumed, "data");
  }
};
var getByLabel = async (client, table, label, keys, options = {}) => {
  if (options === true) {
    options = { meta: true };
  }
  return await get2(client, table, keys, Object.assign(options, { label }));
};
var genStartKey = (lastKey, labelIndex) => {
  if (labelIndex) {
    const indexPk = `pk${labelIndex}`;
    const indexSk = `sk${labelIndex}`;
    return `${lastKey.pk?.S}:${lastKey.sk?.S}|${lastKey[indexPk]?.S}:${lastKey[indexSk]?.S}`;
  }
  return `${lastKey.pk?.S}:${lastKey.sk?.S}`;
};
var get2 = async (client, table, keys, options = {}) => {
  if (typeof options === "boolean") {
    options = { meta: true };
  }
  if (Array.isArray(keys)) {
    const { meta } = options;
    const batchParams = params_default.getBatch(table, keys, options);
    const command = new BatchGetItemCommand(batchParams);
    const data = await client.send(command);
    reportConsumedCapacityUnits("read", data.ConsumedCapacity);
    if (data.Responses) {
      return {
        items: data.Responses[table].map((x4) => parseResults(x4, meta, true))
      };
    }
  } else {
    const { meta = false, label, ...opts } = options;
    const labelIndex = label ? getLabelIndex(label) : void 0;
    const { payload, isQuery } = params_default.get(table, keys, options);
    const command = new QueryCommand(payload);
    const data = await client.send(command);
    reportConsumedCapacityUnits("read", data.ConsumedCapacity);
    telemetry_default.count("dataRequests", 1, "data");
    if (data.Items) {
      if (!isQuery && label === void 0 && data.Items.length > 0) {
        return parseResults(data.Items[0], meta);
      } else if (!isQuery && label === void 0) {
        return void 0;
      } else {
        return {
          items: data.Items.map((x4) => parseResults(x4, meta, true)),
          ...data.LastEvaluatedKey ? {
            lastKey: genStartKey(data.LastEvaluatedKey, labelIndex),
            next: () => get2(
              client,
              table,
              keys,
              Object.assign(options, {
                start: data.LastEvaluatedKey ? genStartKey(data.LastEvaluatedKey, labelIndex) : void 0
              })
            )
          } : null
        };
      }
    } else {
      return isQuery ? { items: [] } : void 0;
    }
  }
};
var set4 = async (client, table, keys, value, opts) => {
  if (Array.isArray(keys)) {
    const options = (typeof value === "boolean" ? { meta: true } : value) || {};
    const meta = options.meta === true ? true : false;
    const { command: batchParams, size } = params_default.setBatch(table, keys, options);
    const command = new BatchWriteItemCommand(batchParams);
    const data = await client.send(command);
    reportConsumedCapacityUnits("write", data.ConsumedCapacity);
    telemetry_default.count("ddbDeltaKbs", size / 1024, "data");
    const items = batchParams.RequestItems[table].map(
      (x4) => parseResults(x4.PutRequest?.Item, meta, true)
    );
    if (data.UnprocessedItems && data.UnprocessedItems?.[table]) {
      return {
        items,
        unprocessed: data.UnprocessedItems?.[table]?.map(
          (x4) => parseResults(x4.PutRequest?.Item, meta, true)
        )
      };
    } else {
      return {
        items: batchParams.RequestItems?.[table].map(
          (x4) => parseResults(x4.PutRequest?.Item, meta, true)
        )
      };
    }
  } else {
    const options = (typeof opts === "boolean" ? { meta: true } : opts) || {};
    const meta = options.meta === true ? true : false;
    const overwrite = options.overwrite === true ? true : false;
    const exists = typeof options.exists === "boolean" ? options.exists : void 0;
    const { command: setParams, size } = params_default.set(table, keys, value, options);
    if (overwrite) {
      const _putParams = setParams;
      const command = new PutItemCommand(_putParams);
      try {
        const data = await client.send(command);
        reportConsumedCapacityUnits("write", data.ConsumedCapacity);
        telemetry_default.count("ddbDeltaKbs", size / 1024, "data");
        if (meta) {
          return parseResults(_putParams.Item, true);
        } else {
          return parseResults(_putParams.Item, false);
        }
      } catch (e10) {
        if (e10.name === "ConditionalCheckFailedException") {
          if (exists === false && e10.Item !== void 0) {
            throw new Error("Item already exists");
          } else if (exists === true && e10.Item === void 0) {
            throw new Error("Item does not exist");
          } else {
            throw new Error(`The 'created' date integrity check failed. The dates must match.`);
          }
        } else {
          throw e10;
        }
      }
    } else {
      const command = new UpdateItemCommand(setParams);
      try {
        const data = await client.send(command);
        telemetry_default.count("ddbDeltaKbs", size / 1024, "data");
        return parseResults(data.Attributes, meta);
      } catch (e10) {
        if (e10.name === "ConditionalCheckFailedException") {
          if (exists === false && e10.Item !== void 0) {
            throw new Error("Item already exists");
          } else if (exists === true && e10.Item === void 0) {
            throw new Error("Item does not exist");
          } else {
            throw new Error("Cannot convert an existing object to a simple value.");
          }
        } else {
          if (e10.name === "ValidationException") {
            if (e10.message === "Item size to update has exceeded the maximum allowed size") {
              throw new Error("Item size to update is greater than the maximum size of 400 KB.");
            }
          }
          throw e10;
        }
      }
    }
  }
};
var remove2 = async (client, table, keys) => {
  if (Array.isArray(keys)) {
    const batchParams = params_default.removeBatch(table, keys);
    const command = new BatchWriteItemCommand(batchParams);
    const data = await client.send(command);
    reportConsumedCapacityUnits("write", data.ConsumedCapacity);
    if (data.UnprocessedItems) {
      return false;
    } else {
      return true;
    }
  } else {
    const removeParams = params_default.remove(table, keys);
    const command = new DeleteItemCommand(removeParams);
    const { Attributes, ConsumedCapacity: ConsumedCapacity2 } = await client.send(command);
    reportConsumedCapacityUnits("write", ConsumedCapacity2);
    if (Attributes) {
      const size = calculateItemSizeInBytes(Attributes);
      telemetry_default.count("ddbDeltaKbs", size / 1024 * -1, "data");
    }
    return true;
  }
};

// ../../lib/system-data/system-data.ts
var SystemData = class _SystemData {
  constructor(client, table) {
    this.client = client;
    this.table = table;
    this.client = client;
    this.table = table;
  }
  static create() {
    const table = "sys-d2a57dc1";
    const client = getClient2();
    return new _SystemData(client, table);
  }
  get(keys, options = {}) {
    return get2(this.client, this.table, keys, options);
  }
  set(keys, value, options = {}) {
    return set4(this.client, this.table, keys, value, options);
  }
  getByLabel(label, keys, options = {}) {
    return getByLabel(this.client, this.table, label, keys, options);
  }
  remove(keys) {
    return remove2(this.client, this.table, keys);
  }
};
var systemData = SystemData.create();

// ../../lib/events-core/parse-after.ts
var import_dayjs2 = __toESM(require_dayjs_min(), 1);
var import_utc2 = __toESM(require_utc(), 1);
import_dayjs2.default.extend(import_utc2.default);
var MAX_NUMERIC_OFFSET = 10 * 365 * 24 * 60 * 60 * 1e3;
function validUnit2(unit, items) {
  return items.includes(unit) || items.includes(unit + "s");
}
function parseAfter(after, base) {
  if (!after) {
    return base;
  }
  if (typeof after === "number") {
    return new Date(Math.abs(after) <= MAX_NUMERIC_OFFSET ? base + after : after).getTime();
  } else if (after instanceof Date) {
    return after.getTime();
  } else {
    const date2 = Date.parse(after);
    if (date2) {
      return date2;
    }
    try {
      const [num, unit] = after.toLowerCase().split(" ");
      if (!validUnit2(unit, ["seconds", "minutes", "hours", "days", "weeks", "months", "years"])) {
        applicationWarning(`Warning: invalid unit "${unit}" in 'after' config parameter`);
        return NaN;
      }
      return import_dayjs2.default.utc(base).add(Number.parseInt(num), unit).valueOf();
    } catch (err) {
      return NaN;
    }
  }
}

// ../../lib/events-core/index.ts
var MAX_SHARDS = 1;
var base32 = "0123456789abcdefghjkmnpqrstvwxyz";
var ONE_DAY_MS = 24 * 60 * 60 * 1e3;
var ONE_MONTH_MS = 30 * ONE_DAY_MS;
var ONE_YEAR_MS = 365 * ONE_DAY_MS;
var MAX_SQS_DELAY_MS = 15 * 60 * 1e3;
var MAX_SQS_BODY_SIZE = 256 * 1024;
var sqs = new SQS({});
function getPartitionKey(eventId) {
  const pid = eventId.slice(0, 6);
  const sid = eventId.slice(-1);
  return `${pid}_${sid}`;
}
function mintEventIdForTimestamp(timestamp) {
  return mintEventIdForTimestampAndShard(timestamp, randomShard());
}
function mintEventIdForTimestampAndShard(timestamp, partition3) {
  const sid = base32.charAt(partition3);
  const id = ulid(timestamp).toLowerCase();
  return `${id}${sid}`;
}
function randomShard() {
  return Math.floor(Math.random() * MAX_SHARDS);
}
async function publishEvent(_name, ...args) {
  let [config, body] = args;
  if (!body) {
    body = config;
    config = {};
  }
  const { after } = config || {};
  if (!body) {
    throw new Error("Missing body for event");
  }
  const name = _name.includes(":") ? _name : `custom:${_name}`;
  const time = Date.now();
  let sendAt = parseAfter(after, time);
  if (isNaN(sendAt)) {
    throw new Error("Invalid delivery time");
  }
  if (sendAt < time) {
    sendAt = time;
  }
  const delay = sendAt - time;
  if (delay > ONE_YEAR_MS) {
    throw new Error("Event delivery must be within one year");
  }
  const id = mintEventIdForTimestamp(sendAt);
  const MessageBody = JSON.stringify({
    id,
    name,
    body,
    time,
    delay
  });
  if (MessageBody.length > MAX_SQS_BODY_SIZE) {
    throw new Error("Event body is too large");
  }
  if (delay <= MAX_SQS_DELAY_MS) {
    const message = {
      MessageBody,
      QueueUrl: process.env.EVENTS_QUEUE_URL,
      DelaySeconds: Math.ceil(delay / 1e3)
    };
    await sqs.sendMessage(message);
  } else {
    const item = {
      id,
      name,
      body: JSON.stringify(body),
      time,
      delay
    };
    const pk = getPartitionKey(id);
    await systemData.set(`ev_${pk}:${id}`, item, {
      ttl: Math.ceil((sendAt + ONE_MONTH_MS) / 1e3)
    });
  }
  return { id, time, delay };
}

// events/index.ts
var Handler = class {
  name;
  invocationType;
  callbacks;
  timeout;
  constructor(name, invocationType) {
    this.name = name;
    this.invocationType = invocationType;
    this.callbacks = [];
    this.timeout = 5e3;
  }
  push(handler) {
    this.callbacks.push(handler);
  }
  setTimeout(ms) {
    if (ms > this.timeout) {
      this.timeout = ms;
    }
  }
  async invoke(_event, context) {
    const event = { ..._event, name: _event.name?.replace(/^custom:/, "") };
    return Promise.all(this.callbacks.map((cb) => cb(event, context)));
  }
};
var Events = class {
  handlers;
  errors;
  sqs;
  constructor() {
    this.handlers = /* @__PURE__ */ new Map();
    this.errors = [];
    this.sqs = new SQSClient({});
  }
  on(_name, ...args) {
    let [config, handler] = args;
    if (!handler) {
      handler = config;
      config = {};
    }
    const name = `event:${_name.includes(":") ? _name : `custom:${_name}`}`;
    let existingHandler = this.handlers.get(name);
    if (!handler) {
      if (!existingHandler) {
        throw new Error(`No handler found for event: ${name}`);
      }
      return null;
    }
    if (!existingHandler) {
      existingHandler = new Handler(name, config.invocationType || "event");
      this.handlers.set(name, existingHandler);
    }
    let { timeout = 5e3 } = config || {};
    if (timeout > 6e4) {
      this.errors.push("Maximum timeout for event handlers is 60000 ms");
      timeout = 6e4;
    }
    existingHandler.setTimeout(timeout);
    existingHandler.push(handler);
    const invokeAll = existingHandler.invoke.bind(existingHandler);
    addEventListener(name, invokeAll, {
      source: config.source || "events",
      invocationType: config.invocationType || "event",
      timeout,
      id: name,
      name,
      meta: config.meta
    });
    return null;
  }
  async publish(_name, ...args) {
    return await publishEvent(_name, ...args);
  }
  getConfig() {
    return {
      events: Array.from(this.handlers.entries()).map(([name, handler]) => ({
        id: name,
        name,
        timeout: handler.timeout,
        invocationType: handler.invocationType
      })),
      errors: this.errors
    };
  }
  getHandlers() {
    const result = {};
    for (const [name, handler] of this.handlers.entries()) {
      result[name] = handler.invoke.bind(handler);
    }
    return result;
  }
};
var events = new Events();

// task/index.ts
var DEFAULT_TASK_TIMEOUT_MS = 3e4;
var DEFAULT_TASK_ATTEMPTS = 3;
var registry = /* @__PURE__ */ new Map();
var Task = class {
  name;
  lifecycleName;
  config;
  handler;
  constructor(name, config, handler) {
    this.name = name;
    this.lifecycleName = name.replace(/\s/g, "-");
    this.config = config;
    this.handler = handler;
  }
  every(expression, payload) {
    schedule().every(
      expression,
      {
        ...this.config,
        meta: {
          taskName: this.name
        }
      },
      () => this.run(payload)
    );
    return this;
  }
  cron(expression, payload) {
    schedule().cron(
      expression,
      {
        ...this.config,
        meta: {
          taskName: this.name
        }
      },
      () => this.run(payload)
    );
    return this;
  }
  async run(_after, _body) {
    const after = _body === void 0 ? void 0 : _after;
    const body = _body === void 0 ? _after : _body;
    const result = await executeTask(this.name, this.config, body, after);
    return {
      id: result.id
    };
  }
  // lifecycle events
  on(name, handler) {
    const eventName = `task-lifecycle:${this.lifecycleName}:${name}`;
    events.on(eventName, handler);
    return;
  }
};
function task(name, _options, _handler) {
  const options = _handler ? _options || {} : {};
  const handler = _handler ? _handler : _options;
  if (name.length > 64) {
    throw new Error("Task name must be 64 characters or less");
  }
  if (!handler) {
    throw new Error("Task handler is required");
  }
  if (registry.has(name)) {
    throw new Error(`Task ${name} already exists`);
  }
  const config = {
    timeout: options.timeout || DEFAULT_TASK_TIMEOUT_MS,
    attempts: options.attempts || DEFAULT_TASK_ATTEMPTS
  };
  if (config.timeout > MAX_TASK_TIMEOUT_MS) {
    config.timeout = MAX_TASK_TIMEOUT_MS;
    console.warn(`Task ${name} timeout was capped at ${MAX_TASK_TIMEOUT_MS}ms`);
  }
  const task2 = new Task(name, config, handler);
  registry.set(name, task2);
  addEventListener(`task:${name}`, handler, {
    source: "tasks",
    invocationType: "task",
    timeout: config.timeout,
    name
  });
  return task2;
}
task.status = async (executionId) => {
  const item = await getExecution(executionId);
  if (!item) {
    return;
  }
  return {
    id: item.id,
    name: item.name,
    body: item.body,
    state: item.state,
    createdAt: item.createdAt,
    scheduledAt: item.scheduledAt,
    submittedAt: item.submittedAt,
    startedAt: item.startedAt,
    failedAt: item.failedAt,
    completedAt: item.completedAt,
    progressedAt: item.progressedAt,
    result: item.result,
    errorMessage: item.errorMessage,
    errorStack: item.errorStack,
    progressMessage: item.progressMessage,
    progressPercent: item.progressPercent
  };
};

// schedule/index.ts
var MAX_SCHEDULES = parseInt(process.env.AMPT_MAX_SCHEDULES ?? "20");
var allowedScheduleUnits = /(minute|minutes|hour|hours|day|days)/g;
var expressionVersions = /(rate|every|cron)/g;
var specialChars = /["'()]/g;
var prettyifyRateStr = (rate) => {
  if (rate.startsWith("1")) {
    let _rate = "Every ";
    _rate += rate.replace("1 ", "");
    if (rate.endsWith("s")) {
      _rate = _rate.slice(0, -1);
    }
    return _rate;
  } else {
    return `Every ${rate}`;
  }
};
var getConfig = () => {
  const handlers = Object.values(getHandlers());
  const schedule2 = handlers.map((handler) => ({
    id: handler.id,
    invocationType: "schedule",
    schedule: handler.schedule,
    handler: handler.handler,
    name: handler.name,
    taskName: handler.taskName,
    timeout: handler.timeout
  }));
  return { schedule: schedule2 };
};
var ScheduleError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ScheduleError";
  }
};
var getHandlers = () => {
  return Schedule.handlerRegistry;
};
var Handler2 = class {
  name;
  taskName;
  id;
  schedule;
  rate;
  timeout;
  errors;
  handler;
  constructor(params) {
    const { id, rate, schedule: schedule2, handler, timeout, name, taskName } = params;
    this.name = name;
    this.rate = rate;
    this.id = id;
    this.schedule = schedule2;
    this.handler = handler;
    this.timeout = timeout;
    this.taskName = taskName;
    addEventListener(`schedule:${id}`, handler, {
      source: "schedule",
      invocationType: "schedule",
      timeout,
      id,
      name,
      // Save the human readable rate expression for dashboard UI
      meta: { schedule: schedule2, rate, taskName }
    });
    Schedule.handlerRegistry[id] = this;
  }
};
var Schedule = class _Schedule {
  handlers;
  name;
  _taskDefinition;
  errors;
  static currentIndex = 0;
  static taskCount = 0;
  static handlerRegistry = {};
  constructor(name) {
    if (name) {
      this.name = name;
    }
    this.handlers = [];
    this.errors = [];
  }
  static handle(name) {
    if (name) {
      if (name.length > 64) {
        throw new ScheduleError("Schedule name must be 64 characters or less");
      }
      const duplicate = Object.values(_Schedule.handlerRegistry).find((handler) => handler.name === name);
      if (duplicate) {
        throw new ScheduleError(`Schedule name must be unique. "${name}" is already in use.`);
      }
    }
    return new _Schedule(name);
  }
  parseExpression(expression) {
    return expression.replace(expressionVersions, "").replace(specialChars, "");
  }
  validate(expression) {
    if (expression.match(/rate/) || expression.match(/every/)) {
      if (!expression.match(allowedScheduleUnits)) {
        return false;
      }
    } else if (expression.match(/cron/)) {
      const cronExpression = expression.replace(expressionVersions, "").replace(specialChars, "");
      const cronResult = (0, import_cron_validate.default)(cronExpression, { preset: "aws-cloud-watch" });
      if (!cronResult.isValid()) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  use(scheduleConfig, ...args) {
    const { expression: schedule2, rate } = scheduleConfig;
    let [config, handler] = args;
    if (!handler) {
      handler = config;
      config = {};
    }
    if (!handler) {
      const testHandler = this.handlers.find((s10) => s10.schedule === schedule2);
      if (!testHandler) {
        throw new ScheduleError(`No handler found for schedule: ${schedule2}`);
      }
      return testHandler;
    }
    if (_Schedule.currentIndex >= MAX_SCHEDULES - 1) {
      throw new ScheduleError(`Maximum number of schedules (${MAX_SCHEDULES}) exceeded`);
    }
    const id = `schedule-${_Schedule.currentIndex}`;
    const isValidExpression = this.validate(schedule2);
    if (!isValidExpression) {
      throw new ScheduleError(`[${this.name}] Invalid schedule expression: ${schedule2}`);
    }
    _Schedule.currentIndex++;
    let { timeout = 2e4 } = config || {};
    if (timeout > 3e5) {
      console.warn(`[${this.name}] Maximum timeout for scheduled tasks is 300000 ms`);
      timeout = 3e5;
    }
    const parsedRate = rate ? prettyifyRateStr(rate) : void 0;
    this.handlers.push(
      new Handler2({
        id,
        schedule: schedule2,
        rate: parsedRate,
        handler,
        timeout,
        name: this.name,
        taskName: config.meta?.taskName
      })
    );
    return null;
  }
  cron(expression, ...args) {
    return this.use({ expression: `cron(${expression})` }, ...args);
  }
  every(rate, ...args) {
    return this.rate(rate, ...args);
  }
  rate(rate, ...args) {
    const cron2 = convertRateToCron(rate);
    const expression = cron2 ? `cron(${cron2})` : `rate(${rate})`;
    return this.use(
      {
        expression,
        rate
      },
      ...args
    );
  }
  task(...args) {
    let [config, handler] = args;
    if (!handler) {
      handler = config;
      config = {};
    }
    const taskName = this.name || `task-${_Schedule.taskCount++}`;
    this._taskDefinition = task(
      taskName,
      config,
      (event, context) => (
        // format the event to match the legacy scheduled task event format
        handler(
          {
            target: event.target,
            id: event.id,
            name: event.name,
            body: {
              source: "schedule-task",
              name: event.name,
              date: event.time,
              payload: event.body
            },
            time: event.time,
            ...event.delay && { delay: event.delay }
          },
          context
        )
      )
    );
    return this.task;
  }
  // TODO: detect if this is running inside a handler, it cannot run at root
  async at(date2, payload) {
    if (!this._taskDefinition) {
      throw new ScheduleError("at() must be called after task()");
    }
    return this._taskDefinition.run(date2, payload);
  }
};
var schedule = Schedule.handle;
var schedule_default = schedule;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Schedule,
  ScheduleError,
  convertRateToCron,
  getConfig,
  getHandlers,
  schedule
});
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

aws4fetch/dist/aws4fetch.esm.mjs:
  (**
   * @license MIT <https://opensource.org/licenses/MIT>
   * @copyright Michael Hart 2022
   *)
*/
